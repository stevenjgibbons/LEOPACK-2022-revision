C*********************************************************************
C subroutine Landau Couette Semi-Implicit Time Step subroutine *******
C            -      -       -    -        -    -               *******
C Steve Gibbons Sun May  7 19:44:40 BST 2000                         C
C____________________________________________________________________C
C                                                                    C
C Takes the matrix output by LCFTSM and uses a Predictor-corrector   C
C method, forming the RHS with LCRHSF, to solve the equation         C
C                                                                    C
C    A_t = ( lambda + 2 i kappa x - x^2 - |A|^2 ) A + d^2A/dx^2      C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C                                                                    C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C     IPIV      : Dim ( * ). Output from LCFTSM.                     C
C                                                                    C
C     LULOG     : Set to zero to avoid all output.                   C
C                 If LULOG is non-zero, progress reports are output  C
C                 to file with number LULOG.                         C
C                                                                    C
C     NOIT      : On input. NOIT = Maximum number of iterations      C
C                 permitted in the functional iteration part of the  C
C                 process in the routine.                            C
C                 On output. NOIT is number of iterations taken      C
C                 UNLESS - maximum number is exceeded (NOIT = -1)    C
C                 OR the iteration norm,                             C
C                 DABS( |V_(j)^{i+1}| - |V_{j-1}^{i+1}| )            C
C                 is actually growing (NOIT = -2).                   C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     DPARS     : Array dim (*).                                     C
C                 DPARS( 1 ) = LAMBDA                                C
C                 DPARS( 2 ) = KAPPA                                 C
C                                                                    C
C     DELTAT    : Time step.                                         C
C     CFAC      : Implicit/Explicit ratio.                           C
C                 CFAC must be greater than 0 and less than 1.       C
C                 If cfac was 1, this would be implicit.             C
C                 If cfac was 0, this would be explicit.             C
C                 cfac = 0.5 --> Crank-Nicolson.                     C
C                                                                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( 2*NBN+1, NR, 3, 1).                   C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C     VI        : Dim (*). Solution at current time step.            C
C     VIP1      : Dim (*). Solution at next time step. (Output)      C
C     DWORK     : Dim (*). Temporary vector.                         C
C     TOL       : Convergence parameter on norms.                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE LCSITS( NR, NBN, N1, N2, KL, KU, KLE, A, DPARS,
     1                   DELTAT, CFAC, XARR, SVFDC, IPIV, VI, VIP1,
     2                   DWORK, LULOG, NOIT, TOL )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, NBN, N1, N2, KL, KU, KLE, IPIV( * ), LULOG, NOIT
      DOUBLE PRECISION A( N1, N2 ), DPARS( * ), XARR( * ),
     1                 SVFDC( 2*NBN+1, NR, 3, 1 ), DELTAT, CFAC,
     2                 VI( * ), VIP1( * ), DWORK( * ), TOL
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER INFO, NRHS, NBAND, NDRVS, NDCS, MHBCS( 1 ), MHP( 2 ),
     1        INARR( 3 ), INC, ITMX, NCFM
      DOUBLE PRECISION DNRM2, ARHS, DIFF, ODIFF, AOLD
      CHARACTER *(1) TRANS
      PARAMETER ( NRHS = 1, NDCS = 1, TRANS = 'N' )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      ODIFF = 1.0d8
C
      INC        = 1
      MHBCS( 1 ) = 3
      MHP( 1 )   = 1
      MHP( 2 )   = 1
      NBAND      = 3*KL + 1
      NDRVS      = 2
      NCFM       = 2*NBN + 1
      IF ( KLE.NE.KL .OR. KU.NE.KL ) THEN
        PRINT *,' Subroutine LCSITS.'
        PRINT *,' KL  = ', KL
        PRINT *,' KU  = ', KU
        PRINT *,' KLE = ', KLE
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      INARR( 1 ) = 3
      INARR( 2 ) = NR
      INARR( 3 ) = 2
C
C At the beginning, we copy VI into VIP1 in order to make
C our predictor
C
      CALL VECCP( VI, VIP1, N2 )
C
C Form RHS vector
C
      CALL LCRHSF( NR, NBN, VI, VIP1, DWORK, DPARS,
     1             DELTAT, CFAC, XARR, SVFDC )
C
C Solve system to form predictor.
C
      CALL DGBTRS( TRANS, N2, KL, KL, NRHS, A, NBAND,
     1             IPIV, DWORK, N2, INFO )
C
      IF ( INFO.NE.0 ) THEN
        PRINT *,' Subroutine LCSITS.'
        PRINT *,' DGBTRS called and INFO returned value ',INFO
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      CALL ASVCPL( DWORK, NR, NDCS, INARR, MHP, MHBCS, MHBCS,
     1             NCFM, NDRVS, NDRVS, NBN, SVFDC )
      ARHS = DNRM2( N2, DWORK, INC )
      CALL VECCP( DWORK, VIP1, N2 )
C
C ARHS is now the norm of the (predictor) estimate.
C
      IF ( LULOG.NE.0 ) WRITE ( LULOG, 81 ) ARHS
 81   FORMAT('lcsits: Predictor norm = ',1PD16.7)
C
C Now begin functional iteration loop
C
      ITMX = NOIT
      NOIT = 0
 50   CONTINUE
      NOIT = NOIT + 1
      IF ( NOIT.GT.ITMX ) THEN
        IF ( LULOG.NE.0 ) WRITE ( LULOG, 83 )
 83     FORMAT('lcsits: Max. iterations exceeded.')
        NOIT = -1
        RETURN
      ENDIF
C
C Predictor is now stored in VIP1
C Calculate new RHS vector
C
      CALL LCRHSF( NR, NBN, VI, VIP1, DWORK, DPARS,
     1             DELTAT, CFAC, XARR, SVFDC )
C
C Solve system to form new iteration of solution.
C
      CALL DGBTRS( TRANS, N2, KL, KL, NRHS, A, NBAND,
     1             IPIV, DWORK, N2, INFO )
C
      IF ( INFO.NE.0 ) THEN
        PRINT *,' Subroutine LCSITS.'
        PRINT *,' DGBTRS called and INFO returned value ',INFO
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      CALL ASVCPL( DWORK, NR, NDCS, INARR, MHP, MHBCS, MHBCS,
     1             NCFM, NDRVS, NDRVS, NBN, SVFDC )
      AOLD = ARHS
      ARHS = DNRM2( N2, DWORK, INC )
      CALL VECCP( DWORK, VIP1, N2 )
      IF ( LULOG.NE.0 ) WRITE ( LULOG, 84 ) NOIT, ARHS
 84   FORMAT('lcsits: Iteration ',I4,' Solution norm = ',1PD16.7)
      DIFF = DABS( ARHS - AOLD )
      IF ( DIFF.LT.TOL ) THEN
        IF ( LULOG.NE.0 ) WRITE ( LULOG, 85 )
 85     FORMAT('Solution converged.')
        RETURN
      ENDIF
C
C ok - so our reiteration wasn't sufficiently
C close to return - check to see if we are getting worse
C
      IF ( DIFF.GT.ODIFF .AND. NOIT.GT.3 ) THEN
        NOIT = -2
        RETURN
      ENDIF
      ODIFF = DIFF
C
      GOTO 50
      END
C*********************************************************************
