C*********************************************************************
C                                                                    C
C Steve Gibbons - Boundary-Locked Steady, Non-Linear Solutions Calc. C
C Thu Mar 16 14:40:21 GMT 2000                                       C
C                                                                    C
C                                                                    C
C                                                                    C
C                                                                    C
C*********************************************************************
      PROGRAM blscnlsc
      IMPLICIT NONE
C_____________________________________________________________________
C                                                                    C
C Variable declarations - array defining parameters.                 C
C                                                                    C
C____________________________________________________________________C
C
      INTEGER NRMAX, LHMAX, NHMAX, NPHMAX, NTHMAX, KLMAX,
     1        NBNDMX, NDCS, NDRVM, ISVMAX, NPMAX, LHLH2M, NCFM,
     2        NBN, NRUNM, NITHMX
C
      PARAMETER ( NRMAX = 40, LHMAX = 62, NHMAX = 140, NBN = 3,
     1            NTHMAX = 64, NPHMAX = 128, KLMAX = (NBN+1)*NHMAX-1,
     2            NBNDMX = 3*KLMAX+1, NDCS = 4, NDRVM = 4, 
     3            ISVMAX = NRMAX*NHMAX, NITHMX = 100 )
      PARAMETER ( NPMAX = (LHMAX+1)*(LHMAX+2)/2, 
     1            LHLH2M = LHMAX*(LHMAX+2), NCFM = 2*NBN + 1,
     2            NRUNM = 100 )
C_____________________________________________________________________
C                                                                    C
C Variable declarations - main arrays.                               C
C                                                                    C
C____________________________________________________________________C
C
      INTEGER MHIBC( 4 ), MHOBC( 4 ), LARR( 4 ), INARR( 3 ),
     1        IPIV( ISVMAX ), MHT( NHMAX ), MHL( NHMAX ),
     2        MHM( NHMAX ), MHP( NHMAX ), MHTR( NHMAX ),
     3        IWORK( NCFM ), MHI( NHMAX ), MHP2( NHMAX )
C
      INTEGER          NRARR( NRUNM )
      INTEGER          ISPARR( NRUNM )
      INTEGER          LHARR( NRUNM )
      INTEGER          ISYMAR( NRUNM )
      INTEGER          MLOWA( NRUNM )
      INTEGER          MINCA( NRUNM )
      INTEGER          MMAXA( NRUNM )
      INTEGER          IOFARR( NRUNM )
      DOUBLE PRECISION CCARR( NRUNM )
      DOUBLE PRECISION CB1ARR( NRUNM )
      DOUBLE PRECISION CB2ARR( NRUNM )
      DOUBLE PRECISION CDARR( NRUNM )
      DOUBLE PRECISION CFARR( NRUNM )
      DOUBLE PRECISION CGARR( NRUNM )
      DOUBLE PRECISION CHARR( NRUNM )
      DOUBLE PRECISION CIARR( NRUNM )
      DOUBLE PRECISION EPSIAR( NRUNM )
      DOUBLE PRECISION EPSOAR( NRUNM )
C
      DOUBLE PRECISION DPARR( 2 ), XARR( NRMAX ), VEC( ISVMAX ),
     1                 SVFDC( NCFM, NRMAX, NDRVM+1, NDCS ),
     2                 PARAM( 12 ), FDCM( NCFM, NRMAX, 1 )
C
      DOUBLE PRECISION COEFM1( NCFM, NCFM ), WORK1( NCFM ),
     1                 COEFM2( NCFM, NCFM ), WORK2( NCFM ),
     2                 A( NBNDMX, ISVMAX ), VEC2( ISVMAX ),
     3                 GAUX( NTHMAX ), GAUW( NTHMAX )
C
      DOUBLE PRECISION PA( NPMAX, NTHMAX ), DPA( NPMAX, NTHMAX ),
     1                 CAFIT( 3, NITHMX ), SHCI( LHLH2M ), SHCIM,
     2                 SHCO( LHLH2M ), SHCOM, SHCI2( LHLH2M ),
     3                 SHCO2( LHLH2M )
C
      CHARACTER *(200) LINE
C_____________________________________________________________________
C                                                                    C
C Variable declarations - scalars and small arrays                   C
C                                                                    C
C____________________________________________________________________C
C
      INTEGER ITHEBC, IFORMF, LU, INSPCF, KL, IRUN, IFORM,
     1        N1, N2, NDRVS, NR, LH, IOP, INDFUN
C
      INTEGER NH, ISYM, MLOW, MINC, MMAX, IVELBC, NTHP, NPHP,
     1        IWRITE, IAPP, IH, MXATT, IERR, NRUNS, IR, IITH
C
      INTEGER I, ILEN, IOF, ILNR, IRNR, IZF, IREAD,
     1        L, M, ICS, IND, INDSHC, KIB, KOB, NITH, IHD
C
      INTEGER  LULOG, LUNR, LUISP, LULH, LUSYM,
     1         LUM, LUCC, LUCB1, LUCB2, LUCD, LUCF,
     2         LUCG, LUCH, LUCI, LURES, LURI, LURO, LUBC,
     3         LUEPSI, LUEPSO
C
      CHARACTER *(2)  BCH
      CHARACTER *(80) FNLOG, FNAME, FNNR, FNISP, FNLH, FNSYM,
     1                FNM, FNCC, FNCB1, FNCB2, FNCD, FNCF, ROOT,
     2                FNCG, FNCH, FNCI, FNRES, FNRI, FNRO, FNBC,
     3                FNEPSI, FNEPSO
C
      DOUBLE PRECISION RI, RO, LOW, ZERO, CD, CI, CG, CAK, CBK, CCK,
     1                 X1, X2, CC, CF, CH, CB1, CB2, RAD,
     2                 CTOL, EPSI, EPSO, COEF, DERV( 1 )
C_____________________________________________________________________
C                                                                    C
C Variable declarations - parameters and EXTERNAL declarations.      C
C                                                                    C
C____________________________________________________________________C
C
      PARAMETER ( IFORMF = 3, LU = 12, IFORM = 1, IOP = 0,
     1            IWRITE = 3, IAPP = 4, IREAD = 1 )
C
      PARAMETER ( LOW = 1.0d-7, ZERO = 0.0d0, X1 = -1.0d0,
     1            X2 = 1.0d0 )
C_____________________________________________________________________
C                  **************************************************C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      DO I = 1, 80
        ROOT(I:I) = ' '
        FNLOG(I:I) = ' '
        FNNR(I:I) = ' '
        FNISP(I:I) = ' '
        FNLH(I:I) = ' '
        FNSYM(I:I) = ' '
        FNM(I:I) = ' '
        FNCC(I:I) = ' '
        FNCB1(I:I) = ' '
        FNCB2(I:I) = ' '
        FNCD(I:I) = ' '
        FNCF(I:I) = ' '
        FNCG(I:I) = ' '
        FNCH(I:I) = ' '
        FNCI(I:I) = ' '
        FNRES(I:I) = ' '
        FNRI(I:I) = ' '
        FNRO(I:I) = ' '
        FNBC(I:I) = ' '
        FNEPSI(I:I) = ' '
        FNEPSO(I:I) = ' '
      ENDDO
C
 80   FORMAT(A)
C
C Start reading in input file
C First line contains root only
C
      PRINT *,' Program Boundary Locked Steady Solution Solve.'
      PRINT *,' Enter name which contains boundary coef.s '
      PRINT *,' ======================================== '
 21   CONTINUE
      READ ( 5, 80 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 21
C
      DO I = 1, 200
        IF ( LINE(I:I).EQ.' ' ) THEN
          ILEN = I-1
          GOTO 49
        ENDIF
      ENDDO
 49   CONTINUE
      FNAME = LINE(1:ILEN)
C
C Zero arrays of boundary coefficients
C
      SHCIM = ZERO
      SHCOM = ZERO
      CALL VECOP( SHCI, ZERO, LHLH2M, IOP )
      CALL VECOP( SHCO, ZERO, LHLH2M, IOP )
C
C Now let's read in boundary coefficients
C
      CALL FOPEN( LU, FNAME, IREAD )
 92   CONTINUE
      READ ( LU, 80, END = 93 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 92
C
      BCH = LINE(1:2)
      READ ( LINE(3:80), * ) L, M, ICS, COEF
      IF ( BCH.NE.'IB' .AND. BCH.NE.'OB' ) THEN
        PRINT *,' Start of boundary coefficient line'
        PRINT *,' must either be IB (inner) or '
        PRINT *,' OB (outer) boundary.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( L.GT.LHMAX ) THEN
        PRINT *,' Boundary coefficient with L = ', L
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IND = INDSHC( L, M, ICS )
      IF ( BCH.EQ.'IB' ) THEN
        IF ( IND.EQ.0 ) THEN
          SHCIM = COEF
        ELSE
          SHCI( IND ) = COEF
        ENDIF
      ELSE
        IF ( IND.EQ.0 ) THEN
          SHCOM = COEF
        ELSE
          SHCO( IND ) = COEF
        ENDIF
      ENDIF
C
C zeros mean heat flux variation ...
C
      SHCIM = ZERO
      SHCOM = ZERO
C
      GOTO 92
 93   CONTINUE
      CALL FCLOSE( LU, FNAME, 'Error' )
C
C next line contains name of file which contains
C spherical harmonic coefficients
C
      PRINT *,' Input file name root.'
      PRINT *,' ======================================== '
 121  CONTINUE
      READ ( 5, 80 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 121
C
      DO I = 1, 200
        IF ( LINE(I:I).EQ.' ' ) THEN
          ILEN = I-1
          GOTO 149
        ENDIF
      ENDDO
 149  CONTINUE
      ROOT = LINE(1:ILEN)
C
C next line should contain RI, RO, IVELBC, ITHEBC, LULOG
C RI must be atleast zero
C RO must be strictly greater than RI
C IVELBC = 1 --> no slip
C IVELBC = 2 --> stress free
C ITHEBC = 1 --> fixed tm inner and outer boundaries
C ITHEBC = 2 --> fixed tm inner hf outer
C ITHEBC = 3 --> fixed hf inner tm outer
C LULOG = 0 --> no output
C LULOG = 44 --> limited output
C LULOG = 45 --> extensive output
C
      PRINT *,' Enter RI, RO, IVELBC, ITHEBC, LULOG '
      PRINT *,' (ivelbc = 1 --> no slip )'
      PRINT *,' (ivelbc = 2 --> stress free)'
      PRINT *,' (ithebc = 1 --> fixed tm inner and outer)'
      PRINT *,' (ithebc = 2 --> fixed tm inner hf outer)'
      PRINT *,' (ithebc = 3 --> fixed hf inner tm outer)'
      PRINT *,' (lulog = 0  --> no output)'
      PRINT *,' (lulog = 6  --> output to screen)'
      PRINT *,' (lulog = 45  --> extensive output)'
      PRINT *,' ======================================== '
 22   CONTINUE
      READ ( 5, 80 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 22
      READ ( LINE, * ) RI, RO, IVELBC, ITHEBC, LULOG
C
      IF ( RI.LT.ZERO ) THEN
        PRINT *,' RI = ', RI
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( RO.LE.RI ) THEN
        PRINT *,' RI = ', RI
        PRINT *,' RO = ', RO
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C ri and ro seem ok
C
      DPARR( 1 ) = RI
      DPARR( 2 ) = RO
C
      IF ( IVELBC.NE.1 .AND. IVELBC.NE.2 ) THEN
        PRINT *,' IVELBC = ', IVELBC
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( ITHEBC.NE.1 .AND. ITHEBC.NE.2 .AND. ITHEBC.NE.3 ) THEN
        PRINT *,' ITHEBC = ', ITHEBC
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( LULOG.NE.0 .AND. LULOG.NE.6 .AND. LULOG.NE.145 .AND.
     1         LULOG.NE.45 ) THEN
        PRINT *,' LULOG = ', LULOG
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Fill in MHIBC, MHOBC and LARR arrays
C First poloidal velocity
C
      LARR( 1 ) = 0
      LARR( 2 ) = 0
      LARR( 3 ) = 0
      LARR( 4 ) = 0
C
      IF ( IVELBC.EQ.1 ) THEN
        MHIBC( 1 ) = 4
        MHOBC( 1 ) = 4
        MHIBC( 2 ) = 2
        MHOBC( 2 ) = 2
      ELSE
        MHIBC( 1 ) = 5
        MHOBC( 1 ) = 5
        MHIBC( 2 ) = 6
        MHOBC( 2 ) = 6
      ENDIF
C
      IF ( ITHEBC.EQ.1 ) THEN
        MHIBC( 3 ) = 2
        MHOBC( 3 ) = 2
        KIB        = 1
        KOB        = 1
      ENDIF
C
      IF ( ITHEBC.EQ.2 ) THEN
        MHIBC( 3 ) = 2
        MHOBC( 3 ) = 3
        KIB        = 1
        KOB        = 2
      ENDIF
C
      IF ( ITHEBC.EQ.3 ) THEN
        MHIBC( 3 ) = 3
        MHOBC( 3 ) = 2
        KIB        = 2
        KOB        = 1
      ENDIF
C
      MHIBC( 4 ) = 1
      MHOBC( 4 ) = 1
C
      FNLOG(1:ILEN) = ROOT(1:ILEN)
      FNLOG(ILEN+1:ILEN+4) = '.log'
      IF ( LULOG.NE.0 .AND. LULOG.NE.6 ) 
     1              CALL FOPEN ( LULOG, FNLOG, IWRITE )
C
      LUNR   = 61
      LUISP  = 62
      LULH   = 63
      LUSYM  = 64
      LUM    = 65
      LUCC   = 66
      LUCB1  = 67
      LUCB2  = 68
      LUCD   = 69
      LUCF   = 70
      LUCG   = 71
      LUCH   = 72
      LUCI   = 73
      LURES  = 74
      LURI   = 75
      LURO   = 76
      LUBC   = 77
      LUEPSI = 78
      LUEPSO = 79
C
      FNNR(1:ILEN) = ROOT(1:ILEN)
      FNISP(1:ILEN) = ROOT(1:ILEN)
      FNLH(1:ILEN) = ROOT(1:ILEN)
      FNSYM(1:ILEN) = ROOT(1:ILEN)
      FNM(1:ILEN) = ROOT(1:ILEN)
      FNCC(1:ILEN) = ROOT(1:ILEN)
      FNCB1(1:ILEN) = ROOT(1:ILEN)
      FNCB2(1:ILEN) = ROOT(1:ILEN)
      FNCD(1:ILEN) = ROOT(1:ILEN)
      FNCF(1:ILEN) = ROOT(1:ILEN)
      FNCG(1:ILEN) = ROOT(1:ILEN)
      FNCH(1:ILEN) = ROOT(1:ILEN)
      FNCI(1:ILEN) = ROOT(1:ILEN)
      FNRES(1:ILEN) = ROOT(1:ILEN)
      FNRI(1:ILEN) = ROOT(1:ILEN)
      FNRO(1:ILEN) = ROOT(1:ILEN)
      FNBC(1:ILEN) = ROOT(1:ILEN)
      FNEPSI(1:ILEN) = ROOT(1:ILEN)
      FNEPSO(1:ILEN) = ROOT(1:ILEN)
      FNAME(1:ILEN) = ROOT(1:ILEN)
C
      FNNR(ILEN+1:ILEN+3) = '.nr'
      FNISP(ILEN+1:ILEN+4) = '.isp'
      FNLH(ILEN+1:ILEN+3) = '.lh'
      FNSYM(ILEN+1:ILEN+5) = '.isym'
      FNM(ILEN+1:ILEN+2) = '.m'
      FNCC(ILEN+1:ILEN+3) = '.cc'
      FNCB1(ILEN+1:ILEN+4) = '.cb1'
      FNCB2(ILEN+1:ILEN+4) = '.cb2'
      FNCD(ILEN+1:ILEN+3) = '.cd'
      FNCF(ILEN+1:ILEN+3) = '.cf'
      FNCG(ILEN+1:ILEN+3) = '.cg'
      FNCH(ILEN+1:ILEN+3) = '.ch'
      FNCI(ILEN+1:ILEN+3) = '.ci'
      FNRES(ILEN+1:ILEN+4) = '.res'
      FNRI(ILEN+1:ILEN+3) = '.ri'
      FNRO(ILEN+1:ILEN+3) = '.ro'
      FNBC(ILEN+1:ILEN+3) = '.bc'
      FNEPSI(ILEN+1:ILEN+5) = '.epsi'
      FNEPSO(ILEN+1:ILEN+5) = '.epso'
C
      CALL FOPEN( LUNR   , FNNR   , IAPP )
      CALL FOPEN( LUISP  , FNISP  , IAPP )
      CALL FOPEN( LULH   , FNLH   , IAPP )
      CALL FOPEN( LUSYM  , FNSYM  , IAPP )
      CALL FOPEN( LUM    , FNM    , IAPP )
      CALL FOPEN( LUCC   , FNCC   , IAPP )
      CALL FOPEN( LUCB1  , FNCB1  , IAPP )
      CALL FOPEN( LUCB2  , FNCB2  , IAPP )
      CALL FOPEN( LUCD   , FNCD   , IAPP )
      CALL FOPEN( LUCF   , FNCF   , IAPP )
      CALL FOPEN( LUCG   , FNCG   , IAPP )
      CALL FOPEN( LUCH   , FNCH   , IAPP )
      CALL FOPEN( LUCI   , FNCI   , IAPP )
      CALL FOPEN( LURES  , FNRES  , IAPP )
      CALL FOPEN( LURI   , FNRI   , IAPP )
      CALL FOPEN( LURO   , FNRO   , IAPP )
      CALL FOPEN( LUBC   , FNBC   , IAPP )
      CALL FOPEN( LUEPSI , FNEPSI , IAPP )
      CALL FOPEN( LUEPSO , FNEPSO , IAPP )
C
C Next line should contain MXATT, CTOL
C
      PRINT *,' Enter MXATT, CTOL '
      PRINT *,' MXATT = number of attempts allowed '
      PRINT *,' to iterate to non-linear solution.'
      PRINT *,' CTOL = convergence criterion.'
 23   CONTINUE
      READ ( 5, 80 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 23
      READ ( LINE, * ) MXATT, CTOL
C
C Now loop around until we have solved all the
C required problems ... these parameters are
C
C NR, INSPCF, LH, ISYM, MLOW, MINC, MMAX, IOF
C CC, CB1, CB2, CD, CF, CG, CH, CI
C
C (inspcf = 1 --> equally spaced nodes )
C (inspcf = 2 --> Chebyshev nodes )
C isym = 1 for Equatorially symmetric modes
C isym = 2 for Equatorially anti-symmetric modes
C isym = 3 for both symmetries
C IOF = 0 --> no write out of eigenfunctions etc.
C IOF = 1 --> standard output of homogeneous eigenfunctions
C IOF = 2 --> visual output of radial functions.
C IOF = 3 --> standard output of full solution (with inhom. bdry)
C IOF = 4 --> standard output of hom and inhom. boundary)
C
      NRUNS = 0
 24   CONTINUE
      READ ( 5, 80, END=300 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 24
      NRUNS = NRUNS + 1
      IF ( NRUNS.GT.NRUNM ) THEN
        PRINT *,' NRUNM exceeded. Either recompile'
        PRINT *,' or change inputs.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
      READ ( LINE, * )  NRARR( NRUNS ), ISPARR( NRUNS ),
     1       LHARR( NRUNS ), ISYMAR( NRUNS ), MLOWA( NRUNS ), 
     2       MINCA( NRUNS ), MMAXA( NRUNS ), IOFARR( NRUNS ),
     3       CCARR( NRUNS ), CB1ARR( NRUNS ), CB2ARR( NRUNS )
 25   CONTINUE
      READ ( 5, 80 ) LINE
      IF ( LINE(1:1).EQ.'*' ) GOTO 25
      READ ( LINE, * ) CDARR( NRUNS ), CFARR( NRUNS ),
     1       CGARR( NRUNS ), CHARR( NRUNS ), CIARR( NRUNS ),
     2       EPSIAR( NRUNS ), EPSOAR( NRUNS )
      GOTO 24
 300  CONTINUE
C
C
C
C o.k. - now we have read in all our parameters
C so let's loop around one by one ....
C
      DO IRUN = 1, NRUNS
C
C Zero VEC for new run ...
C
      CALL VECOP( VEC, ZERO, ISVMAX, IOP )
C
       NR = NRARR( IRUN )
       INSPCF = ISPARR( IRUN )
       LH = LHARR( IRUN )
       ISYM = ISYMAR( IRUN )
       MLOW = MLOWA( IRUN )
       MINC = MINCA( IRUN )
       MMAX = MMAXA( IRUN )
       IOF  = IOFARR( IRUN )
       CC   = CCARR( IRUN )
       CB1  = CB1ARR( IRUN )
       CB2  = CB2ARR( IRUN )
       CD   = CDARR( IRUN )
       CF   = CFARR( IRUN )
       CG   = CGARR( IRUN )
       CH   = CHARR( IRUN )
       CI   = CIARR( IRUN )
       EPSI = EPSIAR( IRUN )
       EPSO = EPSOAR( IRUN )
C
C Check values for NR, INSPCF
C
      IF ( NR.LT.10 .OR. NR.GT.NRMAX ) THEN
        PRINT *,' NR = ', NR,' NRMAX = ', NRMAX
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( INSPCF.NE.1 .AND. INSPCF.NE.2 ) THEN
        PRINT *,' INSPCF = ', INSPCF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( INSPCF.EQ.1 ) THEN
        CALL ESNAAS( NR, XARR, RI, RO )
      ELSE
        CALL ZCPAAS( NR, XARR, RI, RO )
      ENDIF
C
      IF ( LH.GT.LHMAX ) THEN
        PRINT *,' LH    = ', LH
        PRINT *,' LHMAX = ', LHMAX
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( ISYM.NE.1 .AND. ISYM.NE.2 .AND. ISYM.NE.3 ) THEN
        PRINT *,' ISYM  = ', ISYM
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Now read to calculate Legdendre Functions etc.
C
      CALL ONTPPF( LH, MMAX, NTHP, NPHP, NTHMAX, NPHMAX )
      CALL GAUWTS ( X1, X2, GAUX, GAUW, NTHP )
      CALL SCHNLA ( PA, DPA, GAUX, LH, NTHP )
C
C Now calculate the full harmonic sets
C
      CALL VTHMSR( ISYM, NH, MLOW, MINC, MMAX, NHMAX, MHT, MHL,
     1             MHM, LH, LHMAX )
C
      CALL CINDSW ( NH, MHT, MHTR )
      PRINT *,' Total of ', NH,' harmonics. '
C
      INARR( 1 ) = IFORMF
      INARR( 2 ) = NR
      INARR( 3 ) = NH
C
      KL = (NBN+1)*NH - 1
      N1 = 3*KL + 1
      N2 = NH*NR
C
      IF ( CD.LT.LOW .OR. CI.LT.LOW .OR. CG.LT.ZERO ) THEN
        PRINT *,' CD = ', CD
        PRINT *,' CI = ', CI
        PRINT *,' CG = ', CG
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Now set up array MHP
C this is straightforward as we only have 3 types
C
      DO IH = 1, NH
        MHP( IH ) = MHT( IH )
      ENDDO
C
C Form SVFDC matrix
C
      NDRVS = 1
      CALL SVFDCF( NR, NDCS, NBN, 1, 1, MHIBC, MHOBC,
     1             LARR, NCFM, NCFM, NDRVS, NDRVM, XARR,
     2             IWORK, SVFDC, COEFM1, COEFM2, WORK1, WORK2 )
C
      NDRVS = 4
      CALL SVFDCF( NR, NDCS, NBN, 2, NR-1, MHIBC, MHOBC,
     1             LARR, NCFM, NCFM, NDRVS, NDRVM, XARR,
     2             IWORK, SVFDC, COEFM1, COEFM2, WORK1, WORK2 )
C
      CALL FDCMBD( NR, NBN, 2, NR-1, 2, NR-1, NCFM,
     1             NCFM, 1, 1, IWORK, XARR, FDCM,
     2             COEFM1, WORK1, WORK2 )
C
      NDRVS = 1
      CALL SVFDCF( NR, NDCS, NBN, NR, NR, MHIBC, MHOBC,
     1             LARR, NCFM, NCFM, NDRVS, NDRVM, XARR,
     2             IWORK, SVFDC, COEFM1, COEFM2, WORK1, WORK2 )
C
C*****************************
C Here we must form the array
C CAFIT which contains the
C coefficients which represent
C the inhomogeneous boundary
C condition.
C*****************************
      CALL SHCANC( LH, SHCI, SHCI2, EPSI )
      CALL SHCANC( LH, SHCO, SHCO2, EPSO )
      NITH = 0
      CALL ITHCAR( KIB, KOB, NITH, NITHMX, NH, MHT, MHL, MHM,
     1             MHI, LH, RI, RO, SHCI2, SHCIM, SHCO2, SHCOM,
     2             CAFIT )
C*****************************
      PARAM(  2 ) = CB1
      PARAM(  3 ) = CB2
      PARAM(  4 ) = CC 
      PARAM(  5 ) = CD 
      PARAM(  7 ) = CF 
      PARAM(  8 ) = CG 
      PARAM(  9 ) = CH 
      PARAM( 10 ) = CI    
      PARAM( 12 ) = CTOL
C
      CALL BLCNRS( VEC, INARR, NR, PARAM, MXATT, IERR, A, N1,
     1  N2, KL, MHT, MHL, MHM, MHP, MHTR, NBN, NCFM, NDRVM, NDCS,
     2  NTHP, NPHP, MMAX, LH, MHIBC, MHOBC, IPIV, LULOG, SVFDC, XARR,
     3  GAUX, GAUW, PA, DPA, FDCM, MHI, CAFIT )
C
 701  FORMAT(I4)
 702  FORMAT(I1)
 703  FORMAT(1PD16.8)
 704  FORMAT(I2,I2)
 705  FORMAT(1PD16.8)
 706  FORMAT(I4,I4,I4)
C
      IF ( IERR.GT.0 ) THEN
        WRITE ( LUNR, 701 ) NR
        WRITE ( LUISP, 702 ) INSPCF
        WRITE ( LULH, 701 ) LH
        WRITE ( LUSYM, 702 ) ISYM
        WRITE ( LUM, 706 ) MLOW, MINC, MMAX
        WRITE ( LUCC, 703 ) CC
        WRITE ( LUCB1 , 703 ) CB1
        WRITE ( LUCB2 , 703 ) CB2
        WRITE ( LUCD  , 703 ) CD
        WRITE ( LUCF  , 703 ) CF
        WRITE ( LUCG  , 703 ) CG
        WRITE ( LUCH  , 703 ) CH
        WRITE ( LUCI  , 703 ) CI
        WRITE ( LURES , 705 ) CH
        WRITE ( LURI  , 703 ) RI
        WRITE ( LURO  , 703 ) RO
        WRITE ( LUBC  , 704 ) IVELBC, ITHEBC
      ELSE
        PRINT *,' IRUN = ', IRUN,' IERR = ', IERR
        PRINT *,' Solution unsuccessful.'
      ENDIF
C
C We have to write out the critical eigenvector
C in the standard format ...
C
      IF ( IOF.EQ.1 .OR. IOF.EQ.4 ) THEN
C       .
C       . We need to apply a filename
C       . for the .vecs, .xarr and .ints files
C       . FNAME(1:ILEN) contains root
C       .
        IF ( IRUN.GE.1 .AND. IRUN.LT.10 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 811 ) IRUN
        IF ( IRUN.GE.10 .AND. IRUN.LT.100 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 812 ) IRUN
        IF ( IRUN.GE.100 .AND. IRUN.LT.1000 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 813 ) IRUN
C
C Write out the harmonic integers file
C
        FNAME(ILEN+8:ILEN+12) = '.ints'
        FNAME = FNAME(1:ILEN+12)
        CALL HMFWT( NH, MHT, MHL, MHM, MHP, NDCS, MHIBC, MHOBC,
     1            LU, FNAME )
C
C Write out the eigenvectors
C
        FNAME(ILEN+8:ILEN+12) = '.vecs'
        FNAME = FNAME(1:ILEN+12)
        CALL SVFWT( INARR, LU, IFORM, VEC, FNAME )
C
C Write out radial node data
C
        FNAME(ILEN+8:ILEN+12) = '.xarr'
        FNAME = FNAME(1:ILEN+12)
        CALL XARRWT( NR, XARR, LU, FNAME, IFORM )
C       .
      ENDIF
C
C We have to write out the eigenvector
C WITH THE INHOMOGENEOUS TEMPERATURE
C
      IF ( IOF.EQ.3 .OR. IOF.EQ.4 ) THEN
        IHD = 0
C       .
        DO IH = 1, NH
          IF ( MHT( IH ).EQ.3 ) THEN
            MHP2( IH ) = 4
            IITH   = MHI( IH )
            CAK    = CAFIT( 1, IITH )
            CBK    = CAFIT( 2, IITH )
            CCK    = CAFIT( 3, IITH )
            DO IR = 1, NR
              RAD = XARR( IR )
C             .
              IND = INDFUN( IR, IH, INARR )
              DERV( 1 ) = 0.0d0
C
              CALL ITFA( RAD, RI, RO, CAK, CBK, CCK, DERV, IHD )
C             .
              VEC2( IND ) = VEC( IND ) + DERV( 1 )
C             .
            ENDDO
         ELSE
            MHP2( IH ) = MHP( IH )
            DO IR = 1, NR
              IND = INDFUN( IR, IH, INARR )
              VEC2( IND ) = VEC( IND )
            ENDDO
         ENDIF
        ENDDO
C       .
C       . We need to apply a filename
C       . for the .inhom, .xarr and .ints files
C       . FNAME(1:ILEN) contains root
C       .
        IF ( IRUN.GE.1 .AND. IRUN.LT.10 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 811 ) IRUN
        IF ( IRUN.GE.10 .AND. IRUN.LT.100 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 812 ) IRUN
        IF ( IRUN.GE.100 .AND. IRUN.LT.1000 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 813 ) IRUN
C
C Write out the harmonic integers file
C
        FNAME(ILEN+8:ILEN+12) = '.ints'
        FNAME = FNAME(1:ILEN+12)
        CALL HMFWT( NH, MHT, MHL, MHM, MHP2, NDCS, MHIBC, MHOBC,
     1            LU, FNAME )
C
C Write out the eigenvectors
C
        FNAME(ILEN+8:ILEN+13) = '.inhom'
        FNAME = FNAME(1:ILEN+13)
        CALL SVFWT( INARR, LU, IFORM, VEC2, FNAME )
C
C Write out radial node data
C
        FNAME(ILEN+8:ILEN+12) = '.xarr'
        FNAME = FNAME(1:ILEN+12)
        CALL XARRWT( NR, XARR, LU, FNAME, IFORM )
C       .
      ENDIF
C
C We have to write out the critical eigenvector
C in the visual display format
C
      IF ( IOF.EQ.2 ) THEN
C       .
C       . We need to apply a filename
C       . for the .disp file
C       . FNAME(1:ILEN) contains root
C       .
        IF ( IRUN.GE.1 .AND. IRUN.LT.10 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 811 ) IRUN
        IF ( IRUN.GE.10 .AND. IRUN.LT.100 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 812 ) IRUN
        IF ( IRUN.GE.100 .AND. IRUN.LT.1000 )
     1     WRITE (  FNAME(ILEN+1:ILEN+7), 813 ) IRUN
C
C Write out the harmonic integers file
C
        FNAME(ILEN+8:ILEN+12) = '.disp'
        FNAME = FNAME(1:ILEN+12)
        ILNR  = 1
        IRNR  = NR
        IZF   = 2
        CALL FOPEN( LU, FNAME, IWRITE )
        CALL SVPRNT ( VEC, NR, INARR, DPARR, XARR, MHT, MHL,
     1                MHM, ILNR, IRNR, LU, IZF, IFORM )
        CALL FCLOSE ( LU, FNAME, 'Error in closing FNAME' )
C       .
      ENDIF
C
 811  FORMAT('.run00',I1)
 812  FORMAT('.run0',I2)
 813  FORMAT('.run',I3)
C
      ENDDO
      PRINT *,' Program finishing.'
      CALL FCLOSE( LUNR   , FNNR   , 'Error' )
      CALL FCLOSE( LUISP  , FNISP  , 'Error' )
      CALL FCLOSE( LULH   , FNLH   , 'Error' )
      CALL FCLOSE( LUSYM  , FNSYM  , 'Error' )
      CALL FCLOSE( LUM    , FNM    , 'Error' )
      CALL FCLOSE( LUCC   , FNCC   , 'Error' )
      CALL FCLOSE( LUCB1  , FNCB1  , 'Error' )
      CALL FCLOSE( LUCB2  , FNCB2  , 'Error' )
      CALL FCLOSE( LUCD   , FNCD   , 'Error' )
      CALL FCLOSE( LUCF   , FNCF   , 'Error' )
      CALL FCLOSE( LUCG   , FNCG   , 'Error' )
      CALL FCLOSE( LUCH   , FNCH   , 'Error' )
      CALL FCLOSE( LUCI   , FNCI   , 'Error' )
      CALL FCLOSE( LURES  , FNRES  , 'Error' )
      CALL FCLOSE( LURI   , FNRI   , 'Error' )
      CALL FCLOSE( LURO   , FNRO   , 'Error' )
      CALL FCLOSE( LUBC   , FNBC   , 'Error' )
      CALL FCLOSE( LUEPSI , FNEPSI , 'Error' )
      CALL FCLOSE( LUEPSO , FNEPSO , 'Error' )
      IF ( LULOG.NE.0 .AND. LULOG.NE.6  )
     1     CALL FCLOSE ( LULOG, FNLOG, 'Error in closing file.' )
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine VECtor OPeration ****************************************
C Steve Gibbons 22.4.97 Fills vector with a constant, multiplies a   C
C                       vector by a constant or adds a constant.     C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IOP	: Type of operation required.                        C
C                  IOP=0  -->  Each element of the vector = CONST    C
C                  IOP=1  -->  Each el. is multiplied by CONST       C
C                  IOP=2  -->  Each el. is added to CONST            C
C     N		: Length of the vector.                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VEC	: Vector - dimension ( N )                           C
C     CONST     : Double precision constant.                         C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VECOP ( VEC, CONST, N, IOP )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER N, IOP
      DOUBLE PRECISION VEC( N ), CONST
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First do the case of making an element constant.
      IF ( IOP.EQ.0 ) THEN
         DO I = 1, N
            VEC ( I ) = CONST
         ENDDO
         RETURN
      ENDIF
C Now do multiplying a vector
      IF ( IOP.EQ.1 ) THEN
         DO I = 1, N
            VEC ( I ) = VEC( I )*CONST
         ENDDO
         RETURN
      ENDIF
C Now do adding a vector
      IF ( IOP.EQ.2 ) THEN
         DO I = 1, N
            VEC ( I ) = VEC( I ) + CONST
         ENDDO
         RETURN
      ENDIF
C____________________________________________________________________C

      PRINT *,' Subroutine VECOP. IOP must be 0, 1 or 2.'
      PRINT *,'Program aborted.'
      STOP
      END
C*********************************************************************


C********************************************************************
C SUBROUTINE File OPEN **********************************************
C            -    ---- **********************************************
C Steve Gibbons 14.4.97 (Adapted from Dan Gordon's Code)            C
C Routine modified 15.3.99
C___________________________________________________________________C
C Opens a file with number LU, name FNAME, access OACCES  and       C
C a flag IRW to indicate whether the file is to be read or written  C
C to. ( IRW=1 ==> read only, IRW=2 ==> write but only if the file   C
C doesn't already exist, IRW=3 ==> write regardless of whether file C
C exists or not.)						    C
C___________________________________________________________________C
C Input Variables :-						    C
C ===============   						    C
C  Integer							    C
C  -------							    C
C     LU	: File number					    C
C     IRW	: Read / Write Flag 				    C
C                  = 1 for read only		                    C
C                  = 2 for write (provided that file doesn't exist. C
C                  = 3 for write (regardless of existence of file.  C
C                  = 4 for append status.                           C
C  Character							    C
C  ---------							    C
C     FNAME	: File name					    C
C___________________________________________________________________C
C Working Variables :-						    C
C =================   						    C
C  Character							    C
C  ---------							    C
C     OACCES 	: Access flag - should be set to 'OLD' for read     C
C                          and 'UNKNOWN' for write                  C
C     CONTYN    : For a yes/no to IWR = 2 option.		    C
C     LABEL     : Null string to pass into FNAMER option.	    C
C  Logical							    C
C  -------							    C
C     LEXIST	: Existence of file. File present <==> LEXIST=.TRUE.C
C___________________________________________________________________C
C Subroutines Used :-                                               C
C ================                                                  C
C     FNAMER	: For the case of IRW = 2; trying to write to an    C
C		   existing file. Used if alternative filename is   C
C                   asked for.					    C
C___________________________________________________________________C
C
C********************************************************************
      SUBROUTINE FOPEN ( LU, FNAME, IRW)
      IMPLICIT NONE
C___________________________________________________________________C
C Variable declarations - Parameters ...............................C
      INTEGER LU, IRW
      CHARACTER *(*) FNAME
C___________________________________________________________________C
C Variable declarations - Working Variables ........................C
      LOGICAL LEXIST
      CHARACTER *(7) OACCES
      CHARACTER *(1) CONTYN
      CHARACTER *(1) LABEL
C___________________________________________________________________C
      IF ( LU.EQ.0 ) THEN
         PRINT *,' Subroutine FOPEN'
         PRINT *,' I bet you ve forgotten to set LU ...??'
         PRINT *,' Think again and come back when you have'
         PRINT *,' remembered that LU must be a non zero integer!'
         PRINT *,' See you later. Bye for now!!'
         STOP
      ENDIF
C************************
C temporary code : SJG Thu Jun  1 08:07:06 BST 2000
C The Linux compiler will not allow file opening with
C lu.ge.100, so the following line should prevent it.
C 
      IF ( LU.GT.99 ) THEN
         PRINT *,' Subroutine FOPEN'
         PRINT *,' LU = ', LU,' too large.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C************************
C--------------
 600  CONTINUE
      INQUIRE (FILE=FNAME, EXIST=LEXIST)
C Case of read only - LEXIST must be = .TRUE.
      IF ( IRW.EQ.1 ) THEN
         OACCES = 'OLD'
         IF ( .NOT. LEXIST ) THEN
            PRINT *,' Subroutine FOPEN. You are trying to open an'
            PRINT *,' old file which does not exist.'
            PRINT *,' Filename = ',FNAME,' LU= ',LU
            PRINT *,' Program aborted.'
            STOP
         ELSE
            GOTO 500
         ENDIF
      ENDIF
C Case of write to file provided that it doesn't exist
      IF ( IRW.EQ.2 ) THEN
         OACCES = 'UNKNOWN'
         IF ( LEXIST ) THEN
            PRINT *, ' Subroutine FOPEN. You are trying to write'
            PRINT *, ' to an existing file with IRW set to 2.'
            PRINT *,' Filename = ',FNAME,' LU= ',LU
            PRINT *,' Do you wish to give an alternative FNAME?'
            PRINT *,' Type y or n.'
            READ ( 5, 267) CONTYN
 267         FORMAT (A)
            IF (CONTYN.NE.'y'.AND.CONTYN.NE.'Y') THEN
               PRINT *, ' Program Aborted.'
               STOP
            ELSE
               LABEL=' '
               CALL FNAMER ( FNAME, LABEL )
               GOTO 600
            ENDIF
         ELSE
            GOTO 500
         ENDIF
      ENDIF
C Case of write to file regardless of the existence of file.
      IF ( IRW.EQ.3 ) THEN
         OACCES = 'UNKNOWN'
         GOTO 500
      ENDIF
C Treat appendment case
      IF ( IRW.EQ.4 ) THEN
         OACCES = 'UNKNOWN'
         OPEN ( UNIT=LU , FILE=FNAME , STATUS=OACCES,
     1          ACCESS='APPEND', ERR=999 )
         RETURN
      ENDIF
C___________________________________________________________________C
C All the IRW cases as of 14.4.97 have now been covered.
      PRINT *,' Subroutine FOPEN. IRW must be set to 1, 2, 3 or 4.'
      PRINT *,' Program aborted.'
      STOP

 500  CONTINUE
      OPEN ( UNIT=LU , FILE=FNAME , STATUS=OACCES, ERR=999 )
      RETURN

 999  PRINT *,' Subroutine FOPEN. Error in opening file ',FNAME
      STOP

      END
C********************************************************************
C___________________________________________________________________C
C********************************************************************
C subroutine File CLOSE *********************************************
C            -    ----- *********************************************
C Steve Gibbons 14.4.97                                             C
C  ( note that this is essentially the routine of Dan Gordon        C
C___________________________________________________________________C
C Closes file with integer logical unit LU, filename FNAME.         C
C LABEL contains any other information regarding the nature of the  C
C the file.							    C
C___________________________________________________________________C
C Input Variables :-						    C
C ===============						    C
C  Integer							    C
C  -------							    C
C     LU	: Number of file.				    C
C  Character							    C
C  ---------							    C
C     FNAME	: Name of file. Undefined length		    C
C     LABEL	: Any further information. Undefined length         C
C___________________________________________________________________C
C
C********************************************************************
      SUBROUTINE FCLOSE ( LU, FNAME, LABEL )
      IMPLICIT NONE
C___________________________________________________________________C
C Variable Declarations - Parameters ...............................C
      INTEGER LU
      CHARACTER *(*) FNAME
      CHARACTER *(*) LABEL
C___________________________________________________________________C
C START OF PROGRAM *************************************************C
C___________________________________________________________________C
      IF ( LU.EQ.0 ) THEN
         PRINT *,' Subroutine FCLOSE '
         PRINT *,' I bet you ve forgotten to set LU ...??'
         PRINT *,' Think again and come back when you have'
         PRINT *,' remembered that LU must be a non zero integer!'
         PRINT *,' See you later. Bye for now!!'
         STOP
      ENDIF
C----------------------------
      CLOSE (UNIT=LU, STATUS='KEEP', ERR=989 )
      RETURN
C
 989  PRINT *,' Error.  Failed to close ', LABEL, ' file ', FNAME
      STOP
      END
C********************************************************************
C*********************************************************************
C subroutine Equally Spaced Node Abscissa Allocation Subroutine. *****
C            -       -      -    -        -          -           *****
C Steve Gibbons Thu Oct 21 11:35:00 BST 1999                         C
C                                                                    C
C This short routine simply fills the array XARR with xvalues        C
C which are evenly spaced with                                       C
C                                                                    C
C  x_j = r_i + ( j - 1 )*h with h = ( r_o - r_i )/( nr - 1 )         C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Array of dimension (  NR  ).                       C
C                  XARR( i ) contains the value of x or r at the     C
C                   i^{th} radial grid node.                         C
C                                                                    C
C     RI        : Radius of inner boundary                           C
C     RO        : Radius of outer boundary                           C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of grid nodes.                              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ESNAAS( NR, XARR, RI, RO)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR
      DOUBLE PRECISION RI, RO, XARR( NR )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IR
      DOUBLE PRECISION H, TOL
      PARAMETER ( TOL = 1.0d-7 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IF ( NR.LT.4 ) THEN
         PRINT *,' Subroutine ESNAAS.'
         PRINT *,' NR = ', NR
         STOP
      ENDIF
C
      IF ( (RO-RI).LT.TOL ) THEN
         PRINT *,' Subroutine ESNAAS.'
         PRINT *,' RI = ', RI
         PRINT *,' RO = ', RO
         STOP
      ENDIF
C
      H = ( RO - RI )/DBLE( NR - 1 )
      DO IR = 1, NR
        XARR( IR ) = RI + DBLE( IR - 1 )*H
      ENDDO
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Zeroes of Chebyshev Polynomial Abscissa Allocation Sub. *
C            -         -         -          -        -          -    *
C Steve Gibbons Tue Sep 21 17:46:55 BST 1999                         C
C This routine is almost entirely derived from ZECHGA written        C
C by D. Funaro of Consiglio Nazionale Delle Ricerche,                C
C Via Abbiategrasso, 209 - 27100 Pavia, Italy.                       C
C However, rather than giving the N zeros of the Chebyshev polynom.  C
C of degree N in the interval (-1,1), it returns XARR( 1 ) = RI,     C
C XARR( NR ) = RO and XARR( i + 1 ) as the i^{th} zero of the        C
C Chebyshev polynomial of degree (NR-2) scaled into the interval     C
C (RI,RO) ie. x := (ro-ri)(x+1.0d0)/2.0d0 + ri                       C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Array of dimension (  NR  ).                       C
C                  XARR( i ) contains the value of x or r at the     C
C                   i^{th} radial grid node.                         C
C                                                                    C
C     RI        : Radius of inner boundary                           C
C     RO        : Radius of outer boundary                           C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of grid nodes.                              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ZCPAAS( NR, XARR, RI, RO)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR
      DOUBLE PRECISION RI, RO, XARR( NR )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER N, N2, I, IN
      DOUBLE PRECISION PH, DN, C, SI, DI, CSX, RIPRO2,
     1                 RIMRO2
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IF ( NR.LT.4 ) THEN
         PRINT *,' Subroutine ZCPAAS.'
         PRINT *,' NR = ', NR
         STOP
      ENDIF
C
      IF ( RI.GE.RO ) THEN
         PRINT *,' Subroutine ZCPAAS.'
         PRINT *,' RI = ', RI
         PRINT *,' RO = ', RO
         STOP
      ENDIF
C
      RIPRO2 = 0.5d0*(RO + RI)
      RIMRO2 = 0.5d0*(RO - RI)
C
      XARR(  1 ) = RI
      XARR( NR ) = RO
      N = NR - 2
      XARR(2) = 0.D0
      N2 = N/2
      IN = 1+4*N2-2*N
      PH = 1.57079632679489661923D0
      DN = DFLOAT(N)
      C  = PH/DN
      SI = -1.D0
      DO 10 I = 1, N2
         DI = DFLOAT(I)
         CSX = DCOS(C*(2.D0*DI-1.D0))
         XARR(I+1) = (1.0d0-CSX)*RIMRO2 + RI
         XARR(N-I+2) = (1.0d0+CSX)*RIMRO2 + RI
         SI = -SI
 10   CONTINUE
C
      IF (IN .EQ. 1) RETURN
      XARR(N2+2) = RIPRO2
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Optimum Number of Theta and Phi Points Find *************
C            -       -         -         -   -      -    *************
C Steve Gibbons 9.9.97                                               C
C____________________________________________________________________C
C For a given level of harmonics LH; this routine will return a      C
C number of theta points ( NTHPTS ) which is greater then LH         C
C and less than or equal to NTHMAX. Also a number of PHI points      C
C ( NPHPTS ) which is greater than 2*MMAX and is also a              C
C power of 2 and is also smaller than NPHMAX. Failiure to do either  C
C will be reported.                                                  C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     LH        : Highest degree, l, of spherical harmonic.          C
C     MMAX      : Highest order, m, of spherical harmonic.           C
C                                                                    C
C     For a fully 3-D problem, MMAX will equal LH but may be         C
C     less if certain symmetries are applied in the azimuthal        C
C     direction.                                                     C
C                                                                    C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     NTHMAX    : Maximum number of theta points.                    C
C     NPHMAX    : Maximum number of phi points.                      C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ONTPPF ( LH, MMAX, NTHPTS, NPHPTS, NTHMAX, NPHMAX )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, MMAX, NTHPTS, NPHPTS, NTHMAX, NPHMAX
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IF ( LH.EQ.0 ) THEN
        PRINT *,' Subroutine ONTPPF. LH = 0.'
        STOP
      ENDIF
C
      IF ( MMAX.LT.0 .OR. MMAX.GT.LH ) THEN
        PRINT *,' Subroutine ONTPPF. MMAX = ', MMAX
        PRINT *,' Must be between 0 and LH (= ',LH,')'
        STOP
      ENDIF
C
      NPHPTS = 2
 500  CONTINUE
      IF ( 2*MMAX.GE.NPHPTS ) THEN
         NPHPTS = NPHPTS*2
         GOTO 500
      ENDIF
      IF ( NPHPTS.GT.NPHMAX ) THEN
         PRINT *,' Subroutine ONTPPF.'
         PRINT *,' NPHPTS must be atleast ', NPHPTS
         PRINT *,' NPHMAX = ', NPHMAX
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      NTHPTS = LH+1
      IF ( NTHPTS/2*2.NE.NTHPTS ) NTHPTS = NTHPTS + 1
      IF ( NTHPTS.GT.NTHMAX ) THEN
         PRINT *,' Subroutine ONTPPF.'
         PRINT *,' NTHPTS must be atleast ', LH+1
         PRINT *,' NTHMAX = ', NTHMAX
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine GAUWTS **************************************************
C Adapted 22.4.97 from Numerical Recipes routine GAULEG              C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NTHPTS	: Number of theta points.                            C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     X1	: Starting value for integration.                    C
C     X2	: Ending value for integration.                      C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX	: Array containing abscissae of the Gauss-Legendre   C
C                  NTHPTS-points quadrature formula.                 C
C     GAUW      : Array containing the weights for the above points. C
C                                                                    C
C ( Both GAUX and GAUW have dimension NTHPTS ).                      C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE GAUWTS ( X1, X2, GAUX, GAUW, NTHPTS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NTHPTS
      DOUBLE PRECISION X1, X2, GAUX( NTHPTS ), GAUW( NTHPTS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER M,I,J
      DOUBLE PRECISION XM,XL,P1,P2,P3,EPS,PP,Z,Z1
      PARAMETER (EPS=1.0d-13)
      DOUBLE PRECISION PI
      PARAMETER (PI=3.14159265358979312D0)
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C 
      IF ( ABS( X1 - X2 ).LT.EPS ) THEN
        PRINT *,' Subroutine GAUWTS,'
        PRINT *,' X1 = ', X1
        PRINT *,' X2 = ', X2
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C ....... the roots are symmetric in the interval so need only find
C half of them.
      M = ( NTHPTS + 1 )/2
      XM = 0.5d0 * ( X2 + X1 )
      XL = 0.5d0 * ( X2 - X1 )
C ........start looping over the desired roots .......................
      DO I = 1, M
         Z = DCOS( PI*( DBLE(I) - 0.25d0)/( DBLE(NTHPTS) + 0.5d0 ))
C           ..... starting with this approximation to the Ith root, we
C                enter the main loop of refinement by Newton's method.
 100     CONTINUE
            P1 = 1.0D0
            P2 = 0.0D0
C           ........... Loop up the recurrence relation to get the
C                      legendre Polynomial evaluated at Z.
            DO J = 1, NTHPTS
               P3 = P2
               P2 = P1
               P1 = ((2.0d0*J-1.0d0)*Z*P2 - (J-1.0d0)*P3)/DBLE( J )
            ENDDO
C           ..................... finish recurrence relation loop ...
C ... P1 is now the desired Legendre Polynomial. We now compute PP,
C    its derivative by a standard relation involving also P2, the 
C    polynomial of one order lower.
            PP = NTHPTS*(Z*P1-P2)/(Z*Z-1.0d0)
            Z1 = Z
            Z = Z1 - P1/PP
         IF ( ABS(Z-Z1).GT.EPS ) GOTO 100
C ...........scale the root to the desired interval .................
         GAUX( I ) = XM - XL*Z
C ...........and add its symmetric counterpart ......................
         GAUX( NTHPTS+1-I ) = XM + XL*Z
C ...........calculate the weight ...................................
         GAUW( I ) = 2.0d0*XL/((1.0d0-Z*Z)*PP*PP)
C ...........and add its symmetric counterpart ......................
         GAUW( NTHPTS + 1 - I ) = GAUW( I )
      ENDDO
C ......... end looping over the desired roots .......................
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine SCHmidt Normalised Legendre function Array **************
C            ---     -          -                 -     **************
C Steve Gibbons 22.4.97                                              C
C____________________________________________________________________C
C Does the same as SCHNLF except that instead of a single valued X   C
C for one theta point, it fills arrays PA and DPA with the           C
C legendre Functions etc. for each of the NTHPTS values of cos(theta)C
C in the array GAUX.                                                 C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     LH	: Highest degree, l, of spherical harmonic.          C
C     NTHPTS	: Number of theta points.                            C
C  Double Precision                                                  C
C  ----------------                                                  C
C     PA	: Schmidt Normalised Legendre Functions Dimension.   C
C		   {  ( LH + 1 )*( LH + 2 )/2 , NTHPTS }             C
C		   P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA	: Derivatives of the above.                          C
C     GAUX	: Array of cosines to the NTHPTS angles.             C
C                  Dimension ( NTHPTS ).                             C
C____________________________________________________________________C
C Functions ... Calling Proceedures :-                               C
C  Double Precision                                                  C
C  ----------------                                                  C
C PMM ( M, S )					                     C
C DPMM ( M, C, S )				                     C
C PMM1 ( M, X, PMM0 )                                                C
C PLM ( L, M, X, PLMIN1, PLMIN2 )				     C
C DPMM1 ( M , X , S, PMM , DPMM)                                     C
C DPLM ( L, M , X , S, PMM1 , DPMM1, DPMM2 )                         C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SCHNLA ( PA, DPA, GAUX, LH, NTHPTS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, NTHPTS
      DOUBLE PRECISION GAUX( NTHPTS ),
     1                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     2                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER INDEX,L,M,IOLD1,IOLD2,NTHETA
      DOUBLE PRECISION SINE,PMIN1,PMIN2,TOL,DPMIN1,
     1                 DPMIN2,X
      PARAMETER (TOL=1.0d-6)
C____________________________________________________________________C
C Variable declarations - Functions called ..........................C
      DOUBLE PRECISION PMM,PMM1,PLM,DPMM,DPMM1,DPLM
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C Check validity of arguments ....
C
C ........................... now loop around theta points
      DO NTHETA = 1, NTHPTS
C
        X = GAUX ( NTHETA )
        SINE = X*X
        IF ( SINE.GT.1.0d0 ) THEN
           PRINT *,' Subroutine SCHNLA.'
           PRINT *,' Illegal Cos(theta) has been entered.'
           PRINT *,' ( For NTHETA = ',NTHETA,' )'
           PRINT *,' Program stopped.'
           STOP
        ENDIF
C
C Set SINE (theta) in terms of X
        SINE = DSQRT ( (1.0d0 + X)*(1.0d0 - X) )
        IF ( SINE.LT.TOL ) THEN
           PRINT *,' Subroutine SCHNLA.'
           PRINT *,' SINE is too small. Division by zero imminent.'
           PRINT *,' ( For NTHETA = ',NTHETA,' )'
           PRINT *,' Program stopped.'
           STOP
        ENDIF
C..................... first calculate the P_l^m ..........
        DO M = 0, LH - 2
C                        ............. Calculate P_M^M .....
           L = M
           INDEX = L*(L+1)/2+M+1
           PA ( INDEX , NTHETA) = PMM ( M , SINE )
           DPA ( INDEX , NTHETA) = DPMM ( M , X, SINE )
C                         ............. Calculate P_(M+1)^M .
           PMIN1 = PA ( INDEX , NTHETA)
           DPMIN1 = DPA ( INDEX , NTHETA)
           IOLD2 = INDEX
           L = L + 1
           INDEX = L*(L+1)/2+M+1
           PA (INDEX , NTHETA) = PMM1 ( M , X , PMIN1 )
           DPA (INDEX , NTHETA) = DPMM1 (M,X,SINE,PMIN1, DPMIN1)
           IOLD1 = INDEX
C                         ......... Calculate P_L^M general .
           DO L = M + 2, LH
              PMIN2 = PA ( IOLD2 , NTHETA)
              PMIN1 = PA ( IOLD1 , NTHETA)
              DPMIN2 = DPA ( IOLD2 , NTHETA)
              DPMIN1 = DPA ( IOLD1 , NTHETA)
              INDEX = L*(L+1)/2+M+1
              PA ( INDEX , NTHETA) = PLM ( L,M,X,PMIN1,PMIN2 )
              DPA ( INDEX , NTHETA) = DPLM (L,M,X,SINE , PMIN1, 
     1                              DPMIN1, DPMIN2 )
              IOLD2 = IOLD1
              IOLD1 = INDEX
           ENDDO
        ENDDO
        M = LH - 1
        L = M
        INDEX = L*(L+1)/2+M+1
        PA( INDEX , NTHETA) = PMM ( M , SINE )
        DPA ( INDEX , NTHETA) = DPMM ( M , X, SINE )
        PMIN1 = PA( INDEX , NTHETA)
        DPMIN1 = DPA( INDEX , NTHETA)
        L = LH
        INDEX = L*(L+1)/2+M+1
        PA( INDEX , NTHETA) = PMM1 ( M , X , PMIN1 )
        DPA(INDEX ,NTHETA) = DPMM1 (M ,X ,SINE,PMIN1,DPMIN1 )
        M = LH
        INDEX = L*(L+1)/2+M+1
        PA( INDEX , NTHETA) = PMM ( M , SINE )
        DPA ( INDEX , NTHETA) = DPMM ( M , X, SINE )
C......................finished calculating P_l^m .........
      ENDDO
C......................finished looping around theta points

      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Velocity and Temperature HarMonic Selection Routine *****
C            -            -           -        -         -       *****
C Steve Gibbons Mon Nov 15 10:34:14 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Fills MHT, MHL and MHM for a velocity and temperature only vector  C
C with lowest order, mlow, incremented by minc and capped by mmax -  C
C with L being filled up to LH.                                      C
C                                                                    C
C It avoids the call to MHINDA, although is no more powerful         C
C than that routine.                                                 C
C                                                                    C
C  e.g. case mlow = 1, minc = 2, mmax = 6 gives                      C
C                                                                    C
C  m = 1, 3 and 5.                                                   C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     ISYM      : ISYM.eq.1 --> only equatorially symmetric harm.s   C
C                 ISYM.eq.2 --> only equatorially symmetric harm.s   C
C                 ISYM.eq.3 --> all equatorially symmetries          C
C                                                                    C
C     NH        : Output only integer giving the total number of     C
C                  harmonics selected.                               C
C                                                                    C
C     MLOW      : Lowest wavenumber, m.                              C
C     MINC      : Increment in wavenumber, m.                        C
C     MMAX      : Highest wavenumber, m.                             C
C                                                                    C
C     NHMAX     : Maximum number of harmonics permitted. If the      C
C                  specified parameters demand more harmonics than   C
C                   permitted by this bound then HMINDA calculates   C
C                    how many harmonics are necessary and then       C
C                     aborts with an appropriate message.            C
C                                                                    C
C     MHT       : MHT( ih ) contains itype for harmonic 'ih'         C
C                                                                    C
C     MHL       : MHL( ih ) contains degree, l, for harmonic 'ih'    C
C                                                                    C
C     MHM       : MHM( ih ) contains order, m, for harmonic 'ih' if  C
C                  ih has cos m phi dependency and (-m) if ih has    C
C                   sin m phi dependency.                            C
C                                                                    C
C     LH        : Maximum requested degree, l, of a spherical harm.  C
C                                                                    C
C     LHMAX     : Global maximum permitted degree, l, of a spherical C
C                  harmonic.                                         C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VTHMSR( ISYM, NH, MLOW, MINC, MMAX, NHMAX, MHT, MHL,
     1                   MHM, LH, LHMAX )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER ISYM, NH, MLOW, MINC, MMAX, NHMAX, MHT( * ), MHL( * ),
     1        MHM( * ), LH, LHMAX
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER L, M, LMIN, ICS, ITYPE, IS, M2
      LOGICAL OK, OES, OEA
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
c
      IF ( LH.GT.LHMAX ) THEN
        PRINT *,' Subroutine VTHMSR.'
        PRINT *,' LH    = ', LH
        PRINT *,' LHMAX = ', LHMAX
        PRINT *,' Program aborted.'
        STOP
      ENDIF
c
      IF ( ISYM.NE.1 .AND. ISYM.NE.2 .AND. ISYM.NE.3 ) THEN
        PRINT *,' Subroutine VTHMSR.'
        PRINT *,' ISYM = ', ISYM
        PRINT *,' Program aborted.'
        STOP
      ENDIF
c
      IF ( MINC.EQ.0 ) THEN
        PRINT *,' Subroutine VTHMSR.'
        PRINT *,' MINC = ', MINC
        PRINT *,' Program aborted.'
        STOP
      ENDIF
c
      NH = 0
      OK = .TRUE.
c
      OES = .FALSE.
      OEA = .FALSE.
      IF ( ISYM.EQ.1 .OR. ISYM.EQ.3 ) OES = .TRUE.
      IF ( ISYM.EQ.2 .OR. ISYM.EQ.3 ) OEA = .TRUE.
c
      DO M = MLOW, MMAX
        IF ( (M-MLOW)/MINC*MINC.NE.(M-MLOW) ) GOTO 50
        DO ITYPE = 1, 3
          IF ( ITYPE.EQ.1 ) M2 = 0
          IF ( ITYPE.EQ.2 ) M2 = 1
          IF ( ITYPE.EQ.3 ) M2 = 0
          DO IS = 1, 2
            IF ( .NOT. OES  .AND. IS.EQ.1 ) GOTO 49
            IF ( .NOT. OEA  .AND. IS.EQ.2 ) GOTO 49
            LMIN = M
            IF ( M.EQ.0 .AND. ( ITYPE.NE.3 .OR. IS.NE.1 ) ) LMIN = 1
            DO L = LMIN, LH
              IF ( IS.EQ.1 .AND. MOD( (L-M), 2 ).NE.M2 ) GOTO 48
              IF ( IS.EQ.2 .AND. MOD( (L-M), 2 ).EQ.M2 ) GOTO 48
              DO ICS = 1, 2
                IF ( M.EQ.0 .AND. ICS.EQ.2 ) GOTO 48
c               . ok this harmonic DOES go in
c               . (provided we have enough room)
c               .
                NH = NH + 1
                IF ( NH.GT.NHMAX ) OK = .FALSE.
                IF ( OK ) MHT( NH ) = ITYPE
                IF ( OK ) MHL( NH ) = L
                IF ( OK .AND. ICS.EQ.1 ) MHM( NH ) = M
                IF ( OK .AND. ICS.EQ.2 ) MHM( NH ) = -M
c               .
              ENDDO
 48         CONTINUE
            ENDDO
 49       CONTINUE
          ENDDO
        ENDDO
 50   CONTINUE
      ENDDO
c
      IF ( OK ) RETURN
      PRINT *,' Subroutine VTHMSR. Your specifications'
      PRINT *,' require ',NH,' harmonics. Maximum was set'
      PRINT *,' at ',NHMAX,'. Program aborted.'
c
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine Curl INDex SWitch ***************************************
C            -    ---   --     ***************************************
C Steve Gibbons Sat Sep 25 15:41:55 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C This routine is for programming conveience rather than scientific  C
C necessity. The integer array MHT has length NH and for each        C
C harmonic, ih, in the solution vector, MHT( ih ) corresponds to     C
C itype - which has the following options.                           C
C                                                                    C
C         ITYPE = 1 for a poloidal velocity harmonic.                C
C         ITYPE = 2 for a toroidal velocity harmonic.                C
C         ITYPE = 3 for a temperature harmonic.                      C
C         ITYPE = 4 for a poloidal magnetic field harmonic.          C
C         ITYPE = 5 for a toroidal magnetic field harmonic.          C
C                                                                    C
C Now when solving the vorticity equation, the curl is taken of      C
C the momentum equation and so equations for toroidal harmonics and  C
C those for poloidal harmonics are interchanged.                     C
C                                                                    C
C CINDSW simply makes a copy of MHT but with the 1s and the 2s       C
C interchanged. This can then be supplied to other routines as the   C
C MHT array for the destination (row) function.                      C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NH        : Number of spherical harmonics.                     C
C     MHTI      : MHTI( ih ) itype for harmonic 'ih'                 C
C     MHTO      : MHTO( ih ) itype for curl of harmonic 'ih'         C
C                  (only effects velocity harmonics.)                C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE CINDSW ( NH, MHTI, MHTO )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NH, MHTI( NH ), MHTO( NH )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IH
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
c
      DO IH = 1, NH
        IF ( MHTI( IH ).EQ.1 ) MHTO( IH ) = 2
        IF ( MHTI( IH ).EQ.2 ) MHTO( IH ) = 1
        IF ( MHTI( IH ).EQ.3 ) MHTO( IH ) = 3
        IF ( MHTI( IH ).EQ.4 ) MHTO( IH ) = 4
        IF ( MHTI( IH ).EQ.5 ) MHTO( IH ) = 5
      ENDDO
c
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Solution Vector Finite Difference Coefficients Form *****
C            -        -      -      -          -            -    *****
C Steve Gibbons Fri Oct 22 09:33:36 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C  If XARR is an array of length ( NR ) such that the j^{th}         C
C  element is the value of x_j, then SVFDCF builds an array          C
C  SVFDC of dimension ( NFDCM, NR, NDRVM+1, NDCS ) such that for a   C
C  node number, j, the ND^{th} derivative of radial function         C
C  given f_{IH} ( x ) will be given by                               C
C                                                                    C
C  f_{IH}^{ND}( x_j ) =                                              C
C         \sum_{i=LN}^{RN} SVFDC ( IRAD, j, ND+1, K ) f_{IH} ( x_i ) C
C                                                                    C
C  where LN (the left node)  = MAX( NLMR, j - NBN ) and              C
C        RN (the right node) = MIN( NRMC, j + NBN ),                 C
C                                                                    C
C  IRAD = i - j + NBN + 1 and K = MHP( ih ).                         C
C                                                                    C
C  NDCS is the number of distinct sets of coefficients required for  C
C  different types of harmonics (in generally will be considerably   C
C  smaller than the number of harmonics, NH).                        C
C                                                                    C
C  The arrays MHIBC and MHOBC instruct SVFDCF how to manipulate      C
C  the finite difference coefficients at the boundaries.             C
C                                                                    C
C  MHIBC( ih ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHIBC( ih ) = 2 --> Function must vanish at the bndry.            C
C  MHIBC( ih ) = 3 --> First derivative must vanish at the bndry.    C
C  MHIBC( ih ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHIBC( ih ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHIBC( ih ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHIBC( ih ) = 7 --> r df/dr - l f(r) = 0 at the bndry.            C
C                        where L = LARR( ih )                        C
C                                                                    C
C  Similarly, at the outer boundary:-                                C
C                                                                    C
C  MHOBC( ih ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHOBC( ih ) = 2 --> Function must vanish at the bndry.            C
C  MHOBC( ih ) = 3 --> First derivative must vanish at the bndry.    C
C  MHOBC( ih ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHOBC( ih ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHOBC( ih ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHOBC( ih ) = 7 --> r df/dr + (l+1) f(r) = 0 at the bndry.        C
C                        where L = LARR( ih )                        C
C                                                                    C
C  The elements of this array are filled in from j = NLMR            C
C  to j = NRMR ( number of the left most node and number of the      C
C  right most node ) - other rows are left unreferred to.            C
C  This is incase a higher order derivative is required for          C
C  central nodes than boundary nodes; in which case SVFDCF must      C
C  be called for the remaining nodes with modified parameters.       C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of grid nodes.                              C
C     NDCS       : Number of distinct differencing coeff.s           C
C                  represented in SVFDC.                             C
C                                                                    C
C     NBN       : Maximum number of nodes on either side for         C
C                  central differencing.                             C
C                                                                    C
C     NLMR      : This is the lowest j for which the terms are       C
C                  calculated for SVFDC( i, j, ND+1, K )             C
C     NRMR      : This is the highest j for which the terms are      C
C                  calculated for SVFDC( i, j, ND+1, K )             C
C                                                                    C
C     MHIBC     : Dimension ( NDCS ). See above.                     C
C     MHOBC     : Dimension ( NDCS ). See above.                     C
C     LARR      : Spherical harmonic degree, L. Dim. ( NDCS ).       C
C                 This value is only useful for harmonics            C
C                 when calculating derivatives for magnetic fields.  C
C                 If LARR( ih ) = -1, the harmonic is ignored        C
C                 completely.                                        C
C                                                                    C
C     NCFM      : Leading order of working coefficient matrix.       C
C                 Must be atleast (2*NBN + 1) where NBN is the       C
C                 maximum number of nodes on either side of the      C
C                 central node.                                      C
C     NFDCM     : Leading order of the array SVFDC.                  C
C                 This must be atleast (2*NBN + 1)                   C
C     NDRVS     : Number of derivatives required.                    C
C                  This will be limited by the available bandwidth.  C
C                                                                    C
C                  Let NLCS = NLMR - 1    and let                    C
C                      NRCS = NR - NRMR                              C
C                                                                    C
C                  Now, let I = MIN( NLCS, NRCS) + NBN               C
C                                                                    C
C                  then NDRVS must be no greater than I.             C
C                  This is checked for.                              C
C     NDRVM     : Maximum number of derivatives allowed.             C
C                                                                    C
C     IWORK     : Integer work array. Dimension ( NCFM )             C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Array of dimension (  NR  ).                       C
C                  XARR( i ) contains the value of x or r at the     C
C                   i^{th} radial grid node.                         C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                                                                    C
C     COEFM1    : Coefficient work array. Dimension ( NCFM, NCFM )   C
C     COEFM2    : Coefficient work array. Dimension ( NCFM, NCFM )   C
C     WORK1     : Coefficient work array. Dimension ( NCFM )         C
C     WORK2     : Coefficient work array. Dimension ( NCFM )         C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SVFDCF( NR, NDCS, NBN, NLMR, NRMR, MHIBC, MHOBC,
     1                   LARR, NCFM, NFDCM, NDRVS, NDRVM, XARR,
     2                   IWORK, SVFDC, COEFM1, COEFM2, WORK1, WORK2 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, NDCS, NBN, NLMR, NRMR, MHIBC( NDCS ), MHOBC( NDCS ),
     1        LARR( NDCS ), NCFM, NFDCM, NDRVS, NDRVM, 
     1        IWORK( NCFM )
      DOUBLE PRECISION XARR( NR ), SVFDC( NFDCM, NR, NDRVM+1, NDCS ),
     1                 COEFM1( NCFM, NCFM ), COEFM2( NCFM, NCFM ),
     2                 WORK1( NCFM ), WORK2( NCFM )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NDER, IRAD, NLCS, NRCS, NLN, NRN, IDCS, L,
     1        NNDS, INDS, I, INODE, NSNIB, NSNOB, NALF, NARF,
     2        IIBC, IOBC, ND1
C
C nsnib is the number of special nodes on the inner boundary
C nsnob is the number of special nodes on the outer boundary
C
      DOUBLE PRECISION DZERO, X0, EMMULT, FAC
      PARAMETER ( DZERO = 0.0d0 )
C
      LOGICAL OCHNGE
C
C ochnge is .TRUE. when the boundary conditions
C play a part in the finite difference coefficients
C and .FALSE. otherwise
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C     .
C     . Check the values of integers ...
C     .
      IF ( NDRVS.GT.NDRVM ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NDRVS  = ',NDRVS
         PRINT *,' NDRVM  = ',NDRVM
         STOP
      ENDIF
C     .
      NLCS = NLMR - 1
      NRCS = NR - NRMR
C     . 
C     . Check that sufficient points are allowed
C     . for the derivatives ...
C     . 
      IF ( (NR-1).LT.(NBN+1) ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NBN  = ', NBN
         PRINT *,' NLMR = ', NLMR
         PRINT *,' NRMR = ', NRMR
         PRINT *,' Insufficient nodes for differencing.'
         STOP
      ENDIF
C     . 
      IF ( NLCS.LT.0 ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NLMR = ', NLMR
         STOP
      ENDIF
C     . 
      IF ( NRCS.LT.0 ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NRMR = ', NRMR
         STOP
      ENDIF
C     .
      I = MIN( NLCS, NRCS) + NBN
C     .
      IF ( NDRVS.GT.I ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' You have requested deriv.s to order ',NDRVS
         PRINT *,' At one node, you have only', I
         PRINT *,' side nodes to use for differencing.'
         STOP
      ENDIF
C     .
      I = 2*NBN + 1
C     .
      IF ( NCFM.LT.I ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NCFM = ', NCFM
         PRINT *,' NBN  = ', NBN
         STOP
      ENDIF
C     .
      IF ( NFDCM.LT.I ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NFDCM = ', NFDCM
         PRINT *,' NBN  = ', NBN 
         STOP
      ENDIF
C     .
      IF ( NLMR.GT.NRMR ) THEN
         PRINT *,' Subroutine SVFDCF.'
         PRINT *,' NLMR = ', NLMR
         PRINT *,' NRMR = ', NRMR
         STOP
      ENDIF
C     .
C     . Whew ... all input parameters seem to be o.k.
C     . Loop around the requested nodes
C     .
      DO IRAD = NLMR, NRMR
C      .
C      . Loop around the different 'harmonic forms'
C      .
       DO IDCS = 1, NDCS
C
C Check for flag to ignore this harmonic
C
        IF ( LARR( IDCS ).EQ.-1 ) GOTO 50
C
C We now need to check which boundary condition is
C required. Make sure that it is valid.
C
        IF ( MHIBC( IDCS ).LT.1 .AND. MHIBC( IDCS ).GT.7 ) THEN
          PRINT *,' Subroutine SVFDCF.'
          PRINT *,' MHIBC(',IDCS,') = ', MHIBC( IDCS )
          STOP
        ENDIF
C
C O.k. inner b.c. is fine. Now need to 
C see how many points this effects.
C
        IF ( MHIBC( IDCS ).EQ.1 ) THEN
          NSNIB = 0
        ENDIF
C
        IF ( MHIBC( IDCS ).EQ.2 .OR. MHIBC( IDCS ).EQ.3 .OR.
     1       MHIBC( IDCS ).EQ.6 .OR. MHIBC( IDCS ).EQ.7     ) THEN
          NSNIB = 1
        ENDIF
C
        IF ( MHIBC( IDCS ).EQ.4 .OR. MHIBC( IDCS ).EQ.5 ) THEN
          NSNIB = 2
        ENDIF
C
        IF ( MHOBC( IDCS ).LT.1 .AND. MHOBC( IDCS ).GT.7 ) THEN
          PRINT *,' Subroutine SVFDCF.'
          PRINT *,' MHOBC(',IDCS,') = ', MHOBC( IDCS )
          STOP
        ENDIF
C
C O.k. outer b.c. is fine. Now need to
C see how many points this effects.
C
        IF ( MHOBC( IDCS ).EQ.1 ) THEN
          NSNOB = 0
        ENDIF
C
        IF ( MHOBC( IDCS ).EQ.2 .OR. MHOBC( IDCS ).EQ.3 .OR.
     1       MHOBC( IDCS ).EQ.6 .OR. MHOBC( IDCS ).EQ.7     ) THEN
          NSNOB = 1 
        ENDIF
C
        IF ( MHOBC( IDCS ).EQ.4 .OR. MHOBC( IDCS ).EQ.5 ) THEN
          NSNOB = 2 
        ENDIF
C
        DO NDER = 0, NDRVS
          ND1 = NDER + 1
          DO I = 1, NFDCM
            SVFDC( I, IRAD, ND1, IDCS ) = DZERO
          ENDDO
        ENDDO
C
C irad is the node for which we want to calculate
C our coefficients
C
        NLCS = IRAD - 1
        NRCS = NR - IRAD
C
C we wish to calculate NLN (number of left nodes)
C and NRN ( number of right nodes )
C NNDS ( total number of nodes) is then NLN + NRN + 1 ...
C
        NLN = MIN( NBN, NLCS )
        NRN = MIN( NBN, NRCS )
C
        NNDS = NLN + NRN + 1
C
C We must work out how many nodes are affected
C to the left and the right. NALF and NARF
C are respectively the number of affected nodes
C to the left and right.
C
        IF ( (IRAD-NLN).GT.NSNIB ) NALF = 0
        IF ( (IRAD-NLN).EQ.NSNIB ) NALF = 1
        IF ( (IRAD-NLN).LT.NSNIB ) NALF = 2
C
        IF ( (IRAD+NRN).LT.(NR+1-NSNOB) ) NARF = 0
        IF ( (IRAD+NRN).EQ.(NR+1-NSNOB) ) NARF = 1
        IF ( (IRAD+NRN).GT.(NR+1-NSNOB) ) NARF = 2
C
        IF ( NALF.EQ.0 .AND. NARF.EQ.0 ) THEN
          OCHNGE = .FALSE.
        ELSE
          OCHNGE = .TRUE.
        ENDIF
        IF ( .NOT. OCHNGE ) GOTO 51
C       .
C       . OK - we need to form a matrix COEFM2 such that
C       . the correct coeffcients are given when
C       . COEFM1 is multiplied by COEFM2
C       .
        L    = LARR( IDCS )
        IIBC = MHIBC( IDCS )
        IOBC = MHOBC( IDCS )
C       .
        CALL LDGNMF( NR, NNDS, NALF, NARF, L, IIBC, IOBC, NCFM,
     1             XARR, COEFM2, COEFM1, WORK1, WORK2, IWORK )
C       .
 51     CONTINUE
        X0 = XARR( IRAD )
        DO INDS = 1, NNDS
          INODE = IRAD - NLN - 1 + INDS
          WORK1( INDS ) = XARR( INODE )
        ENDDO
C
C Now ready to calculate the coefficients
C
        CALL GFDCFD( X0, WORK1, NNDS, COEFM1, NCFM, 
     1               IWORK, WORK2 )
C
C coefm matrix should now contain the coeff.s
C
        IF ( OCHNGE ) THEN
C        .
C        . Our coefficients are modified
C        . by the boundary conditions
C        .
         DO NDER = 0, NDRVS
          ND1 = NDER + 1
          DO INDS = 1, NNDS
            INODE = INDS - NLN + NBN
            FAC = EMMULT( ND1, INDS, NCFM, NCFM, NNDS,
     1                      COEFM1, COEFM2 )
            SVFDC( INODE, IRAD, ND1, IDCS ) = FAC
          ENDDO
         ENDDO
        ELSE
C        .
C        . Our coefficients are not modified
C        . by the boundary conditions
C        .
         DO NDER = 0, NDRVS
          ND1 = NDER + 1
          DO INDS = 1, NNDS
            INODE = INDS - NLN + NBN
            SVFDC( INODE, IRAD, ND1, IDCS ) = 
     1                      COEFM1( ND1, INDS )
          ENDDO
         ENDDO
C        .
        ENDIF
C
 50    CONTINUE
       ENDDO
C      .
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Finite Difference Coefficient Matrix BuilD **************
C            -      -          -           -      -   - **************
C Steve Gibbons Tue Sep 21 09:25:54 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C  If XARR is an array of length ( NR ) such that the j^{th}         C
C  element is the value of x_j, then FDCMBD builds an array          C
C  FDCM of dimension ( NFDCM, NR, NDRVS ) such that for a given      C
C  node number, j, the ND^{th} derivative of a function f( x )       C
C  will be given by                                                  C
C                                                                    C
C  f^{ND}( x_j ) = \sum_{i=LN}^{RN} FDCM( IRAD, j, ND ) f( x_i )     C
C                                                                    C
C  where LN (the left node)  = MAX( NLMC, j - NBN ) and              C
C        RN (the right node) = MIN( NRMC, j + NBN )                  C
C                                                                    C
C  and IRAD = i - j + NBN + 1                                        C
C                                                                    C
C  NLMC and NRMC are respectively the left most and right most       C
C  nodes (columns) which may be used to obtain a difference formula. C
C  In most matrix applications NLMC = 1 and NRMC = NR, although      C
C  when differentiating a vector it may be necessary to omit an      C
C  extreme point; for instance when this would result in a division  C
C  by zero.                                                          C
C                                                                    C
C  The elements of this array are filled in from j = NLMN            C
C  to j = NRMN ( number of the left most node and number of the      C
C  right most node ) - other rows are left unreferred to.            C
C  This is incase a higher order derivative is required for          C
C  central nodes than boundary nodes; in which case FDCMBD must      C
C  be called for the remaining nodes with modified parameters.       C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Array of dimension (  NR  ).                       C
C                  XARR( i ) contains the value of x or r at the     C
C                   i^{th} radial grid node.                         C
C                                                                    C
C     FDCM      : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM ).                   C
C                                                                    C
C     COEFM     : Coefficient work array. Dimension ( NCFM, NCFM )   C
C     WORK1     : Coefficient work array. Dimension ( NCFM )         C
C     WORK2     : Coefficient work array. Dimension ( NCFM )         C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of grid nodes.                              C
C     NBN       : Maximum number of nodes on either side for         C
C                  central differencing.                             C
C     NLMN      : This is the lowest j for which the terms are       C
C                  calculated for FDCM( i, j, ND )                   C
C     NRMN      : This is the highest j for which the terms are      C
C                  calculated for FDCM( i, j, ND )                   C
C     NLMC      : This is the lowest i for which the terms are       C
C                  calculated for FDCM( i, j, ND )                   C
C     NRMC      : This is the highest i for which the terms are      C
C                  calculated for FDCM( i, j, ND )                   C
C                                                                    C
C     NCFM      : Leading order of working coefficient matrix.       C
C                 Must be atleast (2*NBN + 1) where NBN is the       C
C                 maximum number of nodes on either side of the      C
C                 central node.                                      C
C     NFDCM     : Leading order of the array FDCM.                   C
C                 This must be atleast (2*NBN + 1)                   C
C     NDRVS     : Number of derivatives required.                    C
C                  This will be limited by the available bandwidth.  C
C                                                                    C
C                  Let NLCS = NLMN - NLMC and let                    C
C                      NRCS = NRMC - NRMN                            C
C                                                                    C
C                  Now, let I = MIN( NLCS, NRCS) + NBN               C
C                                                                    C
C                  then NDRVS must be no greater than I.             C
C                  This is checked for.                              C
C     NDRVM     : Maximum number of derivatives required.            C
C                                                                    C
C     IWORK     : Integer work array. Dimension ( NCFM )             C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE FDCMBD( NR, NBN, NLMN, NRMN, NLMC, NRMC, NCFM,
     1                   NFDCM, NDRVS, NDRVM, IWORK, XARR, FDCM,
     2                   COEFM, WORK1, WORK2 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, NBN, NLMN, NRMN, NCFM, NFDCM, NDRVS, NDRVM, 
     1        IWORK( NCFM ), NLMC, NRMC
      DOUBLE PRECISION XARR( NR ), FDCM( NFDCM, NR, NDRVM ),
     1                 COEFM( NCFM, NCFM ), WORK1( NCFM ),
     2                 WORK2( NCFM )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NDER, IRAD, NLCS, NRCS, NLN, NRN,
     1        NNDS, INDS, I, INODE
      DOUBLE PRECISION DZERO, X0
      PARAMETER ( DZERO = 0.0d0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C     .
C     . Check the values of integers ...
C     .
      IF ( NDRVS.GT.NDRVM ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NDRVS  = ',NDRVS
         PRINT *,' NDRVM  = ',NDRVM
         STOP
      ENDIF
C     .
      NLCS = NLMN - NLMC
      NRCS = NRMC - NRMN
C     . 
C     . Check that sufficient points are allowed
C     . for the derivatives ...
C     . 
      IF ( (NRMC-NLMC).LT.(NBN+1) ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NBN  = ', NBN
         PRINT *,' NLMC = ', NLMC
         PRINT *,' NRMC = ', NRMC
         PRINT *,' Insufficient nodes for differencing.'
         STOP
      ENDIF
C     . 
      IF ( NLCS.LT.0 ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NLMN = ', NLMN
         PRINT *,' NLMC = ', NLMC
         STOP
      ENDIF
C     . 
      IF ( NRCS.LT.0 ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NRMN = ', NRMN
         PRINT *,' NRMC = ', NRMC
         STOP
      ENDIF
C     .
      I = MIN( NLCS, NRCS) + NBN
C     .
      IF ( NDRVS.GT.I ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' You have requested deriv.s to order ',NDRVS
         PRINT *,' At one node, you have only', I
         PRINT *,' side nodes to use for differencing.'
         STOP
      ENDIF
C     .
      I = 2*NBN + 1
C     .
      IF ( NCFM.LT.I ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NCFM = ', NCFM
         PRINT *,' NBN  = ', NBN
         STOP
      ENDIF
C     .
      IF ( NFDCM.LT.I ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NFDCM = ', NFDCM
         PRINT *,' NBN  = ', NBN 
         STOP
      ENDIF
C     .
      IF ( NLMN.GT.NRMN ) THEN
         PRINT *,' Subroutine FDCMBD.'
         PRINT *,' NLMN = ', NLMN
         PRINT *,' NRMN = ', NRMN
         STOP
      ENDIF
C     .
C     . Whew ... all input parameters seem to be o.k.
C     . Now loop around the requested rows
C     .
      DO IRAD = NLMN, NRMN
C
        DO NDER = 1, NDRVS
          DO I = 1, NFDCM
            FDCM( I, IRAD, NDER ) = DZERO
          ENDDO
        ENDDO
C
C irad is the node for which we want to calculate
C our coefficients
C
        NLCS = IRAD - NLMC
        NRCS = NRMC - IRAD
C
C we wish to calculate NLN (number of left nodes)
C and NRN ( number of right nodes )
C NNDS ( total number of nodes) is then NLN + NRN + 1 ...
C
        NLN = MIN( NBN, NLCS )
        NRN = MIN( NBN, NRCS )
C
        NNDS = NLN + NRN + 1
C
        X0 = XARR( IRAD )
        DO INDS = 1, NNDS
          INODE = IRAD - NLN - 1 + INDS
          WORK1( INDS ) = XARR( INODE )
        ENDDO
C
C Now ready to calculate the coefficients
C
        CALL GFDCFD( X0, WORK1, NNDS, COEFM, NCFM, 
     1               IWORK, WORK2 )
C
C coefm matrix should now contain the coeff.s
C
        DO NDER = 1, NDRVS
          DO INDS = 1, NNDS
            INODE = INDS - NLN + NBN
            FDCM( INODE, IRAD, NDER ) = COEFM( NDER+1, INDS )
          ENDDO
        ENDDO
C
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Spherical Harmonic Coef. Array Normalised Copy **********
C            -         -        -     -     -          -    **********
C Steve Gibbons Thu Mar 16 17:51:14 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Let the function g( \theta, \phi ) be expressed as the sum of      C
C Schmidt normalised spherical harmonics:                            C
C                                                                    C
C  g = \sum_{l,m} [  c_{l,mc} P_l^m( cos theta ) cos (m phi)         C
C               + c_{l,ms} P_l^m( cos theta ) sin (m phi)            C
C                                                                    C
C with the coefficients (ordered by the function INDSHC) given in    C
C the array SHC.                                                     C
C                                                                    C
C If all coefficients are zero, then SHCANC returns SHCN as a zero   C
C array. Otherwise, SHCN returns the coefficients scaled such that   C
C the spherical surface integral of g^2 is equal to VALN.            C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     LH        : Maximum spherical harmonic degree, l.              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     SHC       : Dim ( LH*(LH+2) ). Input array coefficients.       C
C     SHCN      : Dim ( LH*(LH+2) ). Output array coefficients.      C
C     VALN      : Value for normalisation.                           C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SHCANC( LH, SHC, SHCN, VALN )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH
      DOUBLE PRECISION SHC( * ), SHCN( * ), VALN
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER L, M, ICS, I, NH
      DOUBLE PRECISION DLOW, ZERO, PI, RNORM, COEF, FAC
      PARAMETER ( DLOW = 1.0d-8, ZERO = 0.0d0,
     1            PI = 3.14159265358979312D0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NH = LH*(LH+2)
C
      RNORM = ZERO
      DO I = 1, NH
        CALL LMFIND( I, L, M, ICS )
        COEF = SHC( I )
        FAC  = 2.0d0*DBLE(L) + 1.0d0
        RNORM = RNORM + COEF*COEF*4.0d0*PI/FAC
      ENDDO
C
      IF ( RNORM.LT.DLOW ) THEN
        FAC = 0.0d0
      ELSE
        FAC = VALN/SQRT( RNORM )
      ENDIF
C
      DO I = 1, NH
        SHCN( I ) = SHC( I )*FAC
      ENDDO
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Inhomogeneous Temperature Harmonic Coefficient Allocate *
C            -             -           -        -           -        *
C Steve Gibbons Wed Jan 19 08:46:34 GMT 2000              Routine    C
C____________________________________________________________________C
C                                                                    C
C ITHCAR receives arrays defining sets of harmonics; these are       C
C                                                                    C
C  MHT( ih ) = 1 for a poloidal velocity harmonic                    C
C  MHT( ih ) = 2 for a toroidal velocity harmonic                    C
C  MHT( ih ) = 3 for a temperature harmonic                          C
C  MHT( ih ) = 4 for a poloidal magnetic field harmonic              C
C  MHT( ih ) = 5 for a toroidal magnetic field harmonic              C
C                                                                    C
C  MHL( ih ) = l, degree of spherical harmonic                       C
C  MHM( ih ) = m (order) for cos ( m phi ) dependence or             C
C              -m for sin ( m phi ) dependence.                      C
C                                                                    C
C  A fourth array MHI is assigned values by ITHCAR: If MHT( ih ) = 3 C
C then ITHCAR will look at the arrays HMIB and HMOB (harmonic map    C
C for inner/outer boundary) and the flags KIB and KOB and decide     C
C what value of temperature/temp. gradient that harmonic radial      C
C function should achieve at that boundary.                          C
C                                                                    C
C MHIB and MHOB are indexed by INDSHC.                               C
C                                                                    C
C These values are supplied to the routine ITFCF as VALIB and VALOB  C
C and along with RI and RO will be used to provide the coefficients  C
C CA, CB and CC which define the inhomogeneous temperature function  C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C The coefficients CA, CB and CC are stored in the array             C
C CAFIT (coefficient array for inhomogeneous temperature) which has  C
C dimensions ( 3, NITHMX ) where NITHMX limits the possible number   C
C of temperature harmonics.                                          C
C                                                                    C
C NITH is the number of inhomogeneous temperature harmonics which    C
C have already been assigned coefficients by ITHCAR.                 C
C                                                                    C
C For example if IH is a harmonic radial function with MHT( IH ) = 3 C
C and ITFCF calculates that f(r) should take the coefficients        C
C CA, CB and CC; then                                                C
C                                                                    C
C  CA is stored in CAFIT( 1, IITH )                                  C
C  CB is stored in CAFIT( 2, IITH )                                  C
C  CC is stored in CAFIT( 3, IITH )                                  C
C                                                                    C
C and the index IITH is stored in MHI( IH )                          C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     KIB      : 1 if T( r ) is to be fixed at the inner boundary.   C
C                2 if dT/dr(r) is to be fixed at the inner boundary. C
C                                                                    C
C     KOB      : 1 if T( r ) is to be fixed at the outer boundary.   C
C                2 if dT/dr(r) is to be fixed at the outer boundary. C
C                                                                    C
C     NITH     : Number of inhomogeneous temperature harmonics       C
C                 with coeff.s stored in CAFIT.                      C
C                                                                    C
C     NITHMX   : Limit on NITH.                                      C
C                                                                    C
C     NH       : Number of harmonics                                 C
C     MHT      : Dim( * ). Harmonic type - see above.                C
C     MHL      : Dim( * ). Harmonic degree - see above.              C
C     MHM      : Dim( * ). Harmonic order  - see above.              C
C     MHI      : Dim( * ). 2nd index of CAFIT where coeffs are storedC
C                                                                    C
C     LH       : Maximum spherical harmonic degree.                  C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RI       : Radius of the inner boundary.                       C
C     RO       : Radius of the outer boundary.                       C
C                                                                    C
C     HMIB     : Harmonic map for inner boundary. Dim( LH*(LH+2) )   C
C     HMIBMT   : Harmonic map for inner boundary monopole term       C
C     HMOB     : Harmonic map for outer boundary. Dim( LH*(LH+2) )   C
C     HMOBMT   : Harmonic map for outer boundary monopole term       C
C                                                                    C
C                 MHIB and MHOB can refer to either temperature      C
C                 or temperature gradient depending upon the         C
C                 values of KIB and KOB.                             C
C                                                                    C
C                 The arrays are indexed by INDSHC.                  C
C                                                                    C
C     CAFIT    : Coeff arr. for inhomog. temp. Dim( 3, NITHMX ).     C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ITHCAR( KIB, KOB, NITH, NITHMX, NH, MHT, MHL, MHM,
     1                   MHI, LH, RI, RO, HMIB, HMIBMT, HMOB, HMOBMT,
     2                   CAFIT )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER KIB, KOB, NITH, NITHMX, NH, MHT( * ), MHL( * ),
     1        MHM( * ), MHI( * ), LH
      DOUBLE PRECISION RI, RO, HMIB( LH*(LH+2) ), HMIBMT,
     1                  HMOB( LH*(LH+2) ), HMOBMT, CAFIT( 3, NITHMX )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHARM, L, M, ICS, IH, INDSHC, NIT
      DOUBLE PRECISION VALIB, VALOB, CA, CB, CC, DLOW
      LOGICAL OK
      PARAMETER ( DLOW = 1.0d-7 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      IF ( NITH.LT.0 ) THEN
        PRINT *,' Subroutine ITHCAR.'
        PRINT *,' NITH = ', NITH,' on entry.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      OK = .TRUE.
C     .
      DO IH = 1, NH
        IF ( MHT( IH ).NE.3 ) THEN
          MHI( IH ) = -1
          GOTO 50
        ENDIF
C       .
        L = MHL( IH )
        IF ( MHM( IH ).LT.0 ) THEN
          M   = -MHM( IH )
          ICS = 2
        ELSE
          M   = MHM( IH )
          ICS = 1
        ENDIF
        IHARM = INDSHC( L, M, ICS )
C       .
        IF ( L.GT.LH ) THEN
          PRINT *,' Subroutine ITHCAR.'
          PRINT *,' Harmonic ',IH,' has L = ', L
          PRINT *,' Maximum degree = ', LH
          PRINT *,' Program aborted.'
          STOP
        ENDIF
C       .
        IF ( IHARM.EQ.0 ) THEN
          VALIB = HMIBMT
          VALOB = HMOBMT
        ELSE
          VALIB = HMIB( IHARM )
          VALOB = HMOB( IHARM )
        ENDIF
C       .
        CALL ITFCF( KIB, KOB, RI, RO, VALIB, VALOB, CA, CB, CC )
C       .
C       . OK - we have calculated values
C       . for CA, CB and CC, so let's loop around
C       . CAFIT to see if we have already stored
C       . such values.
C       .
        DO NIT = 1, NITH
          IF ( DABS( CA - CAFIT( 1, NIT ) ).LT.DLOW .AND.
     1         DABS( CB - CAFIT( 2, NIT ) ).LT.DLOW .AND.
     2         DABS( CC - CAFIT( 3, NIT ) ).LT.DLOW   ) THEN
            MHI( IH ) = NIT
            GOTO 50
          ENDIF
        ENDDO
C       .
        CALL CNTRIC( NITH, NITHMX, OK )
C       .
        IF ( OK ) THEN
          CAFIT( 1, NITH ) = CA
          CAFIT( 2, NITH ) = CB
          CAFIT( 3, NITH ) = CC
          MHI( IH ) = NITH
        ENDIF
C       .
 50     CONTINUE
      ENDDO
C     .
      IF ( OK ) RETURN
      PRINT *,' Subroutine ITHCAR.'
      PRINT *,' Number of requested coefficients = ', NITH
      PRINT *,' NITHMX = ', NITHMX
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine Boundary Locked Convection Newton Raphson Solve *********
C            -        -      -          -      -       -     *********
C Steve Gibbons Thu Mar 16 11:29:44 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C We wish to solve for a non-linear convection solution which is     C
C steady as a result of inhomogeneous thermal boundary conditions.   C
C                                                                    C
C Our equations are                                                  C
C                                                                    C
C                     CD \nabla^2 T                                  C
C                     - CC v . \nabla ( T )                 = 0      C
C                     + v . ( CB1 r + CB2 r^{-2} , 0 , 0 )           C
C                                                                    C
C                     CI \nabla^2 \curl v                            C
C                     - CG \curl ( k \times v )             = 0      C
C                     + CH \curl (    T   {\bm r } )                 C
C                     + CF \curl ( v \times \curl v )                C
C                                                                    C
C and we use a Newton Raphson-type iteration to find the finite      C
C amplitude solution.                                                C
C                                                                    C
C The temperature T is given by                                      C
C                                                                    C
C  T = \Theta + T_0, where T_0 is a temperature which satisfies      C
C the boundary conditions, and \Theta has homogeneous boundaries.    C
C                                                                    C
C For each harmonic, IH, MHI( IH ) contains an integer number,       C
C IITH. Then there are 3 numbers, ca, cb and cc with                 C
C                                                                    C
C  CA is stored in CAFIT( 1, IITH )                                  C
C  CB is stored in CAFIT( 2, IITH )                                  C
C  CC is stored in CAFIT( 3, IITH )                                  C
C                                                                    C
C and then the radial function associated with harmonic IH which     C
C gives the inhomogeneous temperature is                             C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     INARR     : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR      See INDFUN for details       C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C                                                                    C
C     MXATT     : Maximum number of iterations allowed.              C
C                                                                    C
C     IERR      : Error flag on return.                              C
C                 If IERR greater than zero, all is well and         C
C                 IERR contains the number of iterations required    C
C                 for the non-linear solution to converge.           C
C                                                                    C
C                 if IERR = -1, more than the maximum number of      C
C                 iterations were needed to converge.                C
C                                                                    C
C     N1        : First dimension of A matrix. Must equal 3*KL+1     C
C     N2        : Second dimension of A matrix. Length of vector.    C
C     KL        : Number of diagonal elements in A matrix.           C
C                                                                    C
C     MHT      : Array length ( * ) - atleast length NH              C
C                                                                    C
C         MHT( IH ) = 1 --> harmonic is poloidal velocity            C
C         MHT( IH ) = 2 --> harmonic is toroidal velocity            C
C         MHT( IH ) = 3 --> harmonic is temperature.                 C
C         MHT( IH ) = 4 --> harmonic is poloidal magnetic field      C
C         MHT( IH ) = 5 --> harmonic is toroidal magnetic field      C
C                                                                    C
C     MHL      : Array length ( * ) - atleast length NH              C
C                  Sph. harm. degree, l.                             C
C     MHM      : Array length ( * ) - atleast length NH              C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHP      : Array length ( * ) - atleast length NH              C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MHTR     : Array length ( * ) - atleast length NH              C
C                 Type of function in equation rows.                 C
C                 Under normal circumstances, MHTR is formed by      C
C                                                                    C
C                 CALL CINDSW( NH, MHT, MHTR )                       C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NCFM      : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C      (NDRVM must be atleast 4 and NDRVS must be 4 for atleast      C
C       grid nodes IR = 2, NR - 1 ).                                 C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C     NTHP      : The number of theta points.                        C
C     NPHP      : The number of phi points.                          C
C                                                                    C
C     MMAX      : Maximum sph. harmonic order, m.                    C
C                                                                    C
C     LH        : Maximum spherical harmonic degree, l.              C
C                                                                    C
C     MHIBC     : Inner boundary condition. Dim ( NDCS )             C
C                                                                    C
C  MHIBC( ih ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHIBC( ih ) = 2 --> Function must vanish at the bndry.            C
C  MHIBC( ih ) = 3 --> First derivative must vanish at the bndry.    C
C  MHIBC( ih ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHIBC( ih ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHIBC( ih ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHIBC( ih ) = 7 --> r df/dr - l f(r) = 0 at the bndry.            C
C                                                                    C
C     MHOBC     : Outer boundary condition. Dim ( NDCS )             C
C                                                                    C
C  MHOBC( ih ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHOBC( ih ) = 2 --> Function must vanish at the bndry.            C
C  MHOBC( ih ) = 3 --> First derivative must vanish at the bndry.    C
C  MHOBC( ih ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHOBC( ih ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHOBC( ih ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHOBC( ih ) = 7 --> r df/dr + (l+1) f(r) = 0 at the bndry.        C
C                                                                    C
C     IPIV      : Dim ( N2 ). Array for pivotting.                   C
C                                                                    C
C     LULOG     : Logical unit number of log file.                   C
C                 LULOG = 0 if no log file is to be written.         C
C                 Otherwise, vector norms and drift rate updates     C
C                 are written out to LULOG.                          C
C                                                                    C
C     MHI      : Dim(*). 2nd index of CAFIT where coeffs are stored  C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     VEC       : Initial solution vector. Dim (N2)                  C
C                                                                    C
C     PARAM     : Array dim ( 10 ) containing these param.s          C
C                                                                    C
C  On input:                                                         C
C                                                                    C
C            PARAM(  1 )  is not referenced (no time derivative)     C
C            PARAM(  2 ) = CB1                                       C
C            PARAM(  3 ) = CB2                                       C
C            PARAM(  4 ) = CC                                        C
C            PARAM(  5 ) = CD                                        C
C            PARAM(  6 )  is not referenced (no time derivative)     C
C            PARAM(  7 ) = CF                                        C
C            PARAM(  8 ) = CG                                        C
C            PARAM(  9 ) = CH                                        C
C            PARAM( 10 ) = CI                                        C
C            PARAM( 11 )  is not referenced (no drifting frame)      C
C            PARAM( 12 ) = CTOL (Convergence parameter for RHS norm) C
C                                                                    C
C     A         : Work array. Dim ( N1, N2 )                         C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NCFM, NR, NDRVM+1, NDCS ).            C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     GAUX      : Cosines of the NTHP evaluated by the routine       C
C                  gauwts. Dimension ( NTHP ).                       C
C     GAUW      : Corresponding weights. As above.                   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2, NTHP )       C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C     FDCM      : Finite difference coefficient matrix.              C
C                  Dimension ( NCFM, NR, 1 ).                        C
C                   Array is generated by the routine fdcmbd         C
C                 See documentation for FDCMBD for details.          C
C       MUST be calculated with:                                     C
C                                                                    C
C                     NDRVM = 1                                      C
C                     NLMN  = 2                                      C
C                     NRMN  = NR - 1                                 C
C                     NLMC  = 2                                      C
C                     NRMC  = NR - 1                                 C
C                                                                    C
C     CAFIT    : Coeff arr. for inhomog. temp. Dim( 3, NITHMX ).     C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE BLCNRS( VEC, INARR, NR, PARAM, MXATT, IERR, A, N1,
     1  N2, KL, MHT, MHL, MHM, MHP, MHTR, NBN, NCFM, NDRVM, NDCS,
     2  NTHP, NPHP, MMAX, LH, MHIBC, MHOBC, IPIV, LULOG, SVFDC, XARR,
     3  GAUX, GAUW, PA, DPA, FDCM, MHI, CAFIT )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER INARR( * ), NR, MXATT, IERR, N1, N2, KL, MHT( * ),
     1        MHL( * ), MHM( * ), MHP( * ), MHTR( * ), NBN, NCFM,
     2        NDRVM, NDCS, NTHP, NPHP, MMAX, LH, MHIBC( * ),
     3        MHOBC( * ), IPIV( * ), LULOG, MHI( * )
      DOUBLE PRECISION VEC( * ), PARAM( * ), A( N1, N2 ), XARR( NR ),
     1        SVFDC( NCFM, NR, NDRVM+1, NDCS ), GAUX( NTHP ),
     2        GAUW( NTHP ), PA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     3        DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHP), CAFIT( 3, * )
      DOUBLE PRECISION FDCM( NCFM, NR, 1 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NH, ICLS, NOIT, I, IOP,
     1        ILN, IRN, IHD, NDRVS, ICMP, ICMPO, NRMAX, NVI1, NVI2,
     2        LHMAX, NPHMAX, NTHMAX, M0, MAXNVI, NHMAX, ISVMAX,
     3        NTS, IH, IT10, IT11C, IT11S, ITCDC, IS, ILNT, IRNT, IMF
      DOUBLE PRECISION ZERO, CB1, CB2, CC, CD, CF, CG,
     1        CH, CI, PARS( 8 ), CTOL, FAC, DLOW, DONE,
     2        SOLN, RHSN, DNRM2
      PARAMETER ( ZERO = 0.0d0, IOP = 0, NRMAX = 200,
     1            NPHMAX = 128, NTHMAX = 64, LHMAX = 62,
     2            MAXNVI = 200000, NHMAX = 146, DONE = 1.0d0, 
     3            ISVMAX = NRMAX*NHMAX, DLOW = 1.0d-8 )
      PARAMETER ( IMF = 1 )
      INTEGER KKA1( MAXNVI ), KKB1( MAXNVI ), KKG1( MAXNVI ),
     1        KKA2( MAXNVI ), KKB2( MAXNVI ), KKG2( MAXNVI ),
     2        IPIVH( 4 )
      DOUBLE PRECISION ZCFA( NRMAX ), ZCFB( NRMAX ), ZCFC( NRMAX ),
     1                 F1( 2*NPHMAX ), F2( 2*NPHMAX ), 
     2                 F3( 2*NPHMAX ), SHC( LHMAX*(LHMAX + 2) ),
     3                 DSHC( LHMAX*(LHMAX + 2) ), CVI1( MAXNVI ),
     4                 CVI2( MAXNVI )
      CHARACTER *(4) TVHI1( MAXNVI ), TVHI2( MAXNVI )
      DOUBLE PRECISION QST( LHMAX*(LHMAX + 2), 3 ),
     1                 RQST1( LHMAX*(LHMAX + 2), 3, NRMAX ),
     2                 RQST2( LHMAX*(LHMAX + 2), 3, NRMAX ),
     3                 RQST3( LHMAX*(LHMAX + 2), 3, NRMAX ),
     4                 RQSTA( LHMAX*(LHMAX + 2), 3, NRMAX )
      DOUBLE PRECISION VF1( NPHMAX, NTHMAX, 3),
     1                 VF2( NPHMAX, NTHMAX, 3),
     2                 VF3( NPHMAX, NTHMAX, 3),
     3                 SF( NPHMAX, NTHMAX ), RHS( ISVMAX )
      DOUBLE PRECISION V0( ISVMAX ), V1( ISVMAX ), V2( ISVMAX ),
     1                 V3( ISVMAX ), V4( ISVMAX ), UM( ISVMAX, 4 ),
     2                 VM( ISVMAX, 4 ), HMAT( 4, 4), VTY( 4, 1 ),
     2                 HVTY( 4, 1 ), UHVTY( ISVMAX, 1 )
      CHARACTER *(3) CHVMFF
      LOGICAL OT10, OT11C, OT11S, OTCDC
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      ILN   = 2
      IRN   = NR - 1
      ILNT  = 3
      IRNT  = NR - 2
C
      OT10  = .FALSE.
      OT11C = .FALSE.
      OT11S = .FALSE.
      OTCDC = .FALSE.
C
      NH    = INARR( 3 )
C
      IF ( NR.GT.NRMAX .OR. NPHP.GT.NPHMAX .OR. LH.GT.LHMAX .OR.
     1     NTHP.GT.NTHMAX .OR. NH.GT.NHMAX .OR. N2.GT.ISVMAX ) THEN
        PRINT *,' Subroutine BLCNRS'
        PRINT *,' NR   = ', NR,  ' NRMAX  = ', NRMAX
        PRINT *,' NH   = ', NH,  ' NHMAX  = ', NHMAX
        PRINT *,' LH   = ', LH,  ' LHMAX  = ', LHMAX
        PRINT *,' N2   = ', N2,  ' ISVMAX = ', ISVMAX
        PRINT *,' NPHP = ', NPHP,' NPHMAX = ', NPHMAX
        PRINT *,' NTHP = ', NTHP,' NTHMAX = ', NTHMAX
        PRINT *,' Recompile routine with higher dimensions.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C We won't bother checking the bounds and dimensions of A
C as we are calling AVMLTA which does this all for us.
C
      CB1    = PARAM(  2 )
      CB2    = PARAM(  3 )
      CC     = PARAM(  4 )
      CD     = PARAM(  5 )
      CF     = PARAM(  7 )
      CG     = PARAM(  8 )
      CH     = PARAM(  9 )
      CI     = PARAM( 10 )
      CTOL   = PARAM( 12 )
C
C Calculate NTS. Now this is the number of additional
C vectors we need to use to solve the linear system.
C
      NTS = 0
C
C If our boundaries are stress free, then we may
C require up to three rows to be added to the matrix
C to fix the frame of reference.
C
      DO IH = 1, NH
        IS  = MHP( IH )
        IF (  MHIBC( IS ).EQ.6 .AND. MHOBC( IS ).EQ.6 .AND.
     1        MHT( IH ).EQ.2 .AND. MHL( IH ).EQ.1  ) THEN
C         .
          IF ( MHM( IH ).EQ.0 ) THEN
            NTS   = NTS + 1
            OT10  = .TRUE.
            IT10  = IH
          ENDIF
C         .
          IF ( MHM( IH ).EQ.1 .AND. DABS( CG ).LT.DLOW ) THEN
            NTS   = NTS + 1
            OT11C = .TRUE.
            IT11C = IH
          ENDIF
C         .
          IF ( MHM( IH ).EQ.-1 .AND. DABS( CG ).LT.DLOW ) THEN
            NTS   = NTS + 1
            OT11S = .TRUE.
            IT11S = IH
          ENDIF
C         .
        ENDIF
      ENDDO
C
C We now calculate the vector interactions which
C are used to form the matrix required for Newton-Raphson
C
      NVI1 = 0
      NVI2 = 0
C
C First: Scalar product ( v . \nabla \Theta )
C
      CALL VSPCC( NVI1, MAXNVI, KKA1, KKB1, KKG1, NH, MHT, MHL, MHM,
     1            NH, MHT, MHL, MHM, NH, MHTR, MHL, MHM, LH, NTHP,
     2            NPHP, MMAX, TVHI1, CVI1, GAUX, GAUW, PA, DPA,
     3            F1, VF1, VF2, SF, SHC )
C
C Second: Inertial term ( - \curl ( v \times \curl v )   )
C
      CALL VCCPCC( NVI2, MAXNVI, KKA2, KKB2, KKG2, NH, MHT, MHL, MHM,
     1             NH, MHT, MHL, MHM, NH, MHTR, MHL, MHM, LH, NTHP,
     2             NPHP, MMAX, TVHI2, CVI2, GAUX, GAUW, PA, DPA,
     3             F1, F2, F3, VF1, VF2, VF3, QST )
C
C We will now begin the iteration of the Newton
C Raphson process.
C
      NDRVS   = 4
      NOIT    = 0
 50   CONTINUE
      NOIT = NOIT + 1
C
      IF ( NOIT.GT.MXATT ) THEN
        IERR = -1
        GOTO 151
      ENDIF
C
C Evaluate the right hand side of system
C First zero RHS vector
C
      CALL VECOP( RHS, ZERO, N2, IOP )
C
C Take derivatives of current vector, VEC.
C
      IHD     = 4
      CALL CASVDR ( VEC, ILN, IRN, NBN, IHD, NCFM, NR, NDRVS,
     1              NDRVM, INARR, NDCS, MHP, SVFDC, V0, V1,
     2              V2, V3, V4 )
C
C Add inhomogeneous temperature terms to derivatives
C
      CALL IBTDVA( ILN, IRN, IHD, INARR, MHT, MHI, XARR,
     1             CAFIT, V0, V1, V2, V3, V4 )
C
C Add diffusive parts to the RHS
C
      FAC  = CI
      CALL SSVLC( NR, V0, V1, V2, V3, V4, INARR, MHT,
     1            MHL, MHM, RHS, INARR, MHTR, MHL, MHM,
     2            FAC, ILN, IRN, XARR )
C
      FAC  = CD
      ICMP = 3
      CALL SSVLP( NR, V0, V1, V2, INARR, MHT, MHL, MHM,
     1            ICMP, RHS, INARR, MHTR, MHL, MHM, FAC,
     2            ILN, IRN, XARR )
C     .
C     . Add on heat source terms
C     .
      FAC   = DONE
      CALL SSVHST( NR, V0, INARR, MHT, MHL, MHM, RHS,
     1             INARR, MHTR, MHL, MHM, FAC, ILN, IRN,
     2             XARR, CB1, CB2 )
C     .
C     . add on Buoyancy terms
C     .
      FAC   = CH
      ICMP  = 3
      ICMPO = 2
      CALL SSVTA( NR, V0, INARR, MHT, MHL, MHM, ICMP,
     1            RHS, INARR, MHTR, MHL, MHM, ICMPO,
     2            FAC, ILNT, IRNT )
C     .
      CALL VECOP( ZCFA, ZERO, NR, IOP )
      CALL VECOP( ZCFB, ZERO, NR, IOP )
      CALL VECOP( ZCFC, ZERO, NR, IOP )
C     .
C     . Now begin non-linear terms
C     . First put velocity into RQST1 array
C     .
      CHVMFF = 'VEL'
      CALL SDRQST( NR, LH, V0, V1, ILN, IRN, INARR,
     1             RQST1, XARR, MHT, MHL, MHM, CHVMFF )
C     .
C     . add on v . Grad( Theta ) terms to RHS
C     .
      FAC   = -1.0d0*CC
      CALL SDVGTA( NR, LH, MMAX, MHT, MHL, MHM, V0, V1, INARR,
     1             MHTR, MHL, MHM, RHS, INARR, RQST1, VF1, VF2,
     2             SF, F1, F2, F3, SHC, DSHC, GAUX, GAUW, PA, DPA,
     3             NTHP, NPHP, FAC, ILN, IRN, XARR, ZCFA)
C     .
C     . RQST1 contains the velocity, v, so by calling
C     . RQSTCF we can put (k x v) into RQST2.
C     .
      CALL RQSTCF( NR, LH, MMAX, ILN, IRN, NTHP, NPHP,
     1             GAUX, GAUW, PA, DPA, RQST1, ZCFA, RQST2,
     2             ZCFB, VF1, F1, F2, F3 )
C     .
C     . Taking curl of RQST2 and subtract (CG*) this
C     . amount from RQSTA
C     .
      ICLS  = 1
      FAC   = (-1.0d0)*CG
      M0    = 1
      CALL RQSTCA( LH, NR, M0, MMAX, NBN, NCFM, NDRVS, ILN, IRN,
     1             ILN, IRN, RQST2, RQSTA, XARR, FDCM, ICLS, ZERO,
     2             FAC )
C     .
C     . Take curl of velocity and store curl in RQST2
C     .
      ICLS  = 1
      FAC   = 1.0d0
      CALL RQSTCA( LH, NR, M0, MMAX, NBN, NCFM, NDRVS, ILN, IRN, ILN,
     1             IRN, RQST1, RQST2, XARR, FDCM, ICLS, ZERO, FAC )
C     .
C     . Evaluate [ v x curl v ] in RQST3
C     .
      CALL RQSTCP( NR, LH, MMAX, ILN, IRN, NTHP, NPHP,
     1             GAUX, GAUW, PA, DPA, RQST1, ZCFA, RQST2,
     2             ZCFB, RQST3, ZCFC, VF1, VF2, VF3, F1, F2, F3 )
C     .
C     . Add CF* curl of RQST3 to RQSTA
C     .
      ICLS  = 0
      FAC   = CF
      CALL RQSTCA( LH, NR, M0, MMAX, NBN, NCFM, NDRVS, ILN, IRN,
     1             ILN, IRN, RQST3, RQSTA, XARR, FDCM, ICLS, DONE, FAC )
C     .
C     . RQSTA now contains (   - CG curl (k x v)
C     .                      + CF curl[ v x (curl v) ]    )
C     . So - add this onto the vector RHS
C     .
      FAC = 1.0d0
      CHVMFF = 'VEL'
      CALL RQSTSV( NR, LH, ILN, IRN, INARR, MHTR, MHL, MHM,
     1             CHVMFF, RQSTA, RHS, XARR, FAC )
C
C Right hand side now complete. Calculate norm. (imf = 1)
C
      RHSN = DNRM2( N2, RHS, IMF )
      IF ( LULOG.NE.0 ) WRITE ( LULOG, 190 ) RHSN
C
 190  FORMAT('blcnrs: RHS norm = ',1pd16.7)
C
C Form the linear parts of matrix.
C If ICLS = 1, this also zeros the matrix
C
      PARS(  1 ) = ZERO
      PARS(  2 ) = (-1.0d0)*CB1
      PARS(  3 ) = (-1.0d0)*CB2
      PARS(  4 ) = (-1.0d0)*CD
      PARS(  5 ) = ZERO
      PARS(  6 ) = (-1.0d0)*CG
      PARS(  7 ) = (-1.0d0)*CH
      PARS(  8 ) = (-1.0d0)*CI
C
      ICLS = 1
      CALL AVMLTA( NR, INARR, MHT, MHL, MHM, MHP, MHTR, NBN, KL,
     1             NCFM, NDRVM, SVFDC, A, N1, N2, NDCS, XARR,
     2             NTHP, NPHP, MMAX, LH, GAUX, GAUW, PA, DPA,
     3             F1, F2, F3, VF1, QST, PARS, ICLS )
C
C Now add non-linear terms to matrix.
C We have already calculated the coefficients for this
C using VSPCC and VCCPCC ...
C
C Firstly: curl ( v0 x curl v_new ) terms
C
      FAC   = CF
      CALL RV0CVA( NR, N1, N2, KL, KL, KL, IMF, ILN, IRN,
     1    ILNT, IRNT, INARR, MHT, MHL, MHM, MHP, MHTR, MHL, MHM,
     2    INARR, MHT, MHL, MHM, MHP, NBN, NDCS, NDRVS, NDRVM, NCFM,
     3    NBN, NDCS, NDRVS, NDRVM, NCFM, A, FAC, XARR, VEC, SVFDC,
     4    SVFDC, NVI2, KKA2, KKB2, KKG2, TVHI2, CVI2 )
C
C Now: curl ( v_new x curl v0 ) terms
C
      CALL RVCV0A( NR, N1, N2, KL, KL, KL, IMF, ILN, IRN,
     1    ILNT, IRNT, INARR, MHT, MHL, MHM, MHP, MHTR, MHL, MHM,
     2    INARR, MHT, MHL, MHM, MHP, NBN, NDCS, NDRVS, NDRVM, NCFM,
     3    NBN, NDCS, NDRVS, NDRVM, NCFM, A, FAC, XARR, VEC, SVFDC,
     4    SVFDC, NVI2, KKA2, KKB2, KKG2, TVHI2, CVI2 )
C
C Now: v0 . nabla ( THETA_new ) terms
C
      FAC   = CC
      CALL RV0GTA( NR, N1, N2, KL, KL, KL, IMF, ILN, IRN, INARR,
     1    MHT, MHL, MHM, MHP, MHTR, MHL, MHM, INARR, MHT, MHL, MHM,
     2    MHP, NBN, NDCS, NDRVS, NDRVM, NCFM, NBN, NDCS, NDRVS,
     3    NDRVM, NCFM, A, FAC, XARR, VEC, SVFDC, SVFDC,
     4    NVI1, KKA1, KKB1, KKG1, TVHI1, CVI1 )
C
C Now: v_new . nabla ( THETA_0 ) terms
C
      CALL RVGI0A( NR, N1, N2, KL, KL, KL, IMF, ILN, IRN, INARR,
     1    MHT, MHL, MHM, MHP, MHTR, MHL, MHM, INARR, MHT, MHL, MHM,
     2    MHP, NBN, NDCS, NDRVS, NDRVM, NCFM, NBN, NDCS, NDRVS,
     3    NDRVM, NCFM, A, FAC, XARR, VEC, SVFDC, SVFDC,
     4    NVI1, KKA1, KKB1, KKG1, TVHI1, CVI1, MHI, CAFIT )
C
C Now prevent singularity of matrix through checking
C of boundary points ...
C
      CALL AMSDEA( A, N1, N2, KL, KL, KL, IMF, INARR,
     1             MHP, MHIBC, 'Inner', DONE, NDCS )
      CALL AMSDEA( A, N1, N2, KL, KL, KL, IMF, INARR,
     1             MHP, MHOBC, 'Outer', DONE, NDCS )
C
C Treat matrix for free rotations and additional
C columns with appropriate adjustments to RHS and
C formation of the correct Woodbury formula matrices
C 
      CALL NRCWMF( N1, N2, KL, KL, KL, NTS, ITCDC, IT10, IT11C,
     1             IT11S, NR, INARR, OTCDC, OT10, OT11C, OT11S,
     2             A, RHS, UM, VM, XARR, V4 )
C
C We have now fully prepared the matrix for Woodbury
C formula solution with the routine BMWDFS. We need to
C LU decompose so call ILUDF as IMF as this is 1.
C
      CALL BMWDFS( N1, N2, NTS, KL, KL, KL, IPIV, IPIVH, A,
     1             RHS, UM, VM, HMAT, VTY, HVTY, UHVTY, IMF )
C
      CALL ASVCPL( RHS, NR, NDCS, INARR, MHP, MHIBC, MHOBC,
     1             NCFM, NDRVS, NDRVM, NBN, SVFDC )
C
C Copy RHS back into VEC for next iteration (imf = 1)
C
      RHSN = DNRM2( N2, RHS, IMF )
      DO I = 1, N2
        VEC( I ) = VEC( I ) + RHS( I )
      ENDDO
      SOLN = DNRM2( N2, VEC, IMF )
      IF ( LULOG.NE.0 ) WRITE ( LULOG, 192 ) RHSN, SOLN
C
C Judge whether convergence has been achieved
C
      IF ( RHSN.LT.CTOL ) THEN
        IERR = NOIT
        GOTO 151
      ENDIF
C
 192  FORMAT('Sol. norms: change: ',1pd16.7,' total: ',1pd16.7)
C
C Return to the beginning of loop for next iteration
C
      GOTO 50
C
 151  CONTINUE
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine HarMonic File WriTe *************************************
C            -  -     -    -  -  *************************************
C Steve Gibbons Fri Nov 12 11:21:17 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Writes out the integer indices of spherical harmonic sets incl.    C
C the appropriate boundary conditions.                               C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NH        : Number of vector spherical harmonics.              C
C                                                                    C
C     MHT       : Array length ( * ) - atleast length NH             C
C                                                                    C
C         MHT( IH ) = 1 --> harmonic is poloidal velocity            C
C         MHT( IH ) = 2 --> harmonic is toroidal velocity            C
C         MHT( IH ) = 3 --> harmonic is temperature.                 C
C         MHT( IH ) = 4 --> harmonic is poloidal magnetic field      C
C         MHT( IH ) = 5 --> harmonic is toroidal magnetic field      C
C                                                                    C
C     MHL       : Array length ( * ) - atleast length NH             C
C                  Sph. harm. degree, l.                             C
C     MHM       : Array length ( * ) - atleast length NH             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHP       : Array length ( * ) - atleast length NH             C
C                  Pointer array to finite difference coefficients.  C
C                  MHP( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     NDCS      : Number of distinct finite difference schemes.      C
C                                                                    C
C     MHIBC     : Dimension ( NDCS ). Governs behaviour at inner     C
C                  boundary for finite diff. scheme ( is )           C
C                                                                    C
C  MHIBC( is ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHIBC( is ) = 2 --> Function must vanish at the bndry.            C
C  MHIBC( is ) = 3 --> First derivative must vanish at the bndry.    C
C  MHIBC( is ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHIBC( is ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHIBC( is ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHIBC( is ) = 7 --> r df/dr - l f(r) = 0 at the bndry.            C
C                        where L = MHL( ih )                         C
C                                                                    C
C     MHOBC     : Dimension ( NDCS ). Governs behaviour at outer     C
C                  boundary for finite diff. scheme ( is )           C
C                                                                    C
C  MHOBC( is ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHOBC( is ) = 2 --> Function must vanish at the bndry.            C
C  MHOBC( is ) = 3 --> First derivative must vanish at the bndry.    C
C  MHOBC( is ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHOBC( is ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHOBC( is ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHOBC( is ) = 7 --> r df/dr + (l+1) f(r) = 0 at the bndry.        C
C                        where L = MHL( ih )                         C
C                                                                    C
C     LU        : Logical file unit number.                          C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     FNAME     : *(*) File name.                                    C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE HMFWT( NH, MHT, MHL, MHM, MHP, NDCS, MHIBC, MHOBC,
     1                  LU, FNAME )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NH, MHT( * ), MHL( * ), MHM( * ), MHP( * ), NDCS,
     1        MHIBC( NDCS ), MHOBC( NDCS ), LU
      CHARACTER *(*) FNAME
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IH, IWR, IS, IIBF, IOBF
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Open file for writing
C
      IWR = 3
      CALL FOPEN ( LU, FNAME, IWR )
C
C Write number of spherical harmonics
C
      WRITE ( LU, 40 ) NH
C
C     Now loop around the harmonics and write out their
C     properties
C
      DO IH = 1, NH
        IS   = MHP( IH )
        IIBF = MHIBC( IS )
        IOBF = MHOBC( IS )
        WRITE ( LU, 41 ) MHT( IH ), MHL( IH ), MHM( IH ), IIBF, IOBF
      ENDDO
C
C Close file
C
      CALL FCLOSE ( LU, FNAME, 'Error closing file.' )
C
 40   FORMAT(I5)
 41   FORMAT(I2,I4,I5,I3,I3)
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Solution Vector File WriTe ******************************
C            -        -      -    -  -  ******************************
C Steve Gibbons Sat Nov 13 14:30:24 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Writes out a solution vector to a file.                            C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     INARR     : Array of integers. Dimension ( * )                 C
C                 At present the elements of INARR are as follows.   C
C                                                                    C
C                 INARR( 1 ) = IFORMF. Format flag.                  C
C                  This flag decides how the elements are arranged   C
C                  in the solution vector.                           C
C                                                                    C
C                  The current options are:-                         C
C                                                                    C
C                   IFORMF = 1, 3. INDFUN = ( IR - 1 )*NH + IH       C
C                   IFORMF = 2, 4. INDFUN = ( IH - 1 )*NR + IR       C
C                                                                    C
C  where IR and IH are the current grid node and harmonic resp.      C
C  and NR and NH are the total numbers of nodes and harmonics        C
C  in the solution vector.                                           C
C                                                                    C
C                 INARR( 2 ) = NR. Number of radial grid nodes.      C
C                 INARR( 3 ) = NH. Number of harmonics in sol. vect. C
C                                                                    C
C     LU        : Logical file unit number.                          C
C                                                                    C
C     IFORM     : Specifies how the x values are stored on the file. C
C                 Current values are:-                               C
C                                                                    C
C                   IFORM = 1 --> (5(1PD16.7))                       C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     SV        : Dim ( * ) but length atleast NR*NH.                C
C                  Solution vector defined by INARR.                 C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     FNAME     : *(*) File name.                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SVFWT( INARR, LU, IFORM, SV, FNAME )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER INARR( * ), LU, IFORM
      CHARACTER *(*) FNAME
      DOUBLE PRECISION SV( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I, IWR, ILEN, IFORMF, NR, NH
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IFORMF = INARR( 1 )
      NR     = INARR( 2 )
      NH     = INARR( 3 )
C
      ILEN   = NR*NH
C
C Check that value of IFORM is legal
C
      IF ( IFORM.NE.1 ) THEN
        PRINT *,' Subroutine SVFWT.'
        PRINT *,' IFORM = ', IFORM
        PRINT *,' Currently, 1 is the only permissible value.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Open file for writing
C
      IWR = 3
      CALL FOPEN ( LU, FNAME, IWR )
C
C Write iformf, nr, nh, iform
C  
       WRITE ( LU, 40 ) IFORMF, NR, NH, IFORM
C
C OK, so write X values ...
C
      IF ( IFORM.EQ.1 ) WRITE ( LU, 41 ) ( SV( I ), I = 1, ILEN )
C
C Close file
C
      CALL FCLOSE ( LU, FNAME, 'Error closing file.' )
C
 40   FORMAT(I5,I5,I5,I5)
 41   FORMAT(5(1PD16.7))
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine X value ARRay WriTe *************************************
C            -       ---   -  -  *************************************
C Steve Gibbons Fri Nov 12 08:53:38 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Writes out the XARR array of abscissae to a file.                  C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C                 Note that NR is not checked for correspondence to  C
C                 any other value - merely for being not greater     C
C                 than NRMAX.                                        C
C                                                                    C
C     LU        : Logical file unit number.                          C
C                                                                    C
C     IFORM     : Specifies how the x values are stored on the file. C
C                 Current values are:-                               C
C                                                                    C
C                   IFORM = 1 --> (5(1PD16.7))                       C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Dim ( * ) but length atleast NR. Location of       C
C                  radial grid nodes.                                C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     FNAME     : *(*) File name.                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE XARRWT( NR, XARR, LU, FNAME, IFORM )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, LU, IFORM
      CHARACTER *(*) FNAME
      DOUBLE PRECISION XARR( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I, IWR
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check that value of IFORM is legal
C
      IF ( IFORM.NE.1 ) THEN
        PRINT *,' Subroutine XARRWT.'
        PRINT *,' IFORM = ', IFORM
        PRINT *,' Currently, 1 is the only permissible value.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Open file for writing
C
      IWR = 3
      CALL FOPEN ( LU, FNAME, IWR )
C
C Write number of radial grid nodes
C
      WRITE ( LU, 40 ) NR, IFORM
C
C OK, so write X values ...
C
      IF ( IFORM.EQ.1 ) WRITE ( LU, 41 ) ( XARR( I ), I = 1, NR )
C
C Close file
C
      CALL FCLOSE ( LU, FNAME, 'Error closing file.' )
C
 40   FORMAT(I5,I5)
 41   FORMAT(5(1PD16.7))
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Inhomogeneous Temperature Function Add ******************
C            -             -           -        -   ******************
C Steve Gibbons Mon Jan 17 11:25:35 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C The function f( r ) for ri .le. r .le. ro is defined by            C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C Then clearly,    f( ri )  = CB 2 ( ri-ro )/pi + CC                 C
C                  f'( ri ) = CA 0.5 pi/(ro-ri)                      C
C                                                                    C
C                  f( ro )  = CA                + CC                 C
C                  f'( ro ) = CB                                     C
C                                                                    C
C For the coefficients CA, CB and CC (see ITFCF) ITFA will return    C
C derivatives 0 to IHD of f( r ) with f[nd]( r ) in DERV( nd + 1 )   C
C                                                                    C
C Currently IHD may be no larger than 4 although the routine could   C
C easily be modified for higher derivatives if the need arose.       C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     IHD      : The number of the highest derivative requested.     C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RAD      : Current radius.                                     C
C     RI       : Radius of the inner boundary.                       C
C     RO       : Radius of the outer boundary.                       C
C     CA       : Coefficient of term in f(r). See above.             C
C     CB       : Coefficient of term in f(r). See above.             C
C     CC       : Coefficient of term in f(r). See above.             C
C     DERV     : Array of length atleast ( IHD + 1 ).                C
C                 DERV( nd + 1 ) returned with nd^{th} deriv. of f.  C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ITFA( RAD, RI, RO, CA, CB, CC, DERV, IHD )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IHD
      DOUBLE PRECISION RAD, RI, RO, CA, CB, CC, DERV( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      DOUBLE PRECISION PI, ROMRI, RMRI, LOW, FAC, TERMA, TERMB,
     1                 DOPRND
      PARAMETER ( PI=3.14159265358979312D0, LOW = 1.0d-7 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      IF (      DABS( CA ).LT.LOW      .AND.
     1          DABS( CB ).LT.LOW      .AND.
     2          DABS( CC ).LT.LOW     )      RETURN
C     .
      RMRI  = RAD - RI
      ROMRI = RO - RI
      IF ( DABS( ROMRI ).LT.LOW ) THEN
        PRINT *,' Subroutine ITFA.'
        PRINT *,' RI = ', RI,' RO = ', RO
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Check on bounds for IHD
C     .
      IF ( IHD.LT.0 .OR. IHD.GT.4 ) THEN
        PRINT *,' Subroutine ITFA.'
        PRINT *,' IHD = ', IHD
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      FAC    = 0.5d0*PI/ROMRI
      DOPRND = FAC*RMRI
C
      TERMA  = CA*DSIN( DOPRND )
      TERMB  = CB*DCOS( DOPRND )*(-1.0d0)/FAC
      DERV( 1 ) = DERV( 1 ) + TERMA + TERMB + CC
      IF ( IHD.EQ.0 ) RETURN
C     .
      TERMA  = CA*FAC*DCOS( DOPRND )
      TERMB  = CB*DSIN( DOPRND )
      DERV( 2 ) = DERV( 2 ) + TERMA + TERMB
      IF ( IHD.EQ.1 ) RETURN
C     .
      TERMA  = (-1.0d0)*CA*FAC*FAC*DSIN( DOPRND )
      TERMB  = CB*FAC*DCOS( DOPRND )
      DERV( 3 ) = DERV( 3 ) + TERMA + TERMB
      IF ( IHD.EQ.2 ) RETURN
C     .
      TERMA  = (-1.0d0)*CA*FAC*FAC*FAC*DCOS( DOPRND )
      TERMB  = (-1.0d0)*CB*FAC*FAC*DSIN( DOPRND )
      DERV( 4 ) = DERV( 4 ) + TERMA + TERMB
      IF ( IHD.EQ.3 ) RETURN
C     .
      TERMA  = CA*FAC*FAC*FAC*FAC*DSIN( DOPRND )
      TERMB  = (-1.0d0)*CB*FAC*FAC*FAC*DCOS( DOPRND )
      DERV( 5 ) = DERV( 5 ) + TERMA + TERMB
      IF ( IHD.EQ.4 ) RETURN
C     .
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Solution Vector PRiNT ***********************************
C            -        -      -- -- ***********************************
C Steve Gibbons Fri Sep 24 13:43:53 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Outputs an eye-readable breakdown of a solution vector with the    C
C radial function of each component being headed by its              C
C description.                                                       C
C                                                                    C
C Writes out to file with logical unit number, LU.                   C
C                                                                    C
C If LU = 6, it goes to standard output, otherwise it goes to        C
C an opened file. SVPRNT does NOT open files.                        C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to V.           C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR     See INDFUN for details        C
C                 INARR( 3 ) = NH      nrr must equal nr             C
C                                                                    C
C     MHT       : Array length ( * ) - atleast length NH             C
C                                                                    C
C     MHT( ih ) = 1 if 'ih' is poloidal velocity harmonic.           C
C     MHT( ih ) = 2 if 'ih' is toroidal velocity harmonic.           C
C     MHT( ih ) = 3 if 'ih' is temperature harmonic.                 C
C     MHT( ih ) = 4 if 'ih' is poloidal magnetic field harmonic.     C
C     MHT( ih ) = 5 if 'ih' is toroidal magnetic field harmonic.     C
C                                                                    C
C     MHL       : Spherical harmonic degree, l, of harmonic 'ih'.    C
C                                                                    C
C     MHM       : Spherical harmonic degree, m, of harmonic 'ih'     C
C                if harmonic has (cos m phi dependence) - otherwise  C
C                MHM( ih ) = -m                                      C
C                                                                    C
C     ILNR      : Lowest radial node to output.                      C
C     IRNR      : Highest radial node to output.                     C
C                                                                    C
C     LU        : Logical unit number of file for output.            C
C                                                                    C
C     IZF       : = 1 to display ALL vectors                         C
C                 = 2 to display only non-zero harmonics             C
C                                                                    C
C     IMODE     : Integer flag which sets the format of output       C
C                 Currently, option is limited to IMODE = 1.         C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     V         : DP vector of dimension ( * ) containing solution   C
C                 Length must be atleast NH*NR                       C
C                                                                    C
C     DPARR     : Array for use by RADVLF                            C
C                                                                    C
C     XARR      : Array ( * ). Only referenced if IFORMF = 3 or 4.   C
C                 In this case dim( xarr ) must be atleast NR and    C
C                 xarr( IR ) will contain the x value at node IR.    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SVPRNT ( V, NR, INARR, DPARR, XARR, MHT, MHL, MHM,
     1                    ILNR, IRNR, LU, IZF, IMODE )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHT( * ), MHL( * ), MHM( * ), ILNR,
     1        IRNR, LU, IZF, IMODE
      DOUBLE PRECISION V( * ), DPARR( * ), XARR( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION RAD, TOL, HTOT, H
      INTEGER IND, IH, NH, NRR, IR, M, INDFUN
      PARAMETER ( TOL = 1.0d-6 )
      CHARACTER *(23) CHPV, CHTV, CHTH, CHPM, CHTM, CH23
      CHARACTER *(3) CHCOS, CHSIN, CH3
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IF ( IMODE.NE.1 ) THEN
        PRINT *,' Subroutine SVPRNT.'
        PRINT *,' IMODE = ', IMODE
        PRINT *,' IMODE = 1 only current option.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      NRR = INARR( 2 )
      NH  = INARR( 3 )
      IF ( NRR.NE.NR ) THEN
        PRINT *,' Subroutine SVPRNT.'
        PRINT *,' NRR = ', NRR,' NR = ', NR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( IZF.EQ.2 ) THEN
        WRITE ( LU, 82 ) '# Non-zero radial functions only,'
      ENDIF
C
      CHCOS = 'Cos'
      CHSIN = 'Sin'
C
      CHPV = 'Poloidal velocity      '
      CHTV = 'Toroidal velocity      '
      CHTH = 'Temperature            '
      CHPM = 'Poloidal magnetic field'
      CHTM = 'Toroidal magnetic field'
C             00000000011111111112222
C             12345678901234567890123
C     .
      DO IH = 1, NH
        IF ( IZF.EQ.2 ) THEN
           HTOT = 0.0d0
           DO IR = 1, NR
             IND = INDFUN( IR, IH, INARR )
             HTOT = HTOT + DABS( V( IND ) )
           ENDDO
           IF ( HTOT.LT.TOL ) GOTO 100
        ENDIF
C       .
C       . Decide nature of our harmonic
C       .
        M = IABS( MHM( IH ) )
C       .
        IF ( MHT( IH ).EQ.1 ) CH23 = CHPV
        IF ( MHT( IH ).EQ.2 ) CH23 = CHTV
        IF ( MHT( IH ).EQ.3 ) CH23 = CHTH
        IF ( MHT( IH ).EQ.4 ) CH23 = CHPM
        IF ( MHT( IH ).EQ.5 ) CH23 = CHTM
C       .
        IF ( MHM( IH ).GE.0 ) CH3  = CHCOS
        IF ( MHM( IH ).LT.0 ) CH3  = CHSIN
C       .
        IF ( IMODE.EQ.1 ) WRITE ( LU, 88 )
     1       CH23, MHL( IH ), M, CH3
        IF ( IMODE.EQ.1 ) WRITE ( LU, 89 )
C       .
        DO IR = ILNR, IRNR
          CALL RADVLF( RAD, IR, INARR, DPARR, XARR, H )
          IND = INDFUN( IR, IH, INARR )
          IF ( IMODE.EQ.1 ) WRITE ( LU, 90 ) RAD, V( IND )
        ENDDO
C       .
 100    CONTINUE
      ENDDO
 82   FORMAT(A)
 88   FORMAT('#  ',A23,' L= ',I3,' M= ',I3,' ',A3)
 89   FORMAT('#  ----------------------------------------')
 90   FORMAT(f20.9,f20.9)
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine File NAME giveR *****************************************
C            -    ----     - *****************************************
C Steve Gibbons 14.4.97 (Adapted from Dan Gordon's course.)          C
C____________________________________________________________________C
C Asks the user for a file name FNAME. Pretty simple really ...      C
C____________________________________________________________________C
C Input Variable :-						     C
C ==============   						     C
C  Character							     C
C  ---------							     C
C     LABEL	: Message arbitrary length  			     C
C____________________________________________________________________C
C Output Variable :-						     C
C ===============   						     C
C  Character							     C
C  ---------							     C
C     FNAME	: Filename arbitrary length			     C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE FNAMER ( FNAME, LABEL )
      IMPLICIT NONE
      CHARACTER *(*) FNAME
      CHARACTER *(*) LABEL

      PRINT *,' Please enter a filename for FNAME.'
      PRINT *, LABEL
      READ (5, 200) FNAME
 200  FORMAT (A)
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Linear Dependence of Grid Node Matrix Form **************
C            -      -             -    -    -      -    **************
C Steve Gibbons Sat Oct 23 15:01:52 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Let f be a function of x and let f_j denote the value of f at      C
C the grid node j (x value is x_j given by XARR( j ) ... )           C
C                                                                    C
C If f has to satisfy a particular boundary condition then           C
C all the f_j may not be linearly independent.                       C
C                                                                    C
C For a group of n ( = NNDS ) grid nodes, from s = k+1 to k+n        C
C for some integer, k,                                               C
C                                                                    C
C  f_{k+i} = \sum_{s=1}^n DMAT( i, s ) f_{k+s},                      C
C                                                                    C
C and the routine LDGNMF returns the matrix DMAT.                    C
C                                                                    C
C The number of linearly dependent nodes to the left and right are   C
C given by NALF and NARF respectively.                               C
C                                                                    C
C The boundary conditions at the inner and outer boundaries are      C
C specified by the integers IIBC and IOBC which may take the         C
C following values                                                   C
C                                                                    C
C    IIBC              Inner Boundary Condition                      C
C    ====              ========================                      C
C                                                                    C
C      1       No condition to be applied                            C
C      2       Function must vanish                                  C
C      3       First derivative must vanish                          C
C      4       Function AND first derivative must vanish             C
C      5       Function AND second derivative must vanish            C
C      6       rdf/dr - f(r) = 0                                     C
C      7       r df/dr - l f(r) = 0                                  C
C                                                                    C
C    IOBC              Outer Boundary Condition                      C
C    ====              ========================                      C
C                                                                    C
C      1       No condition to be applied                            C
C      2       Function must vanish                                  C
C      3       First derivative must vanish                          C
C      4       Function AND first derivative must vanish             C
C      5       Function AND second derivative must vanish            C
C      6       rdf/dr - f(r) = 0                                     C
C      7       r df/dr + (l+1) f(r) = 0                              C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Total number of radial grid nodes.                 C
C     NNDS      : Number of nodes needed to take derivative.         C
C     NALF      : Number of nodes to left which are a linear         C
C                 combination of the other nodes.                    C
C     NARF      : Number of nodes to right which are a linear        C
C                 combination of the other nodes.                    C
C     L         : Spherical harmonic degree, l.                      C
C     IIBC      : Inner boundary flag - see above.                   C
C     IOBC      : Outer boundary flag - see above.                   C
C     NCFM      : Leading dimension of array DMAT etc.               C
C     IPCM      : Dimension ( NCFM ). Working array.                 C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Array of dimension ( NR ).                         C
C                  XARR( i ) contains the value of r at the          C
C                   i^{th} grid node.                                C
C                                                                    C
C     DMAT      : Dimension ( NCFM, NCFM ). See above.               C
C     WMAT      : Dimension ( NCFM, NCFM ). Working array.           C
C     WORK1     : Dimension ( NCFM ). Working array.                 C
C     WORK2     : Dimension ( NCFM ). Working array.                 C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE LDGNMF( NR, NNDS, NALF, NARF, L, IIBC, IOBC, NCFM,
     1                   XARR, DMAT, WMAT, WORK1, WORK2, IPCM )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, NNDS, NALF, NARF, L, IIBC, IOBC, NCFM,
     1        IPCM( NCFM )
      DOUBLE PRECISION XARR( NR ), DMAT( NCFM, NCFM),
     1                 WMAT( NCFM, NCFM), WORK1( NCFM ),
     2                 WORK2( NCFM )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER I, IFN, ILN, NDS2, ID1, IHND
      DOUBLE PRECISION ZERO, TOL, X0, FAC, QUOT
      PARAMETER ( ZERO = 0.0d0, TOL = 1.0d-9 )
C ifn is first linearly independent node
C iln is last linearly independent node
C ihnd is the highest number derivative which
C will be needed to be calculated during this
C routine (by GFDCFD)
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First check on values of NALF and NARF
C
      I = NALF*NARF
      IF ( I.NE.0 .OR. (NALF.LT.0) .OR. (NALF.GT.2) .OR.
     1                 (NARF.LT.0) .OR. (NARF.GT.2)       ) THEN
        PRINT *,' Subroutine LDGNMF.'
        PRINT *,' NALF = ', NALF
        PRINT *,' NARF = ', NARF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Ok - the number of affected nodes is valid
C     . so let's proceed. First, zero the matrix DMAT
C     .
      I = 0
      CALL MATOP( DMAT, ZERO, NCFM, NCFM, I )
C     .
C     . Now add the diagonal elements for the
C     . linearly independent variables
C     .
      IF ( NALF.EQ.0 ) IFN = 1
      IF ( NALF.EQ.1 ) IFN = 2
      IF ( NALF.EQ.2 ) IFN = 3
C     .
      IF ( NARF.EQ.0 ) ILN = NNDS
      IF ( NARF.EQ.1 ) ILN = NNDS - 1
      IF ( NARF.EQ.2 ) ILN = NNDS - 2
C     .
      DO I = IFN, ILN
        DMAT( I, I ) = 1.0d0
      ENDDO
C     .
C     . We can now return if the identity matrix is required
C     .
      IF ( NALF.EQ.0 .AND. NARF.EQ.0 ) RETURN
C     .
C     .
C     . OK - now decide whether we are doing inner or
C     . outer boundary
C     .
      IF ( NARF.EQ.0 ) THEN
C       .
C       . We are considering the inner boundary
C       . First, return if IIBC = 1 or 2
C       .
        IF ( IIBC.EQ.1 .OR. IIBC.EQ.2 ) RETURN
C       .
C       . So we need to calculate deriv.s at
C       . the inner boundary, XARR( 1 ).
C       . NDS2 is the number of nodes we can use at
C       . the inner boundary.
C       .
        IF ( IIBC.EQ.5 ) THEN
          IHND = 2
        ELSE
          IHND = 1
        ENDIF
C       .
        NDS2 = 1 + NNDS - NALF
C       .
        IF ( (NDS2-1).LT.IHND ) THEN
           PRINT *,' Subroutine LDGNMF '
           PRINT *,' NDS2                = ', NDS2
           PRINT *,' Required derivative = ', IHND
           PRINT *,' Program aborted.'
           STOP
        ENDIF
C       .
        DO I = 1, NDS2
          WORK1( I ) = XARR( I )
        ENDDO
        X0 = XARR( 1 )
        CALL GFDCFD ( X0, WORK1, NDS2, WMAT, NCFM, IPCM, WORK2 )
C       .
C       . WMAT( m + 1, i ) now contains the coefficient
C       . with which you multiply f_i to get the m^{th}
C       . derivative of f at x_0.
C       .
C       . Consider the case IIBC = 3
C       . We require the first derivative = 0
C       .
        IF ( IIBC.EQ.3 ) THEN
C          .
C          . Just quickly check that NALF = 1
C          . It should not be anything else at this stage.
C          .
           IF ( NALF.NE.1 ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' IIBC = ',IIBC,' and NALF = ',NALF
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
C          . Check for imminent division by zero
C          .
           IF ( ABS( WMAT( 2, 1 ) ).LT.TOL ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' WMAT( 2, 1 ) = ',WMAT( 2, 1 )
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
           DO I = 2, NDS2
             DMAT( 1, I ) = (-1.0d0)*WMAT( 2, I )/WMAT( 2, 1 )
           ENDDO
           RETURN
C          .
        ENDIF
C       .
C       . Consider the case IIBC = 4(5)
C       . We need both the function and the first
C       . (second) derivative to vanish. We do not need to
C       . to change anything to make the function
C       . vanish so just need do the first (second) deriv. cond.
C       .
        IF ( IIBC.EQ.4 .OR. IIBC.EQ.5 ) THEN
C          .
C          . Check for imminent division by zero
C          .
           IF ( IIBC.EQ.4 ) ID1 = 2
           IF ( IIBC.EQ.5 ) ID1 = 3
C          .
           IF ( ABS( WMAT( ID1, 2 ) ).LT.TOL ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' WMAT(',ID1,', 2 ) = ',WMAT( ID1, 2 )
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
           DO I = 3, NDS2
             DMAT( NALF, NALF - 2 + I ) =
     1                    (-1.0d0)*WMAT( ID1, I )/WMAT( ID1, 2 )
           ENDDO
           RETURN
C          .
        ENDIF
C       .
C       . We may treat the cases IIBC.EQ.6 and IIBC.EQ.7
C       . together as they are both conditions of the form
C       . rdf/dr + FAC f(r) = 0
C       .
        IF ( IIBC.EQ.6 .OR. IIBC.EQ.7 ) THEN
C          .
C          . First we make an early escape if r_{inner bnd} = 0
C          . this is equivlent to setting the function to zero
C          . which is what the current status of the matrix is
C          .
           IF ( ABS( X0 ).LT.TOL ) RETURN
C          .
C          . OK - so it's non-trivial!
C          . First, let's allocate the correct value of FAC
C          .
           IF ( IIBC.EQ.6 ) FAC = -1.0d0
           IF ( IIBC.EQ.7 ) FAC = -1.0d0*DBLE( L )
C          .
C          . Just quickly check that NALF = 1
C          . It should not be anything else at this stage.
C          .
           IF ( NALF.NE.1 ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' IIBC = ',IIBC,' and NALF = ',NALF
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
C          . Check for imminent division by zero
C          . We can safely divide by X0 now since the
C          . X0 = 0.0 case has been discounted above.
C          .
           QUOT = FAC/X0 + WMAT( 2, 1 )
           IF ( ABS( QUOT ).LT.TOL ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' QUOT = ', QUOT
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
           DO I = 2, NDS2
             DMAT( 1, I ) = (-1.0d0)*WMAT( 2, I )/QUOT
           ENDDO
           RETURN
C          .
        ENDIF
C       .
      ELSE
C       .
C       . We are considering the outer boundary
C       . First, return if IOBC = 1 or 2
C       .
        IF ( IOBC.EQ.1 .OR. IOBC.EQ.2 ) RETURN
C       .
C       . So we need to calculate deriv.s at
C       . the outer boundary, XARR( NR ).
C       . NDS2 is the number of nodes we can use at
C       . the outer boundary.
C       .
        IF ( IOBC.EQ.5 ) THEN
          IHND = 2
        ELSE
          IHND = 1
        ENDIF
C       .
        NDS2 = 1 + NNDS - NARF
C       .
        IF ( (NDS2-1).LT.IHND ) THEN
           PRINT *,' Subroutine LDGNMF '
           PRINT *,' NDS2                = ', NDS2
           PRINT *,' Required derivative = ', IHND
           PRINT *,' Program aborted.'
           STOP
        ENDIF
C       .
        DO I = 1, NDS2
          WORK1( I ) = XARR( NR - NDS2 + I )
        ENDDO
        X0 = XARR( NR )
        CALL GFDCFD ( X0, WORK1, NDS2, WMAT, NCFM, IPCM, WORK2 )
C       .
C       . WMAT( m + 1, i ) now contains the coefficient
C       . with which you multiply f_{nr-nds2+i} to get the m^{th}
C       . derivative of f at x_0.
C       .
C       . Consider the case IOBC = 3
C       . We require the first derivative = 0
C       .
        IF ( IOBC.EQ.3 ) THEN
C          .
C          . Just quickly check that NARF = 1
C          . It should not be anything else at this stage.
C          .
           IF ( NARF.NE.1 ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' IOBC = ',IOBC,' and NARF = ',NARF
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
C          . Check for imminent division by zero
C          .
           IF ( ABS( WMAT( 2, NDS2 ) ).LT.TOL ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' WMAT( 2,',NDS2,') = ',WMAT( 2, NDS2 )
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
C          .
           DO I = 1, NDS2-1
             DMAT( NNDS, NNDS - NDS2 + I ) =
     1             (-1.0d0)*WMAT( 2, I )/WMAT( 2, NDS2 )
           ENDDO
           RETURN
C          .
        ENDIF
C       .
C       . Consider the case IOBC = 4(5)
C       . We need both the function and the first
C       . (second) derivative to vanish. We do not need to
C       . to change anything to make the function
C       . vanish so just need do the first (second) deriv. cond.
C       .
        IF ( IOBC.EQ.4 .OR. IOBC.EQ.5 ) THEN
C          .
C          . Check for imminent division by zero
C          .
           IF ( IOBC.EQ.4 ) ID1 = 2
           IF ( IOBC.EQ.5 ) ID1 = 3
C          .
           IF ( ABS( WMAT( 2, NDS2-1 ) ).LT.TOL ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' WMAT(',ID1,',',NDS2-1,') = ',WMAT( ID1,NDS2-1)
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
           DO I = 1, NDS2-2
             DMAT( NNDS + 1 - NARF, NNDS - NDS2 - NARF + 2 + I ) =
     1                    (-1.0d0)*WMAT( ID1, I )/WMAT( ID1, NDS2-1)
           ENDDO
           RETURN
C          .
        ENDIF
C       .
C       . We may treat the cases IOBC.EQ.6 and IOBC.EQ.7
C       . together as they are both conditions of the form
C       . rdf/dr + FAC f(r) = 0
C       .
        IF ( IOBC.EQ.6 .OR. IOBC.EQ.7 ) THEN
C          .
C          . Just quickly check that NARF = 1
C          . It should not be anything else at this stage.
C          .
           IF ( NARF.NE.1 ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' IOBC = ',IOBC,' and NARF = ',NARF
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
C          . First, let's allocate the correct value of FAC
C          .
           IF ( IOBC.EQ.6 ) FAC = -1.0d0
           IF ( IOBC.EQ.7 ) FAC = DBLE( L + 1 )
C          .
C          . Check for imminent division by zero
C          . (Once again, we safely divide by X0)
C          .
           QUOT = FAC/X0 + WMAT( 2, NDS2 )
           IF ( ABS( QUOT ).LT.TOL ) THEN
             PRINT *,' Subroutine LDGNMF '
             PRINT *,' QUOT = ', QUOT
             PRINT *,' Program aborted.'
             STOP
           ENDIF
C          .
C          .
           DO I = 1, NDS2-1
             DMAT( NNDS, NNDS - NDS2 + I ) =
     1             (-1.0d0)*WMAT( 2, I )/QUOT
           ENDDO
           RETURN
C          .
        ENDIF
C       .
      ENDIF
C     .
      PRINT *,' Subroutine LDGNMF '
      PRINT *,' Problem with inputs.'
      PRINT *,' IIBC = ', IIBC
      PRINT *,' IOBC = ', IOBC
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine General Finite Difference Coefficient Find **************
C            -       -      -          -           -    **************
C Steve Gibbons Mon Sep 20 16:57:54 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Given a value of X and the values of x_i at NNDS distinct points,  C
C (X need not necessarily be one of the x_i) then the array COEFM    C
C is returned with the finite difference coefficients such that      C
C the ND^{th} derivative of a function f, evaluated at x = X,        C
C is given by                                                        C
C                                                                    C
C f^{ ND }( X ) = \sum_{j = 1, NNDS} COEFM( ND + 1, j )*f( x_j )     C
C                                                                    C
C This is a general version of the routine FDCINV which is valid     C
C only for equally spaced grid nodes.                                C
C                                                                    C
C Coefficients for up to the (NNDS-1)^{th} derivative are given      C
C although care must be taken to ensure the highest derivatives      C
C are sufficiently accurate.                                         C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     X         : Abscissa at which derivatives are to be            C
C                  evaluated.                                        C
C     XARR      : Array of dimension ( NNDS ).                       C
C                  XARR( i ) contains the value of x/r at the        C
C                   i^{th} grid node.                                C
C                                                                    C
C     COEFM     : Dimension ( NCFM, NCFM).                           C
C     WORK      : Workspace array for LAPACK inversion routine.      C
C                 Dimension ( NCFM )                                 C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NNDS      : Number of grid nodes.                              C
C     NCFM      : Leading order of coefficient matrix.               C
C                                                                    C
C     IPCM      : Work array for LAPACK routines to perform          C
C                 pivotting in the matrix inversion.                 C
C                 Dimension ( NCFM )                                 C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE GFDCFD ( X, XARR, NNDS, COEFM, NCFM, IPCM, WORK)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NNDS, NCFM, IPCM( NCFM )
      DOUBLE PRECISION X, COEFM( NCFM, NCFM ), WORK( NCFM ),
     1                 XARR( NNDS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER I, J, NDER, INODE, INFO, ICOL, IROW
      DOUBLE PRECISION DZERO, LOW, FAC
      PARAMETER ( DZERO = 0.0d0, LOW = 1.0d-8 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check bounds of integer parameters
C
      IF ( NNDS.GT.NCFM ) THEN
         PRINT *,' Subroutine GFDCFD: '
         PRINT *,' NNDS = ', NNDS,'. NCFM = ', NCFM
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C Calculate the distances h_i = ( x_i - X )
C These h_i must be distinct and this will be
C checked for - otherwise matrix is singular.
C We can store the h_i in WORK as this will not
C be needed until the inversion, by which time
C it will not be needed by us.
C
      DO I = 1, NNDS
        WORK( I ) = XARR( I ) - X
      ENDDO
C
C Now check for the uniqueness of the points ...
C
      DO I = 1, NNDS - 1
        DO J = I + 1, NNDS
          IF ( ABS( WORK( I ) - WORK( J ) ).LT.LOW ) THEN
            PRINT *,' Subroutine GFDCFD.'
            PRINT *,' X values ',I,' and ',J,' are'
            PRINT *,' identical.'
            PRINT *,' Program aborted.'
            STOP
          ENDIF
        ENDDO
      ENDDO
C
C____________________________________________________________________C
C Parameters are ok so let's zero COEFM
C
      I = 0
      CALL MATOP( COEFM, DZERO, NCFM, NCFM, I )
C
C (nder+1) is the number of the matrix column being filled in.
C inode is the number of the matrix row being filled in.
C
      DO NDER = 0, NNDS - 1
        ICOL = NDER + 1
        DO INODE = 1, NNDS
          IROW = INODE
          IF ( NDER.EQ.0 ) THEN
            COEFM( IROW, ICOL )  = 1.0d0
          ELSE
            FAC = WORK( INODE )/DBLE( NDER )
            COEFM( IROW, ICOL ) = COEFM( IROW, ICOL-1 )*FAC
          ENDIF
        ENDDO
      ENDDO
C
C Ok - this matrix is now ready for inversion -
C For this we use the LAPACK routines DGETRF and DGETRI
C First perform LU decomposition
C
      CALL DGETRF( NNDS, NNDS, COEFM, NCFM, IPCM, INFO )
C
C     . Check that LU decomposition has gone without
C     . problem.
C     .
C
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine GFDCFD.'
         PRINT *,' The LAPACK subroutine DGETRF has'
         PRINT *,' returned ',INFO,' as a value of '
         PRINT *,' INFO in LU decomposition of COEFM matrix.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Now compute the inverse with the LAPACK routine
C     . DGETRI.
C     .
      CALL DGETRI( NNDS, COEFM, NCFM, IPCM, WORK, NCFM, INFO )
C     .
C     . Check that inversion has gone without problem.
C     .
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine GFDCFD.'
         PRINT *,' The LAPACK subroutine DGETRI has'
         PRINT *,' returned ',INFO,' as a value of '
         PRINT *,' INFO in inversion of COEFM matrix.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
      RETURN
      END
C*********************************************************************
C********************************************************************
C subroutine L and M FIND *******************************************
C            -     - ---- *******************************************
C Steve Gibbons 12.4.97                                             C
C Modified 12.6.97 to have IT = 1 for cos and 2 for sine            C
C___________________________________________________________________C
C Given a number of harmonic, N; LMFIND will return the level, L,   C
C the order, M, and IT - which is equal to 2 for sin                C
C spherical harmonics and 1 for cosine ones.                        C
C All the above are integers - no point in a variable list .....    C
C     N = L*L for M = 0, IT = 1                                     C
C     N = L*L + 2*M - 1 for non-zero M and IT = 1                   C
C     N = L*L + 2*M for non-zero M and IT = 2                       C
C If N = 0, we have a monopole: L = 0, M = 0 and IT = 1.            C
C___________________________________________________________________C
C
C********************************************************************
      SUBROUTINE LMFIND ( N, L, M, IT)
      IMPLICIT NONE
C___________________________________________________________________C
C Variable Declarations - Parameters ...............................C
      INTEGER N,L,M,IT
C___________________________________________________________________C
C Variable declarations - Working Variables ........................C
      INTEGER LL,IDIFF,N2,ITWO
      PARAMETER (ITWO=2)
C___________________________________________________________________C
C First put N into N2 so that N is not altered
      N2=N
      IF ( N2.EQ.0 ) THEN
         L=0
         M=0
         IT=1
         RETURN
      ENDIF
      IF ( N2.LT.1 ) THEN 
         WRITE (6,989)
         STOP
 989  FORMAT (' Subroutine LMFIND. N<1 - Program stopped.')
      ENDIF
      IF ( N2.EQ.1 ) THEN
         L=1
         M=0
         IT=1
         RETURN
      ENDIF
      L=1
 500  CONTINUE
      LL=L*L
      IDIFF = N2 - LL
      IF ( IDIFF.GT.0 ) THEN
         L=L+1
         GOTO 500
      ENDIF
      IF ( IDIFF.EQ.0 ) THEN
         M=0
         IT=1
         RETURN
      ENDIF
      L=L-1
      LL=L*L
      N2=N2-LL
C so we know now that N2 is equal to either 2*M or 2*M-1
C corresponding to IT=1 and IT=2 respectively
      IDIFF = MOD ( N2, ITWO )
      IF ( IDIFF.EQ.1) THEN
         IT = 1
         M = (N2+1)/ITWO
      ELSE
         IT = 2
         M = N2/ITWO
      ENDIF
      RETURN
      END
C********************************************************************
C*********************************************************************
C subroutine Inhomogeneous Temperature Function Coefficient Find *****
C            -             -           -        -           -    *****
C Steve Gibbons Mon Jan 17 11:25:35 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C The function f( r ) for ri .le. r .le. ro is defined by            C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C Then clearly,    f( ri )  = CB 2 ( ri-ro )/pi + CC                 C
C                  f'( ri ) = CA 0.5 pi/(ro-ri)                      C
C                                                                    C
C                  f( ro )  = CA                + CC                 C
C                  f'( ro ) = CB                                     C
C                                                                    C
C ITFCF chooses the coefficients CA, CB and CC such that f will      C
C have the desired properties at ri and ro.                          C
C                                                                    C
C Set KIB (KOB) to 1 to fix the temperature at the inner (outer) bnd C
C Set KIB (KOB) to 2 to fix the heat flux at the inner (outer) bnd.  C
C                                                                    C
C VALIB (VALOB) is the actual value which f( r ) or f'( r ) is       C
C to attain at the inner (outer) boundary, depending upon the        C
C setting of KIB (KOB).                                              C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     KIB      : 1 if T( ri ) is to be set to the value VALIB.       C
C                2 if dT/dr( ri ) is to be set to the value VALIB.   C
C                                                                    C
C     KOB      : 1 if T( ro ) is to be set to the value VALOB.       C
C                2 if dT/dr( ro ) is to be set to the value VALOB.   C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RI       : Radius of the inner boundary.                       C
C     RO       : Radius of the outer boundary.                       C
C                                                                    C
C     VALIB    : Value for temp./temp. gradient at inner boundary.   C
C     VALOB    : Value for temp./temp. gradient at outer boundary.   C
C                                                                    C
C     CA       : Coefficient of term in f(r). See above.             C
C     CB       : Coefficient of term in f(r). See above.             C
C     CC       : Coefficient of term in f(r). See above.             C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ITFCF( KIB, KOB, RI, RO, VALIB, VALOB, CA, CB, CC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER KIB, KOB
      DOUBLE PRECISION RI, RO, VALIB, VALOB, CA, CB, CC
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      DOUBLE PRECISION PI, ROMRI, LOW
      PARAMETER ( PI=3.14159265358979312D0, LOW = 1.0d-7 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      ROMRI = RO - RI
      IF ( DABS( ROMRI ).LT.LOW ) THEN
        PRINT *,' Subroutine ITFCF.'
        PRINT *,' RI = ', RI,' RO = ', RO
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . First deal with the case of fixed temperature
C     . at both inner and outer boundaries
C     .
      IF ( KIB.EQ.1 .AND. KOB.EQ.1 ) THEN
        CA = VALOB
        CB = VALIB*PI*(-0.5d0)*ROMRI
        CC = 0.0d0
        RETURN
      ENDIF
C     .
C     . Fixed temperature at inner boundary
C     . Fixed flux at outer boundary
C     .
      IF ( KIB.EQ.1 .AND. KOB.EQ.2 ) THEN
        CA = 0.0d0
        CB = VALOB
        CC = VALIB - CB*2.0d0*(RI-RO)/PI
        RETURN
      ENDIF
C     .
C     . Fixed flux at inner boundary
C     . Fixed temperature at outer boundary
C     .
      IF ( KIB.EQ.2 .AND. KOB.EQ.1 ) THEN
        CA = VALIB*ROMRI*2.0d0/PI
        CB = 0.0d0
        CC = VALOB - CA
        RETURN
      ENDIF
C     .
C     . Fixed flux at inner and outer boundaries
C     .
      IF ( KIB.EQ.2 .AND. KOB.EQ.2 ) THEN
        CA = VALIB*ROMRI*2.0d0/PI
        CB = VALOB
        CC = 0.0d0
        RETURN
      ENDIF
C     .
      PRINT *,' Subroutine ITFCF.'
      PRINT *,' KIB = ', KIB,' KOB = ',KOB
      PRINT *,' Illegal values for KIB and KOB.'
      PRINT *,' Program aborted.'
C     .
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine CouNTeR Increment and Check *****************************
C            -  -- - -             -     *****************************
C Steve Gibbons Mon Jan 10 10:16:42 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Adds 1 to the number IC.                                           C
C If the resulting number is greater than ICMAX then the logical     C
C flag OK is set to .FALSE.                                          C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     IC       : Value of counter variable.                          C
C     ICMAX    : Maximum permitted value of IC.                      C
C                                                                    C
C  Logical                                                           C
C  -------                                                           C
C                                                                    C
C     OK       : Unaltered if IC.le.ICMAX.                           C
C                Set to .FALSE. if IC.gt.ICMAX.                      C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE CNTRIC( IC, ICMAX, OK )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IC, ICMAX
      LOGICAL OK
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      IC = IC + 1
      IF ( IC.GT.ICMAX ) OK = .FALSE.
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Vector Scalar Product Coefficients Calculate ************
C            -      -      -       -            -         ************
C Steve Gibbons Mon Jan 17 18:53:30 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Calculates the coefficients for the non-linear interaction         C
C                                                                    C
C v_{alpha} . Theta_{beta}                                           C
C                                                                    C
C The output takes the form of 5 arrays; IHNALP, IHNBET, IHNGAM,     C
C CVI and TVHI.                                                      C
C                                                                    C
C  IHNALP( in ) and IHNBET( in ) [in = interaction number]           C
C refer to the harmonic number (as defined by the function INDSHC)   C
C of the alpha and beta harmonics respectively.                      C
C                                                                    C
C  If a given reaction forming a third vector harmonic, gamma,       C
C is non-zero then the coefficient C^{abg}_{ABG} is stored in        C
C CVI( in ) [Coefficient of Vector Interaction].                     C
C  IHNGAM( in ) is the number defined by INDSHC for this gamma.      C
C                                                                    C
C  The corresponding element of TVHI [Type of Vector Harmonic        C
C Interaction] is given as 'SPAB' where each of A and B is           C
C replaced by Q, S or T depending upon the nature of the vector      C
C harmonics.                                                         C
C                                                                    C
C  The explicit formulae for the interactions 'SPAB' is given by     C
C the equations (B.39) through to (B.41) on page 188 of my thesis.   C
C                                                                    C
C NVI is the Number of Vector Interactions and, as an input          C
C parameter, indicates how many elements are already stored in the   C
C five arrays. (NVI=0 means that no such routine has yet been        C
C called; NVI .gt. 0 means that the coefficients found by this       C
C routine will begin at NVI + 1).                                    C
C                                                                    C
C MAXNVI is the maximum permitted number of vector interactions.     C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     MAXNVI   : Maximum number of vector interactions.              C
C                This is an upper limit for NVI and the dimension    C
C                of the arrays IHNALP, IHNBET, IHNGAM, CVI and       C
C                TVHI.                                               C
C                                                                    C
C     IHNALP   : Number of alpha harmonics. Dim ( MAXNVI )           C
C     IHNBET   : Number of beta harmonics. Dim ( MAXNVI )            C
C     IHNGAM   : Number of gamma harmonics. Dim ( MAXNVI )           C
C                                                                    C
C   [Key for MTA, MTB, MTG :- 1 = poloidal velocity, 2 = toroidal    C
C  velocity: 3, 4 and 5 are temp, pol mag. field and tor mag. f.]    C
C                                                                    C
C     NHA      : Number of alpha harmonics.                          C
C     MTA      : Array length ( * ) - atleast length NHA             C
C                  See above for key. (corresponds to alpha vec.)    C
C     MLA      : Array length ( * ) - atleast length NHA             C
C                  Sph. harm. degree, l.                             C
C     MMA      : Array length ( * ) - atleast length NHA             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     NHB      : Number of beta harmonics.                           C
C     MTB      : Array length ( * ) - atleast length NHB             C
C                  See above for key. (corresponds to beta vector)   C
C     MLB      : Array length ( * ) - atleast length NHB             C
C                  Sph. harm. degree, l.                             C
C     MMB      : Array length ( * ) - atleast length NHB             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     NHG      : Number of gamma harmonics.                          C
C     MTG      : Array length ( * ) - atleast length NHG             C
C                  See above for key. (corresponds to gamma vec.)    C
C     MLG      : Array length ( * ) - atleast length NHG             C
C                  Sph. harm. degree, l.                             C
C     MMG      : Array length ( * ) - atleast length NHG             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     LH        : Maximum spherical harmonic degree, l.              C
C     NTHP      : The number of theta points.                        C
C     NPHP      : The number of phi points.                          C
C     MMAX      : Maximum sph. harmonic order, m.                    C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. (MAXNVI).    C
C                 = 'CQSS', 'CQST' etc. according to the corresp.    C
C                 vector interaction.                                C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     CVI       : Coefficient of vector interaction. Dim ( MAXNVI )  C
C     GAUX      : Cosines of the NTHP evaluated by the routine       C
C                  gauwts. Dimension ( NTHP ).                       C
C     GAUW      : Corresponding weights. As above.                   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2, NTHP )       C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C     FF1       : Work array - dim. (2*NPHP)                         C
C     VF1       : Work array - dim. ( NPHP, NTHP, 3)                 C
C     VF2       : Work array - dim. ( NPHP, NTHP, 3)                 C
C     SF        : Work array - dim. ( NPHP, NTHP )                   C
C     SHC       : Work array - dim. ( LH * ( LH + 2 ) )              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VSPCC( NVI, MAXNVI, IHNALP, IHNBET, IHNGAM, NHA,
     1    MTA, MLA, MMA, NHB, MTB, MLB, MMB, NHG, MTG, MLG, MMG,
     2    LH, NTHP, NPHP, MMAX, TVHI, CVI, GAUX, GAUW, PA, DPA,
     3    FF1, VF1, VF2, SF, SHC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NVI, MAXNVI, IHNALP( MAXNVI ), IHNBET( MAXNVI ),
     1        IHNGAM( MAXNVI ), NHA, MTA( * ), MLA( * ), MMA( * ),
     2        NHB, MTB( * ), MLB( * ), MMB( * ), NHG, MTG( * ),
     3        MLG( * ), MMG( * ), LH, NTHP, NPHP, MMAX
      CHARACTER *(4) TVHI( MAXNVI )
      DOUBLE PRECISION CVI( MAXNVI ), GAUX( NTHP ), GAUW( NTHP )
      DOUBLE PRECISION PA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     1                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     2                 FF1( 2*NPHP )
      DOUBLE PRECISION VF1( NPHP, NTHP, 3), VF2( NPHP, NTHP, 3),
     1                 SF( NPHP, NTHP ), SHC( LH*( LH + 2) )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHA, IHB, IHG, LA, LB, LG, MA, MB, MG, ICSA, ICSB,
     1        ICSG, IQSTA, IQSTB, INDA, INDB, INDG, INDSHC
C     .
      LOGICAL OK
      DOUBLE PRECISION ZCOEF, LOW, SQQ, SSS, STS
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      OK = .TRUE.
C     .
C     . IHA is the 'alpha' harmonic.
C     . This is the velocity.
C     .
      DO IHA = 1, NHA
C       .
C       . Go onto next alpha harmonic if it is not a velocity term
C       .
        IF ( MTA( IHA ).NE.1 .AND. MTA( IHA ).NE.2 ) GOTO 50
C       .
C       . Consider the case of alpha poloidal
C       .
        IF ( MTA( IHA ).EQ.1 ) THEN
          LA = MLA( IHA )
          IF ( MMA( IHA ).LT.0 ) THEN
            MA   = -MMA( IHA )
            ICSA = 2
          ELSE
            MA   = MMA( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
C         . Now evaluate q_{alpha} in VF1
C         .
          IQSTA = 1
C         .
          CALL SHVECT ( LA, MA, ICSA, IQSTA, VF1, GAUX, PA, DPA,
     1                  NTHP, NPHP, LH )
C         .
C         . Now loop IHB around harmonics in solution
C         . vector and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MTB( IHB ).NE.3 ) GOTO 51
C           .
C           . Calculate indices of temperature harm. beta
C           .
            LB = MLB( IHB )
            IF ( MMB( IHB ).LT.0 ) THEN
              MB   = -MMB( IHB )
              ICSB = 2
            ELSE
              MB   = MMB( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
C           . Evaluate q_{beta} in VF2
C           .
            IQSTB = 1
C           .
            CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX, PA, DPA,
     1                    NTHP, NPHP, LH )
C           .
C           . Calculate scalar product in SF
C           .
            CALL VFDP ( VF1, VF2, SF, NPHP, NTHP )
C           .
C           . Now transform this function into scalar
C           . spherical harmonic coefficients
C           .
            CALL FORSST ( SHC, SF, GAUW, PA, FF1, LH, MMAX,
     1                    NTHP, NPHP, ZCOEF )
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTG( IHG ).NE.3 ) GOTO 52
C             .
              LG = MLG( IHG )
              IF ( MMG( IHG ).LT.0 ) THEN
                MG   = -MMG( IHG )
                ICSG = 2
              ELSE
                MG   = MMG( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              IF ( INDG.EQ.0 ) THEN
                SQQ = ZCOEF
              ELSE
                SQQ = SHC( INDG )
              ENDIF
C             .
              IF ( DABS( SQQ ).LT.LOW ) GOTO 52
C             .
C             . OK - we have an S^{abg}_{qq} interaction
C             .
              CALL CNTRIC( NVI, MAXNVI, OK )
              IF ( OK ) THEN
                IHNALP( NVI ) = INDA
                IHNBET( NVI ) = INDB
                IHNGAM( NVI ) = INDG
                CVI( NVI )    = SQQ
                TVHI( NVI )   = 'SPQQ'
              ENDIF
C             .
 52         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 52)
C           (if dabs( sqq ).lt.low ) goto 52)
            ENDDO
C           .
 51       CONTINUE
C         (if mti( ihb ).ne.3 ) goto 51)
          ENDDO
C         .
C         . Now evaluate s_{alpha} in VF1
C         .
          IQSTA = 2
C         .
          CALL SHVECT ( LA, MA, ICSA, IQSTA, VF1, GAUX, PA, DPA,
     1                  NTHP, NPHP, LH )
C         .
C         . Now loop IHB around harmonics in solution
C         . vector and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MTB( IHB ).NE.3 ) GOTO 53
C           .
C           . Also go on to next harmonic if this is the
C           . monopole. This is because we will evaluate
C           . s_{beta} in VF2 which is ofcourse zero for
C           . l = 0.
C           .
            LB = MLB( IHB )
            IF ( LB.EQ.0 ) GOTO 53
C           .
C           . Calculate indices of temperature harm. beta
C           .
            IF ( MMB( IHB ).LT.0 ) THEN
              MB   = -MMB( IHB )
              ICSB = 2
            ELSE
              MB   = MMB( IHB )
              ICSB = 1
            ENDIF
C           .
            INDB   = INDSHC( LB, MB, ICSB )
C           .
C           . Evaluate s_{beta} in VF2
C           .
            IQSTB = 2
C           .
            CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX, PA, DPA,
     1                    NTHP, NPHP, LH )
C           .
C           . Calculate scalar product in SF
C           .
            CALL VFDP ( VF1, VF2, SF, NPHP, NTHP )
C           .
C           . Now transform this function into scalar
C           . spherical harmonic coefficients
C           .
            CALL FORSST ( SHC, SF, GAUW, PA, FF1, LH, MMAX,
     1                    NTHP, NPHP, ZCOEF )
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTG( IHG ).NE.3 ) GOTO 54
C             .
              LG = MLG( IHG )
              IF ( MMG( IHG ).LT.0 ) THEN
                MG   = -MMG( IHG )
                ICSG = 2
              ELSE
                MG   = MMG( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              IF ( INDG.EQ.0 ) THEN
                SSS = ZCOEF
              ELSE
                SSS = SHC( INDG )
              ENDIF
C             .
              IF ( DABS( SSS ).LT.LOW ) GOTO 54
C             .
C             . OK - we have an S^{abg}_{ss} interaction
C             .
              CALL CNTRIC( NVI, MAXNVI, OK )
              IF ( OK ) THEN
                IHNALP( NVI ) = INDA
                IHNBET( NVI ) = INDB
                IHNGAM( NVI ) = INDG
                CVI( NVI )    = SSS
                TVHI( NVI )   = 'SPSS'
              ENDIF
C             .
 54         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 54)
C           (if dabs( sss ).lt.low ) goto 54)
            ENDDO
C           .
 53       CONTINUE
C         (if mti( ihb ).ne.3 ) goto 53)
C         (if lb.eq.0 ) goto 53)
          ENDDO
C         .
        ENDIF
C       .
C       . Consider the case of alpha toroidal
C       .
        IF ( MTA( IHA ).EQ.2 ) THEN
          LA = MLA( IHA )
          IF ( MMA( IHA ).LT.0 ) THEN
            MA   = -MMA( IHA )
            ICSA = 2
          ELSE
            MA   = MMA( IHA )
            ICSA = 1
          ENDIF
C         .
          INDA   = INDSHC( LA, MA, ICSA )
C         .
C         . Now evaluate t_{alpha} in VF1
C         .
          IQSTA = 3
C         .
          CALL SHVECT ( LA, MA, ICSA, IQSTA, VF1, GAUX, PA, DPA,
     1                  NTHP, NPHP, LH )
C         .
C         . Now loop IHB around harmonics in solution
C         . vector and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MTB( IHB ).NE.3 ) GOTO 55
C           .
C           . Also go on to next harmonic if this is the
C           . monopole. This is because we will evaluate
C           . s_{beta} in VF2 which is ofcourse zero for
C           . l = 0.
C           .
            LB = MLB( IHB )
            IF ( LB.EQ.0 ) GOTO 55
C           .
C           . Calculate indices of temperature harm. beta
C           .
            IF ( MMB( IHB ).LT.0 ) THEN
              MB   = -MMB( IHB )
              ICSB = 2
            ELSE
              MB   = MMB( IHB )
              ICSB = 1
            ENDIF
C           .
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IQSTB = 2
C           .
            CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX, PA, DPA,
     1                    NTHP, NPHP, LH )
C           .
C           . Calculate scalar product in SF
C           .
            CALL VFDP ( VF1, VF2, SF, NPHP, NTHP )
C           .
C           . Now transform this function into scalar
C           . spherical harmonic coefficients
C           .
            CALL FORSST ( SHC, SF, GAUW, PA, FF1, LH, MMAX,
     1                    NTHP, NPHP, ZCOEF )
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTG( IHG ).NE.3 ) GOTO 56
C             .
              LG = MLG( IHG )
              IF ( MMG( IHG ).LT.0 ) THEN
                MG   = -MMG( IHG )
                ICSG = 2
              ELSE
                MG   = MMG( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              IF ( INDG.EQ.0 ) THEN
                STS = ZCOEF
              ELSE
                STS = SHC( INDG )
              ENDIF
C             .
              IF ( DABS( STS ).LT.LOW ) GOTO 56
C             .
C             . OK - we have an S^{abg}_{ts} interaction
C             .
              CALL CNTRIC( NVI, MAXNVI, OK )
              IF ( OK ) THEN
                IHNALP( NVI ) = INDA
                IHNBET( NVI ) = INDB
                IHNGAM( NVI ) = INDG
                CVI( NVI )    = STS
                TVHI( NVI )   = 'SPTS'
              ENDIF
C             .
 56         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 56)
C           (if dabs( sts ).lt.low ) goto 56)
            ENDDO
C           .
 55       CONTINUE
C         (if mti( ihb ).ne.3 ) goto 55)
C         (if lb.eq.0 ) goto 55)
          ENDDO
C         .
        ENDIF
C       .
 50   CONTINUE
C     ( if mt0( iha ).ne.1 .and. mt0( iha ).ne.2 ) goto 50 )
      ENDDO
C     .
      IF ( OK ) RETURN
      PRINT *,' Subroutine VSPCC.'
      PRINT *,' Number of required interactions = ', NVI
      PRINT *,' Maximum interactions allowed    = ', MAXNVI
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Vector Curl Cross Product Coefficients Calculate ********
C            -      -    -     -       -            -         ********
C Steve Gibbons Tue Nov 23 07:51:01 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Calculates the coefficients for the non-linear interaction         C
C                                                                    C
C curl( v_{alpha}  x  [ curl v_{beta} ]  )                           C
C                                                                    C
C The output takes the form of 5 arrays; IHNALP, IHNBET, IHNGAM,     C
C CVI and TVHI.                                                      C
C                                                                    C
C  IHNALP( in ) and IHNBET( in ) [in = interaction number]           C
C refer to the harmonic number (as defined by the function INDSHC)   C
C of the alpha and beta harmonics respectively.                      C
C                                                                    C
C  If a given reaction forming a third vector harmonic, gamma,       C
C is non-zero then the coefficient C^{abg}_{ABG} is stored in        C
C CVI( in ) [Coefficient of Vector Interaction].                     C
C  IHNGAM( in ) is the number defined by INDSHC for this gamma.      C
C                                                                    C
C  The corresponding element of TVHI [Type of Vector Harmonic        C
C Interaction] is given as 'CABG' where each of A, B and G is        C
C replaced by Q, S or T depending upon the nature of the vector      C
C harmonics.                                                         C
C                                                                    C
C  The explicit formulae for the interactions 'CABG' is given by     C
C the equations (B.45) through to (B.50) on page 188 of my thesis.   C
C                                                                    C
C NVI is the Number of Vector Interactions and, as an input          C
C parameter, indicates how many elements are already stored in the   C
C five arrays. (NVI=0 means that no such routine has yet been        C
C called; NVI .gt. 0 means that the coefficients found by this       C
C routine will begin at NVI + 1).                                    C
C                                                                    C
C MAXNVI is the maximum permitted number of vector interactions.     C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     MAXNVI   : Maximum number of vector interactions.              C
C                This is an upper limit for NVI and the dimension    C
C                of the arrays IHNALP, IHNBET, IHNGAM, CVI and       C
C                TVHI.                                               C
C                                                                    C
C     IHNALP   : Number of alpha harmonics. Dim ( MAXNVI )           C
C     IHNBET   : Number of beta harmonics. Dim ( MAXNVI )            C
C     IHNGAM   : Number of gamma harmonics. Dim ( MAXNVI )           C
C                                                                    C
C   [Key for MTA, MTB, MTG :- 1 = poloidal velocity, 2 = toroidal    C
C  velocity: 3, 4 and 5 are temp, pol mag. field and tor mag. f.     C
C  respectively but are not relevant to this routine.]               C
C                                                                    C
C     NHA      : Number of alpha harmonics.                          C
C     MTA      : Array length ( * ) - atleast length NHA             C
C                  See above for key. (corresponds to alpha vec.)    C
C     MLA      : Array length ( * ) - atleast length NHA             C
C                  Sph. harm. degree, l.                             C
C     MMA      : Array length ( * ) - atleast length NHA             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     NHB      : Number of beta harmonics.                           C
C     MTB      : Array length ( * ) - atleast length NHB             C
C                  See above for key. (corresponds to beta vector)   C
C     MLB      : Array length ( * ) - atleast length NHB             C
C                  Sph. harm. degree, l.                             C
C     MMB      : Array length ( * ) - atleast length NHB             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     NHG      : Number of gamma harmonics.                          C
C     MTG      : Array length ( * ) - atleast length NHG             C
C                  See above for key. (corresponds to gamma vec.)    C
C     MLG      : Array length ( * ) - atleast length NHG             C
C                  Sph. harm. degree, l.                             C
C     MMG      : Array length ( * ) - atleast length NHG             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     LH        : Maximum spherical harmonic degree, l.              C
C     NTHP      : The number of theta points.                        C
C     NPHP      : The number of phi points.                          C
C     MMAX      : Maximum sph. harmonic order, m.                    C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. (MAXNVI).    C
C                 = 'CQSS', 'CQST' etc. according to the corresp.    C
C                 vector interaction.                                C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     CVI       : Coefficient of vector interaction. Dim ( MAXNVI )  C
C                                                                    C
C     GAUX      : Cosines of the NTHP evaluated by the routine       C
C                  gauwts. Dimension ( NTHP ).                       C
C     GAUW      : Corresponding weights. As above.                   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2, NTHP )       C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C     FF1       : Work array - dim. (2*NPHP)                         C
C     FF2       : Work array - dim. (2*NPHP)                         C
C     FF3       : Work array - dim. (2*NPHP)                         C
C     VF1       : Work array - dim. ( NPHP, NTHP, 3)                 C
C     VF2       : Work array - dim. ( NPHP, NTHP, 3)                 C
C     VF3       : Work array - dim. ( NPHP, NTHP, 3)                 C
C     QST       : Work array - dim. ( LH*(LH+2) , 3)                 C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VCCPCC( NVI, MAXNVI, IHNALP, IHNBET, IHNGAM, NHA, 
     1    MTA, MLA, MMA, NHB, MTB, MLB, MMB, NHG, MTG, MLG, MMG, 
     2    LH, NTHP, NPHP, MMAX, TVHI, CVI, GAUX, GAUW, PA, DPA,
     3    FF1, FF2, FF3, VF1, VF2, VF3, QST )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NVI, MAXNVI, IHNALP( MAXNVI ), IHNBET( MAXNVI ),
     1        IHNGAM( MAXNVI ), NHA, MTA( * ), MLA( * ), MMA( * ),
     2        NHB, MTB( * ), MLB( * ), MMB( * ), NHG, MTG( * ),
     3        MLG( * ), MMG( * ), LH, NTHP, NPHP, MMAX
      CHARACTER *(4) TVHI( MAXNVI )
      DOUBLE PRECISION CVI( MAXNVI ), GAUX( NTHP ), GAUW( NTHP )
      DOUBLE PRECISION PA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     1                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     2                 FF1( 2*NPHP ), FF2( 2*NPHP ), FF3( 2*NPHP )
      DOUBLE PRECISION VF1( NPHP, NTHP, 3), VF2( NPHP, NTHP, 3),
     1                 VF3( NPHP, NTHP, 3 ), QST( LH*( LH + 2), 3 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHA, IHB, IHG, LA, LB, LG, MA, MB, MG, ICSA, ICSB,
     1        ICSG, IQSTA, IQSTB, INDA, INDB, INDG, INDSHC
C     .
      DOUBLE PRECISION ZCOEF, LOW, 
     1                 CQTS, CQTT, CQSS, CQST, CSTQ, CSQS,
     2                 CSQT, CSSQ, CTTQ, CTQS, CTQT, CTSQ
      PARAMETER ( LOW = 1.0d-9 )
      LOGICAL OK
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      OK = .TRUE.
C     .
C     . Check that NVI is valid.
C     .
      IF ( NVI.LT.0 .OR. NVI.GT.MAXNVI ) THEN
        PRINT *,' Subroutine VCCPCC.'
        PRINT *,' NVI = ', NVI,' MAXNVI = ', MAXNVI 
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . IHA is the 'alpha' harmonic.
C     . This is the velocity.
C     . vector and so loop around IHA from 1 to NHA
C     .
      DO IHA = 1, NHA
C       .
C       . Consider the case of alpha poloidal
C       .
        IF ( MTA( IHA ).EQ.1 ) THEN
          LA = MLA( IHA )
          IF ( MMA( IHA ).LT.0 ) THEN
            MA   = -MMA( IHA )
            ICSA = 2
          ELSE
            MA   = MMA( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
C         . Now evaluate q_{alpha} in VF1
C         .
          IQSTA = 1
C         .
          CALL SHVECT ( LA, MA, ICSA, IQSTA, VF1, GAUX, PA, DPA,
     1                  NTHP, NPHP, LH )
C         .
C         . Now loop IHB around beta harmonics
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MTB( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLB( IHB )
              IF ( MMB( IHB ).LT.0 ) THEN
                MB   = -MMB( IHB )
                ICSB = 2
              ELSE
                MB   = MMB( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
C             . Evaluate t_{beta} in VF2
C             .
              IQSTB = 3
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{qts}^{abg} in comp. 2
C             . QST now contains C_{qtt}^{abg} in comp. 3
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CQTS   = QST( INDG, 2 )
                IF ( INDG.GT.0 ) CQTT   = QST( INDG, 3 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{qts}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CQTS ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CQTS
                    TVHI( NVI )   = 'CQTS'
                  ENDIF
C                 .
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{qtt}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.1 .AND. DABS( CQTT ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CQTT
                    TVHI( NVI )   = 'CQTT'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           .
C           . Case of beta toroidal
C           .
            IF ( MTB( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLB( IHB )
              IF ( MMB( IHB ).LT.0 ) THEN
                MB   = -MMB( IHB )
                ICSB = 2
              ELSE
                MB   = MMB( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
C             . Evaluate s_{beta} in VF2
C             . (No need to evaluate q_{beta}
C             . - there is no Q x Q )
C             .
              IQSTB = 2
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{qss}^{abg} in comp. 2
C             . QST now contains C_{qst}^{abg} in comp. 3
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CQSS   = QST( INDG, 2 )
                IF ( INDG.GT.0 ) CQST   = QST( INDG, 3 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{qss}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CQSS ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CQSS
                    TVHI( NVI )   = 'CQSS'
                  ENDIF
C                 .
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{qst}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.1 .AND. DABS( CQST ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CQST
                    TVHI( NVI )   = 'CQST'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end ihb = 1, nhb)
C         .
C         . Now evaluate s_{alpha} in VF1
C         .
          IQSTA = 2
C         .
          CALL SHVECT ( LA, MA, ICSA, IQSTA, VF1, GAUX, PA, DPA,
     1                  NTHP, NPHP, LH )
C         .
C         . Now loop IHB around beta harmonics
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MTB( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLB( IHB )
              IF ( MMB( IHB ).LT.0 ) THEN
                MB   = -MMB( IHB )
                ICSB = 2
              ELSE
                MB   = MMB( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
C             . Evaluate t_{beta} in VF2
C             .
              IQSTB = 3
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{stq}^{abg} in comp. 1
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CSTQ   = QST( INDG, 1 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{stq}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CSTQ ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CSTQ
                    TVHI( NVI )   = 'CSTQ'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           . Case of beta toroidal
C           .
            IF ( MTB( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLB( IHB )
              IF ( MMB( IHB ).LT.0 ) THEN
                MB   = -MMB( IHB )
                ICSB = 2
              ELSE
                MB   = MMB( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
C             . Evaluate q_{beta} in VF2
C             .
              IQSTB = 1
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{sqs}^{abg} in comp. 2
C             . QST now contains C_{sqt}^{abg} in comp. 3
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CSQS   = QST( INDG, 2 )
                IF ( INDG.GT.0 ) CSQT   = QST( INDG, 3 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{sqs}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CSQS ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CSQS
                    TVHI( NVI )   = 'CSQS'
                  ENDIF
C                 .
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{sqt}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.1 .AND. DABS( CSQT ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CSQT
                    TVHI( NVI )   = 'CSQT'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
C             . Evaluate s_{beta} in VF2
C             .
              IQSTB = 2
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{ssq}^{abg} in comp. 1
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CSSQ   = QST( INDG, 1 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{ssq}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CSSQ ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CSSQ
                    TVHI( NVI )   = 'CSSQ'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end loop ihb = 1, nhb)
C         .
        ENDIF
C       .
C       . Consider the case of alpha toroidal
C       .
        IF ( MTA( IHA ).EQ.2 ) THEN
          LA = MLA( IHA )
          IF ( MMA( IHA ).LT.0 ) THEN
            MA   = -MMA( IHA )
            ICSA = 2
          ELSE
            MA   = MMA( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
C         . Now evaluate t_{alpha} in VF1
C         .
          IQSTA = 3
C         .
          CALL SHVECT ( LA, MA, ICSA, IQSTA, VF1, GAUX, PA, DPA,
     1                  NTHP, NPHP, LH )
C         .
C         . Now loop IHB around beta harmonics
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MTB( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLB( IHB )
              IF ( MMB( IHB ).LT.0 ) THEN
                MB   = -MMB( IHB )
                ICSB = 2
              ELSE
                MB   = MMB( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
C             . Evaluate t_{beta} in VF2
C             .
              IQSTB = 3
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{ttq}^{abg} in comp. 1
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CTTQ   = QST( INDG, 1 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{ttq}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CTTQ ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CTTQ
                    TVHI( NVI )   = 'CTTQ'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           .
C           . Case of beta toroidal
C           .
            IF ( MTB( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLB( IHB )
              IF ( MMB( IHB ).LT.0 ) THEN
                MB   = -MMB( IHB )
                ICSB = 2
              ELSE
                MB   = MMB( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
C             . Evaluate q_{beta} in VF2
C             .
              IQSTB = 1
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{tqs}^{abg} in comp. 2
C             . QST now contains C_{tqt}^{abg} in comp. 3
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CTQS   = QST( INDG, 2 )
                IF ( INDG.GT.0 ) CTQT   = QST( INDG, 3 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{tqs}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CTQS ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CTQS
                    TVHI( NVI )   = 'CTQS'
                  ENDIF
C                 .
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{tqt}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.1 .AND. DABS( CTQT ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CTQT
                    TVHI( NVI )   = 'CTQT'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
C             .
C             . Evaluate s_{beta} in VF2
C             .
              IQSTB = 2
C             .
              CALL SHVECT ( LB, MB, ICSB, IQSTB, VF2, GAUX,
     1                      PA, DPA, NTHP, NPHP, LH )
C             .
C             . Calculate VF3 = VF1 x VF2
C             .
              CALL VFCP ( VF1, VF2, VF3, NPHP, NTHP )
C             .
C             . Transform back into QST coefficients
C             .
              CALL VF2QST( QST, VF3, GAUX, GAUW, PA, DPA, FF1, FF2,
     1                    FF3, ZCOEF, LH, NTHP, NPHP, MMAX )
C             .
C             . QST now contains C_{tsq}^{abg} in comp. 1
C             .
C             . Loop around gamma harmonics
C             .
              DO IHG = 1, NHG
                LG = MLG( IHG )
                IF ( MMG( IHG ).LT.0 ) THEN
                  MG   = -MMG( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMG( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
                IF ( INDG.GT.0 ) CTSQ   = QST( INDG, 1 )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{tsq}^{abg} interaction
C               .
                IF ( MTG( IHG ).EQ.2 .AND. DABS( CTSQ ).GT.LOW ) THEN
C                 .
                  CALL CNTRIC( NVI, MAXNVI, OK )
                  IF ( OK ) THEN
                    IHNALP( NVI ) = INDA
                    IHNBET( NVI ) = INDB
                    IHNGAM( NVI ) = INDG
                    CVI( NVI )    = CTSQ
                    TVHI( NVI )   = 'CTSQ'
                  ENDIF
C                 .
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end ihb = 1, nhb)
C         .
        ENDIF
C       .
      ENDDO
C     (end loop iha = 1, nha)
      IF ( OK ) RETURN
      PRINT *,' Subroutine VCCPCC.'
      PRINT *,' Number of required interactions = ', NVI
      PRINT *,' Maximum interactions allowed    = ', MAXNVI
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Complete Adapted Solution Vector Derivative Routine *****
C            -        -       -        -      -          -       *****
C Steve Gibbons Sat Feb  5 08:34:24 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Loops around the entire convection vector and calculates           C
C derivatives 0 and up to 4 of every harmonic from grid node         C
C IR = ILN to grid node IRN.                                         C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     ILN       : Left-most node to be acted upon.                   C
C     IRN       : Right-most node to be acted upon.                  C
C     NBN       : Number of bounding nodes. See above.               C
C     IHD       : Highest derivative requested.                      C
C     NCFM      : Leading dimension of SVFDC. At least (2*NBN+1)     C
C     NR        : Number of radial grid nodes in each function.      C
C     NDRVS     : Number of highest derivative for which             C
C                  coefficients are stored by the array SVFDC.       C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C     INARR     : Integer array dimension ( * ).                     C
C                  Elements may be arbitrary except for              C
C                  INARR( 1 ) = IFORMF - flag for vector format.     C
C                                        See INDFUN                  C
C                  INARR( 2 ) = NRR. Must be consistent with NR.     C
C                  INARR( 3 ) = NH = total number of radial func.s   C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     MHP       : Pointer array for harmonics. If HMP( ih ) = is     C
C                  then 'is' is the finite difference scheme used    C
C                   to take derivatives of that harm. radial func.   C
C                   If MHP is negative, the harmonic is avoided and  C
C                   CASVDR moves on to the next harmonic.            C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     V         : Solution vector. Dim ( * ) but length atleast      C
C                  NR*NH.                                            C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NCFM, NR, NDRVM+1, NDCS ).            C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C     V0        : Zero^th derivatives. Dim ( * ) but length atleast  C
C     V1        : First   derivatives. Dim ( * ) but length atleast  C
C     V2        : Second  derivatives. Dim ( * ) but length atleast  C
C     V3        : Third   derivatives. Dim ( * ) but length atleast  C
C     V4        : Fourth  derivatives. Dim ( * ) but length atleast  C
C                                                                    C
C IMPORTANT: ALL of V0, V1, V2, V3 and V4 are filled even if         C
C these derivatives are not requested!                               C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE CASVDR ( V, ILN, IRN, NBN, IHD, NCFM, NR, NDRVS,
     1                    NDRVM, INARR, NDCS, MHP, SVFDC, V0, V1,
     2                    V2, V3, V4 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NBN, IHD, NCFM, NR, NDRVS, NDRVM, INARR( * ), NDCS,
     1        MHP( * ), ILN, IRN
      DOUBLE PRECISION V( * ), V0( * ), V1( * ), V2( * ), V3( * ), 
     1                 V4( * ), SVFDC( NCFM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      DOUBLE PRECISION DERV( 5 )
      INTEGER IR, IH, NH, IND, INDFUN, IS, I
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      DO I = 1, 5
        DERV( I ) = 0.0d0
      ENDDO
C
      IF ( IHD.LT.0 .OR. IHD.GT.4 ) THEN
        PRINT *,' Subroutine CASVDR. IHD = ', IHD
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      NH = INARR( 3 )
      DO IH = 1, NH
        IS  = MHP( IH )
        IF ( IS.LT.1 ) GOTO 60
        DO IR = ILN, IRN
C         .
          IND = INDFUN( IR, IH, INARR )
          CALL ASVDR ( V, IR, IS, IH, NBN, IHD, NCFM, NR, NDRVS,
     1                   NDRVM, DERV, INARR, SVFDC, NDCS )
C         .
          V0( IND ) = DERV( 1 )
          V1( IND ) = DERV( 2 )
          V2( IND ) = DERV( 3 )
          V3( IND ) = DERV( 4 )
          V4( IND ) = DERV( 5 )
C         .
        ENDDO
 60   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Inhomogeneous Boundary Temp. Deriv.s Vector Addition. ***
C            -             -        -     -       -      -         ***
C Steve Gibbons Sat Feb  5 09:20:32 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C If V0, V1, V2, V3 and V4 are all the derivative vectors output     C
C by CASVDR (from the homogeneous temperature functions), then       C
C IBTDVA will add on to these values the contributions from the      C
C inhomogeneous temperatures.                                        C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C The function f( r ) for ri .le. r .le. ro is defined by            C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     ILN       : Left-most node to be acted upon.                   C
C                                                                    C
C     IRN       : Right-most node to be acted upon.                  C
C                                                                    C
C     IHD       : Highest derivative requested.                      C
C                                                                    C
C     INARR     : Integer array dimension ( * ).                     C
C                  Elements may be arbitrary except for              C
C                  INARR( 1 ) = IFORMF - flag for vector format.     C
C                                        See INDFUN                  C
C                  INARR( 2 ) = NR. Number of radial grid nodes.     C
C                  INARR( 3 ) = NH = total number of radial func.s   C
C                                                                    C
C     MHT       : Type array. MHT( ih ) = 3 --> temperature harm.    C
C                                                                    C
C     MHI      : Dim ( * ) - atleast atleast length NHI.             C
C                For each temperature harmonic, IHI, MHI(IHI) gives  C
C                the index of the array CAFIT which stores the       C
C                coefficients for that radial function.              C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C                If MHI( IH ) = IITH, then CA, CB and CC are         C
C                respectively stored in CAFIT( 1, IITH ),            C
C                CAFIT( 2, IITH ) and CAFIT( 3, IITH ).              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     XARR      : Dim ( NR ). Radial values.                         C
C                                                                    C
C     CAFIT     : Dimension ( 3, * ). See MHI.                       C
C                                                                    C
C     V0        : Zero^th derivatives. Dim ( * ) but length atleast  C
C     V1        : First   derivatives. Dim ( * ) but length atleast  C
C     V2        : Second  derivatives. Dim ( * ) but length atleast  C
C     V3        : Third   derivatives. Dim ( * ) but length atleast  C
C     V4        : Fourth  derivatives. Dim ( * ) but length atleast  C
C                                                                    C
C IMPORTANT: ALL of V0, V1, V2, V3 and V4 are filled even if         C
C these derivatives are not requested!                               C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE IBTDVA( ILN, IRN, IHD, INARR, MHT, MHI, XARR,
     1                   CAFIT, V0, V1, V2, V3, V4 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER ILN, IRN, IHD, INARR( * ), MHT( * ), MHI( * )
      DOUBLE PRECISION XARR( * ), CAFIT( 3, * ), V0( * ),
     1                 V1( * ), V2( * ), V3( * ), V4( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NR, NH, IH, IR, I, IITH, IND, INDFUN
      DOUBLE PRECISION RAD, RI, RO, CA, CB, CC, DERV( 5 ), DLOW
      PARAMETER ( DLOW = 1.0d-10 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NR = INARR( 2 )
      NH = INARR( 3 )
C
      RI = XARR(  1 )
      RO = XARR( NR )
C
      IF ( IHD.LT.0 .OR. IHD.GT.4 ) THEN
        PRINT *,' Subroutine IBTDVA. IHD = ', IHD
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      DO IH = 1, NH
        IF ( MHT( IH ).NE.3 ) GOTO 60
        IITH   = MHI( IH )
        CA     = CAFIT( 1, IITH )
        CB     = CAFIT( 2, IITH )
        CC     = CAFIT( 3, IITH )
        IF ( DABS( CA ).LT.DLOW .AND. DABS( CB ).LT.DLOW .AND.
     1       DABS( CC ).LT.DLOW ) GOTO 60
        DO IR = ILN, IRN
          RAD = XARR( IR )
C         .
          IND = INDFUN( IR, IH, INARR )
          DO I = 1, 5
            DERV( I ) = 0.0d0
          ENDDO
C
          CALL ITFA( RAD, RI, RO, CA, CB, CC, DERV, IHD )
C         .
          V0( IND ) = V0( IND ) + DERV( 1 )
          V1( IND ) = V1( IND ) + DERV( 2 )
          V2( IND ) = V2( IND ) + DERV( 3 )
          V3( IND ) = V3( IND ) + DERV( 4 )
          V4( IND ) = V4( IND ) + DERV( 5 )
C         .
        ENDDO
 60   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Stored derivative Solution Vector Laplcian and Curl *****
C            -                 -        -      -            -    *****
C Steve Gibbons Tue Oct 26 12:09:14 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds a multiple of FAC* the curl of all Laplacian of all the       C
C velocity harmonics of the vector VI0 to the appropriate elements   C
C of the solution vector, VO.                                        C
C The first, second, third and fourth derivatives (precalculated by  C
C CASVDR) are stored in VI1, VI2, VI3 and VI4.                       C
C                                                                    C
C Now MHTI defines what each scalar function in a solution vector    C
C represents.                                                        C
C                                                                    C
C         MHTI( IH ) = 1 --> harmonic is poloidal velocity           C
C         MHTI( IH ) = 2 --> harmonic is toroidal velocity           C
C         MHTI( IH ) = 3 --> harmonic is temperature.                C
C         MHTI( IH ) = 4 --> harmonic is poloidal magnetic field     C
C         MHTI( IH ) = 5 --> harmonic is toroidal magnetic field     C
C                                                                    C
C and similarly MHTO for the resulting vector.                       C
C                                                                    C
C Taking the curl of a Laplacian of a toroidal harmonic with         C
C radial function x(r) results in a poloidal harmonic with scalar    C
C function D_l x(r).                                                 C
C                                                                    C
C Taking the curl of a Laplacian of a poloidal harmonic with         C
C radial function x(r) results in a toroidal harmonic with scalar    C
C function -D_l^2 x(r).                                              C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARRI    : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NRI     See INDFUN for details       C
C                 INARRI( 3 ) = NHI                                  C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     Note that INARRO, MHTO, MHLO and MHMO correspond to            C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     VI0       : Solution vector. Dim ( * ) ( input )               C
C                 Length must be atleast NRI*NHI                     C
C     VI1       : First  derivatives of VI0 vector. Dim ( * ).       C
C     VI2       : Second derivatives of VI0 vector. Dim ( * ).       C
C     VI3       : Third  derivatives of VI0 vector. Dim ( * ).       C
C     VI4       : Fourth derivatives of VI0 vector. Dim ( * ).       C
C     VO        : Solution vector. Dim ( * )  ( output )             C
C                 Length must be atleast NRO*NHO                     C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SSVLC( NR, VI0, VI1, VI2, VI3, VI4, INARRI, MHTI,
     1                  MHLI, MHMI, VO, INARRO, MHTO, MHLO, MHMO,
     2                  FAC, ILNR, IRNR, XARR )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARRI( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        INARRO( * ), MHTO( * ), MHLO( * ), MHMO( * ),
     2        ILNR, IRNR
      DOUBLE PRECISION VI0( * ), VI1( * ), VI2( * ), VI3( * ),
     1                 VI4( * ), VO( * ), FAC, XARR( NR )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMI, IFORMO, NRI, NRO, NHI, NHO, IHI, IHO, IR,
     1        INDO, INDFUN, L, ICMPO, INDI
      DOUBLE PRECISION LOW, RAD, DL, D0F, D1F, D2F, D3F, D4F, DLDL
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IFORMI = INARRI( 1 )
      NRI    = INARRI( 2 )
      NHI    = INARRI( 3 )
C
      IFORMO = INARRO( 1 )
      NRO    = INARRO( 2 )
      NHO    = INARRO( 3 )
C
      IF ( IFORMI.EQ.1 .OR. IFORMI.EQ.2 .OR.
     1     IFORMO.EQ.1 .OR. IFORMO.EQ.2 ) THEN
         PRINT *,' Subroutine SSVLC.'
         PRINT *,' IFORMI = ', IFORMI
         PRINT *,' IFORMO = ', IFORMO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRI.NE.NR .OR. NRO.NE.NR ) THEN
         PRINT *,' Subroutine SSVLC.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRI  = ', NRI
         PRINT *,' NRO  = ', NRO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( DABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NHI
        IF ( MHTI( IHI ).NE.1 .AND. MHTI( IHI ).NE.2 ) GOTO 50
        IF ( MHTI( IHI ).EQ.1 ) ICMPO = 2
        IF ( MHTI( IHI ).EQ.2 ) ICMPO = 1
C
C so let's look for its corresponding harmonic
C in VO
C
        DO IHO = 1, NHO
          IF (   MHTO( IHO ).EQ.ICMPO          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C
            DO IR = ILNR, IRNR
C
C Find locations of source and destination vectors ...
C
             INDO = INDFUN( IR, IHO, INARRO )
             INDI = INDFUN( IR, IHI, INARRI )
C
             IF ( MHTI( IHI ).EQ.1 ) THEN
c              .
c              . we are doing poloidal --> toroidal
c              . so need to add -D_l^2 operator to RHS
c              . This requires we take up to 4^{th} derivatives
c              .
               L   = MHLI( IHI )
               RAD = XARR( IR )
               D0F = VI0( INDI )
               D2F = VI2( INDI )
               D3F = VI3( INDI )
               D4F = VI4( INDI )
               VO( INDO ) = VO( INDO ) 
     1           - FAC*DLDL( L, RAD, D0F, D2F, D3F, D4F )
c              .
             ELSE
c              .
c              . we are doing toroidal --> poloidal
c              . so we add D_l operator to RHS.
c              . need up to 2^{nd} derivatives
c              .
               L   = MHLI( IHI )
               RAD = XARR( IR )
               D0F = VI0( INDI )
               D1F = VI1( INDI )
               D2F = VI2( INDI )
               VO( INDO ) = VO( INDO )
     1           + FAC*DL( L, RAD, D0F, D1F, D2F )
c              .
             ENDIF
C
            ENDDO
C
          ENDIF 
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Stored derivative Solution Vector LaPlacian *************
C            -                 -        -      - -       *************
C Steve Gibbons Mon Feb  7 08:40:26 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Adds a multiple of FAC* the laplacian of all harmonics IHI in      C
C solution vector VI0 which satisfy MHTI( IHI ) = ICMP to the        C
C corresponding harmonics IHO in vector VO with MHTO( IHO ) = ICMP.  C
C                                                                    C
C The first and second derivatives (precalculated by CASVDR) are     C
C stored in VI1 and VI2.                                             C
C                                                                    C
C Now MHTI defines what each scalar function in a solution vector    C
C represents.                                                        C
C                                                                    C
C         MHTI( IH ) = 1 --> harmonic is poloidal velocity           C
C         MHTI( IH ) = 2 --> harmonic is toroidal velocity           C
C         MHTI( IH ) = 3 --> harmonic is temperature.                C
C         MHTI( IH ) = 4 --> harmonic is poloidal magnetic field     C
C         MHTI( IH ) = 5 --> harmonic is toroidal magnetic field     C
C                                                                    C
C The lapacian of a scalar with radial function f(r)                 C
C is a scalar with radial function D_l f(r) - l is degree of S.H.    C
C                                                                    C
C The lapacian of a toroidal harmonic with radial function f(r)      C
C is toroidal with radial function D_l f(r) - l is degree of S.H.    C
C                                                                    C
C The lapacian of a poloidal harmonic with radial function f(r)      C
C is poloidal with radial function D_l f(r) - l is degree of S.H.    C
C                                                                    C
C  This routine is therefore valid for all forms of harmonics        C
C (itype = 1, 2, 3, 4 and 5) and the result must go in the same      C
C type of harmonic as the original.                                  C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARRI    : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NRI     See INDFUN for details       C
C                 INARRI( 3 ) = NHI                                  C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     ICMP     : The type of harmonic we wish to take curl of.       C
C                                                 see above.         C
C                                                                    C
C     Note that INARRO, MHTO, MHLO and MHMO correspond to            C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     VI0       : Solution vector. Dim ( * ) ( input ). 0 derivs.    C
C                 Length must be atleast NRI*NHI                     C
C     VI1       : Solution vector. Dim ( * ) ( input ). 1 derivs.    C
C                 Length must be atleast NRI*NHI                     C
C     VI2       : Solution vector. Dim ( * ) ( input ). 2 derivs.    C
C                 Length must be atleast NRI*NHI                     C
C     VO        : Solution vector. Dim ( * )  ( output )             C
C                 Length must be atleast NRO*NHO                     C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SSVLP( NR, VI0, VI1, VI2, INARRI, MHTI, MHLI, MHMI,
     1                  ICMP, VO, INARRO, MHTO, MHLO, MHMO, FAC,
     2                  ILNR, IRNR, XARR )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARRI( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        ICMP, INARRO( * ), MHTO( * ), MHLO( * ),
     2        MHMO( * ), ILNR, IRNR
      DOUBLE PRECISION VI0( * ), VI1( * ), VI2( * ), VO( * ), FAC,
     1                 XARR( NR )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMI, IFORMO, NRI, NRO, NHI, NHO, IHI, IHO, IR,
     1        INDO, INDI, INDFUN, L
      DOUBLE PRECISION LOW, RAD, DL, D0F, D1F, D2F
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C     .
C     . However do check ICMP
C     .
C
      IF ( ICMP.NE.1 .AND. ICMP.NE.2 .AND. ICMP.NE.3 .AND.
     1        ICMP.NE.4 .AND. ICMP.NE.5           )    THEN
         PRINT *,' Subroutine SSVLP.'
         PRINT *,' ICMP = ', ICMP
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IFORMI = INARRI( 1 )
      NRI    = INARRI( 2 )
      NHI    = INARRI( 3 )
C
      IFORMO = INARRO( 1 )
      NRO    = INARRO( 2 )
      NHO    = INARRO( 3 )
C
      IF ( IFORMI.EQ.1 .OR. IFORMI.EQ.2 .OR.
     1     IFORMO.EQ.1 .OR. IFORMO.EQ.2 ) THEN
         PRINT *,' Subroutine SSVLP.'
         PRINT *,' IFORMI = ', IFORMI
         PRINT *,' IFORMO = ', IFORMO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRI.NE.NR .OR. NRO.NE.NR ) THEN
         PRINT *,' Subroutine SSVLP.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRI  = ', NRI
         PRINT *,' NRO  = ', NRO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( DABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NHI
        IF ( MHTI( IHI ).NE.ICMP ) GOTO 50
C
C ok - so our harmonic is of the correct type
C so let's look for its corresponding harmonic
C in VO
C
        DO IHO = 1, NHO
          IF (   MHTO( IHO ).EQ.ICMP          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )   .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C
            DO IR = ILNR, IRNR
C
C Find locations of source and destination vectors ...
C
             INDO = INDFUN( IR, IHO, INARRO )
             INDI = INDFUN( IR, IHI, INARRI )
C            .
             L   = MHLI( IHI )
             RAD = XARR( IR )
             D0F = VI0( INDI )
             D1F = VI1( INDI )
             D2F = VI2( INDI )
             VO( INDO ) = VO( INDO )
     1                       + FAC*DL( L, RAD, D0F, D1F, D2F )
C            .
            ENDDO
C
          ENDIF 
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Stored derivative Solution Vector Heat Source Term ******
C            -                 -        -      -    -      -    ******
C Steve Gibbons Thu Nov 18 16:52:11 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C If \nabla^2 T_0( r ) = C (C is a constant), then T_0 has the       C
C general solution                                                   C
C                                                                    C
C            CB1 r^2                                                 C
C T_0( r ) = ------- - CB2 r^{-1}      (cb1 and cb2 are constants)   C
C               2                                                    C
C                                                                    C
C                                                                    C
C and so                                                             C
C                                                                    C
C              [                                     ]               C
C \nabla T_0 = [  CB1 r  +  CB2 r^{-2}     0     0   ]               C
C              [                       ,      ,      ]               C
C                                                                    C
C                                                                    C
C                                          [         CB2  ]          C
C and so v . \nabla T_0 = l(l+1)P(r) Y_l^m [ CB1 +  ----- ]          C
C                                          [         r^3  ]          C
C                                                                    C
C SSVHST adds this term to the appropriate temperature radial funcs. C
C                                                                    C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARRI    : Int. parameter array corresponding to VI0.         C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NRI     See INDFUN for details       C
C                 INARRI( 3 ) = NHI                                  C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     Note that INARRO, MHTO, MHLO and MHMO correspond to            C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     VI0       : Solution vector. Dim ( * ) ( input )               C
C                 Length must be atleast NRI*NHI                     C
C     VO        : Solution vector. Dim ( * )  ( output )             C
C                 Length must be atleast NRO*NHO                     C
C     FAC       : Multiplier of term to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C                                                                    C
C     CB1       : Constant - see above.                              C
C     CB2       : Constant - see above.                              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SSVHST( NR, VI0, INARRI, MHTI, MHLI, MHMI, VO,
     1                   INARRO, MHTO, MHLO, MHMO, FAC, ILNR, IRNR,
     2                   XARR, CB1, CB2 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARRI( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        INARRO( * ), MHTO( * ), MHLO( * ),
     2        MHMO( * ), ILNR, IRNR
      DOUBLE PRECISION VI0( * ), VO( * ), FAC, XARR( NR ), CB1, CB2
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NRI, NRO, NHI, NHO, IR, L, IHI, IHO,
     1        INDFUN, INDO, INDI
      DOUBLE PRECISION LOW, RAD, D0F, F1, R3
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NRI    = INARRI( 2 )
      NHI    = INARRI( 3 )
C
      NRO    = INARRO( 2 )
      NHO    = INARRO( 3 )
C
      IF ( NRI.NE.NR .OR. NRO.NE.NR ) THEN
         PRINT *,' Subroutine SSVHST.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRI  = ', NRI
         PRINT *,' NRO  = ', NRO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( ABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NHI
        IF ( MHTI( IHI ).NE.1 ) GOTO 50
C
C ok - so our harmonic is poloidal velocity
C so let's look for the corresponding temperature
C harmonic in VO
C
        DO IHO = 1, NHO
          IF (   MHTO( IHO ).EQ.3              .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C
            DO IR = ILNR, IRNR
C
C Find locations of source and destination vectors ...
C
              INDO = INDFUN( IR, IHO, INARRO )
              INDI = INDFUN( IR, IHI, INARRI )
C
              L  = MHLI( IHI )
              RAD = XARR( IR )
              IF ( ABS( RAD ).LT.LOW ) THEN
                PRINT *,' Subroutine SSVHST.'
                PRINT *,' Rad at node ',IR,' is ',RAD
                PRINT *,' Division by zero imminent.'
                PRINT *,' Program aborted.'
                STOP
              ENDIF
              R3  = RAD*RAD*RAD
              D0F = VI0( INDI )
              F1  = D0F*DBLE( L )*DBLE( L + 1 )
              VO( INDO ) = VO( INDO ) + FAC*( CB1 + CB2/R3 )*F1
C
            ENDDO
C
          ENDIF
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Stored derivative Solution Vector Term Addition *********
C            -                 -        -      -    -        *********
C Steve Gibbons Tue Oct 26 13:10:21 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Simply adds a factor of FAC * VI( i ) to VO( j ) where i is every  C
C harmonic, IH, such that MHTI( ih ) = ICMPI and grid node such that C
C ILNR .le. ir .le. IRNR - and j is every harmonic, JH, such that    C
C MHTO( jh ) = ICMPO and grid node, jr, such that                    C
C  ILNR .le. ir .le. IRNR                                            C
C                                                                    C
C Useful maybe if adding time derivatives to the forcing term.       C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARRI    : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NRI     See INDFUN for details       C
C                 INARRI( 3 ) = NHI                                  C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See below for key. (corresponds to input vec.)    C
C                                                                    C
C     MHTI( i ) = 1 for a poloidal velocity harmonic, i.             C
C     MHTI( i ) = 2 for a toroidal velocity harmonic, i.             C
C     MHTI( i ) = 3 for a temperature harmonic, i.                   C
C     MHTI( i ) = 4 for a poloidal magnetic field harmonic, i.       C
C     MHTI( i ) = 5 for a toroidal magnetic field harmonic, i.       C
C                                                                    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     Note that INARRO, MHTO, MHLO and MHMO correspond to            C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     ICMPI     : The type of harmonic we wish to act upon.          C
C     ICMPO     : The type of harmonic we wish add term to.          C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     VI0       : Solution vector. Dim ( * ) ( input )               C
C                 Length must be atleast NRI*NHI                     C
C     VO        : Solution vector. Dim ( * )  ( output )             C
C                 Length must be atleast NRO*NHO                     C
C     FAC       : Multiplication factor.                             C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SSVTA( NR, VI0, INARRI, MHTI, MHLI, MHMI, ICMPI,
     1                  VO, INARRO, MHTO, MHLO, MHMO, ICMPO,
     2                  FAC, ILNR, IRNR )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARRI( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        ICMPI, INARRO( * ), MHTO( * ), MHLO( * ),
     2        MHMO( * ), ICMPO, ILNR, IRNR
      DOUBLE PRECISION VI0( * ), VO( * ), FAC
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER INDO, IHI, IHO, NRI, NHI, NRO, NHO, IR,
     1        INDFUN, INDI
      DOUBLE PRECISION D0F, DLOW
      PARAMETER ( DLOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C     . early exit?
C
      IF ( DABS(FAC).LT.DLOW ) RETURN
C
C Check grid nodes ...
C
      NRI    = INARRI( 2 )
      NHI    = INARRI( 3 )
C
      NRO    = INARRO( 2 )
      NHO    = INARRO( 3 )
C     .
      IF ( NRI.NE.NR .OR. NRO.NE.NR ) THEN
         PRINT *,' Subroutine SSVTA.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRI  = ', NRI
         PRINT *,' NRO  = ', NRO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
      DO IHI = 1, NHI
        IF ( MHTI( IHI ).NE.ICMPI ) GOTO 50
C
C ok - so our harmonic is of the correct type
C so let's look for its corresponding harmonic
C in VO
C
        DO IHO = 1, NHO
          IF (   MHTO( IHO ).EQ.ICMPO          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C
            DO IR = ILNR, IRNR
C
C Find locations of source and destination vectors ...
C
             INDI = INDFUN( IR, IHI, INARRI )
             INDO = INDFUN( IR, IHO, INARRO )
             D0F = VI0( INDI )
             VO( INDO ) = VO( INDO ) + FAC*D0F
C
            ENDDO
C
          ENDIF
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Stored Derivative Sol. Vec. 2 Radial QST array **********
C            -      -          -    -    - -      ---       **********
C Steve Gibbons Mon Feb 14 17:50:25 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C If the vector V0 contains radial functions to NH spherical harm.s  C
C with type defined by MHT, MHL and MHM, and V1 the first derivs.,   C
C then SDRQST fills the array RQST with the scaloidal, spheroidal    C
C and toroidal coeff.s of the equivalent representation of the vec.  C
C The monopole term is not included as it cannot exist in the        C
C poloidal/toroidal decomposition.                                   C
C                                                                    C
C V0 and V1 are pre-calculated by CASVDR.                            C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     LH        : Maximum spherical harmonic degree, l.              C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     INARR     : Int. parameter array corresponding to V.           C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NR     See INDFUN for details         C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHT       : Array length ( * ) - atleast length NH             C
C                                                                    C
C         MHT( IH ) = 1 --> harmonic is poloidal velocity            C
C         MHT( IH ) = 2 --> harmonic is toroidal velocity            C
C         MHT( IH ) = 3 --> harmonic is temperature.                 C
C         MHT( IH ) = 4 --> harmonic is poloidal magnetic field      C
C         MHT( IH ) = 5 --> harmonic is toroidal magnetic field      C
C                                                                    C
C     MHL       : Array length ( * ) - atleast length NH             C
C                  Sph. harm. degree, l.                             C
C     MHM       : Array length ( * ) - atleast length NH             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     CHVMFF    : Velocity/magnetic field select.                    C
C                 Set to either 'VEL' or 'MAG'                       C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RQST      : Output array containing scaloidal/spheroidal       C
C                  decomposition of vector.                          C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C     V0        : Solution vector. Legnth must be atleast NR*NH      C
C     V1        : Deriv.s of s. v. Legnth must be atleast NR*NH      C
C                                                                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SDRQST( NR, LH, V0, V1, ILNR, IRNR, INARR,
     1                   RQST, XARR, MHT, MHL, MHM, CHVMFF )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, LH, ILNR, IRNR, INARR( * ),
     1        MHT( * ), MHL( * ), MHM( * )
      DOUBLE PRECISION V0( * ), V1( * ), XARR( NR ),
     1                 RQST( LH*(LH+2), 3, NR )
      CHARACTER *(3) CHVMFF
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NRR, NH, IFORMF, ICOMP, IR, IHARM, INDFUN, IND,
     1        IPOL, ITOR, IH, L, M, ICS, INDSHC
      DOUBLE PRECISION ZERO, D0F, D1F, RAD, SQRLL1, TOL
      PARAMETER ( ZERO = 0.0d0, TOL = 1.0d-9 )
C
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check input parameters ...
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( NR.NE.NRR ) THEN
        PRINT *,' Subroutine SDRQST'
        PRINT *,' NR         = ', NR
        PRINT *,' INARR( 2 ) = ', NRR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
        PRINT *,' Subroutine SDRQST.'
        PRINT *,' IFORMF = ', IFORMF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Let's check validity of CHVMFF
C     .
      IF ( CHVMFF.NE.'VEL' .AND. CHVMFF.NE.'vel' .AND.
     1     CHVMFF.NE.'Vel' .AND. CHVMFF.NE.'MAG' .AND.
     2     CHVMFF.NE.'mag' .AND. CHVMFF.NE.'Mag'  ) THEN
        PRINT *,' Subroutine SDRQST.'
        PRINT *,' CHVMFF = ', CHVMFF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( CHVMFF.EQ.'VEL' .OR. CHVMFF.EQ.'vel' .OR.
     1     CHVMFF.EQ.'Vel' ) THEN
        IPOL = 1
        ITOR = 2
      ENDIF
C     .
      IF ( CHVMFF.EQ.'MAG' .OR. CHVMFF.EQ.'mag' .OR.
     1     CHVMFF.EQ.'Mag' ) THEN
        IPOL = 4
        ITOR = 5
      ENDIF
C     .
C     . Let's zero the array RQST in all
C     . elements we've requested.
C     .
      DO IR = ILNR, IRNR
        DO ICOMP = 1, 3
          DO IHARM = 1, LH*(LH+2)
            RQST( IHARM, ICOMP, IR ) = ZERO
          ENDDO
        ENDDO
      ENDDO
C     .
C     . Loop around the harmonics
C     .
      DO IH = 1, NH
        IF (          MHT( IH ).NE.IPOL     .AND.
     1                MHT( IH ).NE.ITOR     )    GOTO 50
        L  = MHL( IH )
        IF ( L.GT.LH ) THEN
          PRINT *,' Subroutine SDRQST.'
          PRINT *,' Harmonic ',IH,' has L = ',L
          PRINT *,' LH = ', LH
          PRINT *,' Program aborted.'
          STOP
        ENDIF
        IF (          MHM( IH ).GE.0      ) THEN
          M =  MHM( IH )
          ICS = 1
        ELSE
          M = -MHM( IH )
          ICS = 2
        ENDIF
        IHARM = INDSHC( L, M, ICS )
c       .
c       . poloidal harmonics
c       .
        IF ( MHT( IH ).EQ.IPOL ) THEN
C          .
           DO IR = ILNR, IRNR
C            .
             RAD = XARR( IR )
             IF ( RAD.LT.TOL ) THEN
               PRINT *,' Subroutine SDRQST.'
               PRINT *,' Radius = ', RAD,' at node ',IR
               PRINT *,' Division by zero imminent!'
               PRINT *,' Program aborted.'
               STOP
             ENDIF
C            .
C            . Take derivatives
C            .
             IND = INDFUN( IR, IH, INARR )
             D0F = V0( IND )
             D1F = V1( IND )
C            .
C            . Scaloidal part
C            .
             RQST( IHARM, 1, IR ) = DBLE( L*L + L )*D0F/RAD
C            .
C            . Spheroidal part
C            .
             RQST( IHARM, 2, IR ) = 
     1            SQRLL1( L )*(D0F/RAD + D1F)
C            .
           ENDDO
C          .
        ENDIF
c       .
c       . toroidal harmonics
c       .
        IF ( MHT( IH ).EQ.ITOR ) THEN
C          .
           DO IR = ILNR, IRNR
C            .
             IND = INDFUN( IR, IH, INARR )
             D0F = V0( IND )
C            .
C            . Toroidal part
C            .
             RQST( IHARM, 3, IR ) = (-1.0d0)*SQRLL1( L )*D0F
C            .
           ENDDO
C          .
        ENDIF
c       .
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Stored Derivative Velocity dot Gradient of Theta Add ****
C            -      -          -            -           -     -   ****
C Steve Gibbons Mon Feb 14 18:18:21 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C If the vector VI contains radial functions to NHI spherical harm.s C
C with type defined by MHTI, MHLI and MHMI, then SDVGTA will add FAC C
C multiplied by the V.Grad(theta) term to the appropriate locations  C
C in another solution vector VO whose NHO radial functions are       C
C defined by MHTO, MHLO and MHMO.                                    C
C                                                                    C
C Important! The velocity, v, is supplied in the array RQST and      C
C must be obtained in advance by calling ASRQST!!                    C
C SDVGTA does NOT extract the velocity from VI. This is done         C
C entirely to reduce the programming load and ease of checking.      C
C                                                                    C
C Grad theta IS calculated by SDVGTA from the harmonics in VI with   C
C MHTI( ih ) = 3.                                                    C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum spherical harmonic order, m.               C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See below for key. (corresponds to input vec.)    C
C                                                                    C
C     MHTI( i ) = 1 for a poloidal velocity harmonic, i.             C
C     MHTI( i ) = 2 for a toroidal velocity harmonic, i.             C
C     MHTI( i ) = 3 for a temperature harmonic, i.                   C
C     MHTI( i ) = 4 for a poloidal magnetic field harmonic, i.       C
C     MHTI( i ) = 5 for a toroidal magnetic field harmonic, i.       C
C                                                                    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     INARRI    : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NRI     See INDFUN for details       C
C                 INARRI( 3 ) = NHI                                  C
C                                                                    C
C     Note that INARRO, MHTO, MHLO and MHMO correspond to            C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     V0        : Solution vector. Dim ( * ) ( input )               C
C                 Length must be atleast NRI*NHI                     C
C     V1        : Solution vector. Dim ( * ) ( input )               C
C                 First deriv.s of above. Calc. by CASVDR.           C
C     VO        : Solution vector. Dim ( * )  ( output )             C
C                 Length must be atleast NRO*NHO                     C
C     FAC       : Multiplication factor.                             C
C     RQST      : Input array containing scaloidal/spheroidal/tor.   C
C                  decomposition of velocity vector.                 C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C     VF1       : Work arr. dim. ( NPHPTS, NTHPTS, 3 )               C
C     VF2       : Work arr. dim. ( NPHPTS, NTHPTS, 3 )               C
C     SF        : Work arr. dim. ( NPHPTS, NTHPTS )                  C
C     FTF1      : Work arr. dim. ( 2*NPHPTS )                        C
C     FTF2      : Work arr. dim. ( 2*NPHPTS )                        C
C     FTF3      : Work arr. dim. ( 2*NPHPTS )                        C
C                                                                    C
C     SHC       : Work array. Dim ( LH*(LH+2) ).                     C
C     DSHC      : Work array. Dim ( LH*(LH+2) ).                     C
C                                                                    C
C     XARR      : Values of radial nodes. Dim ( NR )                 C
C                                                                    C
C     ZCOEFA    : Coefficients of the monopole term in the R compon. C
C                 This is not necessarily zero in general (but ought C
C                 to be for this procedure!!! )                      C
C                 Dimension ( NR )                                   C
C                                                                    C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SDVGTA ( NR, LH, MMAX, MHTI, MHLI, MHMI, V0, V1,
     1             INARRI, MHTO, MHLO, MHMO, VO, INARRO, RQST,
     2             VF1, VF2, SF, FTF1, FTF2, FTF3, SHC, DSHC, GAUX,
     3             GAUW, PA, DPA, NTHPTS, NPHPTS, FAC, ILNR, IRNR,
     4             XARR, ZCOEFA)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
C
      INTEGER NR, LH, MMAX, NTHPTS, NPHPTS, ILNR, IRNR, 
     1        MHTI( * ), MHLI( * ), MHMI( * ), INARRI( * ),
     2        MHTO( * ), MHLO( * ), MHMO( * ), INARRO( * )
      DOUBLE PRECISION V0( * ), V1( * ), VO( * ),
     1                 RQST( LH*(LH+2), 3, NR ), GAUX( NTHPTS ),
     2                 GAUW( NTHPTS ), ZCOEFA( NR ), FAC
      DOUBLE PRECISION XARR( NR ), FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
      DOUBLE PRECISION SHC( LH*(LH+2) ), DSHC( LH*(LH+2) ),
     2                 SF( NPHPTS, NTHPTS )
      DOUBLE PRECISION VF1( NPHPTS, NTHPTS, 3 ),
     1                 VF2( NPHPTS, NTHPTS, 3 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER NRI, NRO, NHI, NHO, IR, IOP, NH, IHI, IHARM,
     1        IND, L, M, ICS, IHO, INDSHC, INDFUN
      DOUBLE PRECISION ZERO, D0F, D1F, DZCOEF, ZCOEF, RAD
      PARAMETER ( ZERO = 0.0d0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NRI    = INARRI( 2 )
      NHI    = INARRI( 3 )
C
      NRO    = INARRO( 2 )
      NHO    = INARRO( 3 )
C
      NH     = LH*(LH + 2)
C
      IF ( NRI.NE.NR .OR. NRO.NE.NR ) THEN
         PRINT *,' Subroutine SDVGTA.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRI  = ', NRI
         PRINT *,' NRO  = ', NRO
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Loop around radial grid nodes from
C     . IR = ILNR to IR = IRNR.
C     .
      DO IR = ILNR, IRNR
C       .
        RAD = XARR( IR )
C       .
C       . Fill VF1 with the velocity evaluated at node IR
C       .
        CALL RQSTVF ( RQST, VF1, GAUX, PA, DPA, FTF1, FTF2, FTF3,
     1                LH, NTHPTS, NPHPTS, MMAX, ZCOEFA, NR, IR )
C       .
C       . First let's zero the arrays SHC and DSHC for node IR
C       .
        IOP = 0
        CALL VECOP( SHC, ZERO, NH, IOP )
        CALL VECOP( DSHC, ZERO, NH, IOP )
        DZCOEF = ZERO
C       .
C       . Let's loop around harmonics, ihi, in
C       . VI and for each one with MHTI( ihi ) = 3
C       . we put an entry into SHC and DSHC
C       .
        DO IHI = 1, NHI
          IF (    MHTI( IHI ).NE.3     )    GOTO 50
          L  = MHLI( IHI )
          IF ( L.GT.LH ) THEN
            PRINT *,' Subroutine SDVGTA.'
            PRINT *,' Harmonic ',IHI,' has L = ',L
            PRINT *,' LH = ', LH
            PRINT *,' Program aborted.'
            STOP
          ENDIF
          IF (          MHMI( IHI ).GE.0      ) THEN
            M =  MHMI( IHI )
            ICS = 1
          ELSE
            M = -MHMI( IHI )
            ICS = 2
          ENDIF
          IHARM = INDSHC( L, M, ICS )
C         .
C         . Calculate D0F and D1F
C         .
          IND = INDFUN( IR, IHI, INARRI )
          D0F = V0( IND )
          D1F = V1( IND )
C         .
C         . Add to either DZCOEF, or SHC and DSHC
C         .
          IF ( IHARM.EQ.0 ) THEN
            DZCOEF = D1F
          ELSE
            SHC( IHARM )  = D0F
            DSHC( IHARM ) = D1F
          ENDIF
C         .
 50     CONTINUE
        ENDDO
C       .
C       . SHC, DSHC and DZCOEF are now ready to be
C       . supplied to GRINVT - this will fill VF2
C       . with Grad( theta )
C       .
        CALL GRINVT( SHC, DSHC, GAUX, RAD, PA, DPA, FTF1, FTF2,
     1               FTF3, VF2, LH, NTHPTS, NPHPTS, MMAX, DZCOEF )
C       .
C       . VF1 now contains V and VF2 now contains Grad( theta )
C       . so now take scalar product.
C       .
        CALL VFDP( VF1, VF2, SF, NPHPTS, NTHPTS )
C       .
C       . SF now contains the scalar function in
C       . space - so transform back to shc coeffs
C       .
        CALL FORSST( SHC, SF, GAUW, PA, FTF1, LH, MMAX,
     1               NTHPTS, NPHPTS, ZCOEF )
C       .
C       . Now loop around 'output' harmonics
C       . and place in appropriate locations
C       .
        DO IHO = 1, NHO
          IF (    MHTO( IHO ).NE.3     )    GOTO 51
          L = MHLO( IHO )
          IF (          MHMO( IHO ).GE.0      ) THEN
            M =  MHMO( IHO )
            ICS = 1
          ELSE
            M = -MHMO( IHO )
            ICS = 2
          ENDIF
          IHARM = INDSHC( L, M, ICS )
C
C Next line means harmonic iho is beyond the scale
C resolved by the current transform
C
          IF ( IHARM.GT.NH ) GOTO 51
          IND = INDFUN( IR, IHO, INARRO )
C         .
          IF ( IHARM.EQ.0 ) THEN
            VO( IND ) = VO( IND ) + FAC*ZCOEF
          ELSE
            VO( IND ) = VO( IND ) + FAC*SHC( IHARM )
          ENDIF
C         .
 51     CONTINUE
        ENDDO
C       .
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

      

C*********************************************************************
C subroutine Radial QST Coriolis Force *******************************
C            -      --- -        -     *******************************
C Steve Gibbons Sat Oct  2 17:51:02 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Given a vector, v, in RQST format, RQSTCF will return (k \times v) C
C in RQST format. v is supplied in the array RQST1, and (k \times v) C
C is output RQST2.                                                   C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum mode number to be used.                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C     NTHPTS    : Number of points in theta.                         C
C     NPHPTS    : Number of points in phi.                           C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     GAUW      : Gauss weights computed bu GAUWTS. Dim ( NTHPTS )   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C       PA and DPA must be formed in advance by a call to SCHNLA.    C
C                                                                    C
C  RQST1 and ZCF1 store the qst decomposition of input vector.       C
C  RQST2 and ZCF2 store the qst decomposition of the output vector.  C
C                                                                    C
C   ZCF. ( j ) contains the coeff. to Q_0^0( r_j )                   C
C                                                                    C
C     RQST1     : Dim. (  LH*(LH+2) ,3, NR )                         C
C     ZCF1      : Dim. (  NR )                                       C
C     RQST2     : Dim. (  LH*(LH+2) ,3, NR )                         C
C     ZCF2      : Dim. (  NR )                                       C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF1       : Storage for vector function. Dim.(NPHPTS,NTHPTS,3) C
C     FTF1      : Array for fourier transforming. Dim. ( 2*NPHPTS )  C
C     FTF2      : Array for fourier transforming. Dim. ( 2*NPHPTS )  C
C     FTF3      : Array for fourier transforming. Dim. ( 2*NPHPTS )  C
C                                                                    C
C None of these arrays need any input or output values but must be   C
C in parameter list for the sake of dimensioning.                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RQSTCF( NR, LH, MMAX, ILNR, IRNR, NTHPTS, NPHPTS,
     1                   GAUX, GAUW, PA, DPA, RQST1, ZCF1, RQST2,
     2                   ZCF2, VF1, FTF1, FTF2, FTF3 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, LH, MMAX, ILNR, IRNR, NTHPTS, NPHPTS
      DOUBLE PRECISION RQST1( LH*(LH+2) ,3 ,NR ), ZCF1( NR ),
     1                 RQST2( LH*(LH+2) ,3 ,NR ), ZCF2( NR )
      DOUBLE PRECISION FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
      DOUBLE PRECISION VF1( NPHPTS, NTHPTS, 3), GAUX( NTHPTS ),
     1                 GAUW( NTHPTS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IR
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Loop around points IR = ILNR, IRNR
C
      DO IR = ILNR, IRNR
C       .
C       . Put the vector function of RQST1 into VF1 for node IR
C       .
        CALL RQSTVF( RQST1, VF1, GAUX, PA, DPA, FTF1, FTF2, FTF3,
     1               LH, NTHPTS, NPHPTS, MMAX, ZCF1, NR, IR )
C       .
C       . Replace VF1 with the appropriate Coriolis term.
C       .
        CALL VFCOR( NTHPTS, NPHPTS, VF1, GAUX )
C       .
C       . Transform back into RQST3
C       .
        CALL VFRQST( RQST2, VF1, GAUX, GAUW, PA, DPA, FTF1, FTF2,
     1               FTF3, ZCF2, LH, NTHPTS, NPHPTS, MMAX, NR, IR )
C       .
C
      ENDDO
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Radial QST Cross Product ********************************
C            -      --- -     -       ********************************
C Steve Gibbons Sat Oct  2 16:20:35 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Given two vectors in RQST format, RQSTCP will return a third vec.  C
C which is VEC1 \times VEC2, also in RQST format.                    C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum mode number to be used.                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C     NTHPTS    : Number of points in theta.                         C
C     NPHPTS    : Number of points in phi.                           C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     GAUW      : Gauss weights computed bu GAUWTS. Dim ( NTHPTS )   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C       PA and DPA must be formed in advance by a call to SCHNLA.    C
C                                                                    C
C  RQST1 and ZCF1 store the qst decomposition of input vector 1.     C
C  RQST2 and ZCF2 store the qst decomposition of input vector 2.     C
C  RQST3 and ZCF3 store the qst decomposition of the output vector.  C
C                                                                    C
C   ZCF. ( j ) contains the coeff. to Q_0^0( r_j )                   C
C                                                                    C
C     RQST1     : Dim. (  LH*(LH+2) ,3, NR )                         C
C     ZCF1      : Dim. (  NR )                                       C
C     RQST2     : Dim. (  LH*(LH+2) ,3, NR )                         C
C     ZCF2      : Dim. (  NR )                                       C
C     RQST3     : Dim. (  LH*(LH+2) ,3, NR )                         C
C     ZCF3      : Dim. (  NR )                                       C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF1       : Storage for vector function. Dim.(NPHPTS,NTHPTS,3) C
C     VF2       : Storage for vector function. Dim.(NPHPTS,NTHPTS,3) C
C     VF3       : Storage for vector function. Dim.(NPHPTS,NTHPTS,3) C
C     FTF1      : Array for fourier transforming. Dim. ( 2*NPHPTS )  C
C     FTF2      : Array for fourier transforming. Dim. ( 2*NPHPTS )  C
C     FTF3      : Array for fourier transforming. Dim. ( 2*NPHPTS )  C
C                                                                    C
C None of these arrays need any input or output values but must be   C
C in parameter list for the sake of dimensioning.                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RQSTCP( NR, LH, MMAX, ILNR, IRNR, NTHPTS, NPHPTS,
     1                   GAUX, GAUW, PA, DPA, RQST1, ZCF1, RQST2,
     2                   ZCF2, RQST3, ZCF3, VF1, VF2, VF3, FTF1,
     3                   FTF2, FTF3 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, LH, MMAX, ILNR, IRNR, NTHPTS, NPHPTS
      DOUBLE PRECISION RQST1( LH*(LH+2) ,3 ,NR ), ZCF1( NR ),
     1                 RQST2( LH*(LH+2) ,3 ,NR ), ZCF2( NR ),
     2                 RQST3( LH*(LH+2) ,3 ,NR ), ZCF3( NR )
      DOUBLE PRECISION FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
      DOUBLE PRECISION VF1( NPHPTS, NTHPTS, 3), GAUX( NTHPTS ),
     1                 VF2( NPHPTS, NTHPTS, 3), GAUW( NTHPTS ),
     2                 VF3( NPHPTS, NTHPTS, 3)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IR
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Loop around points IR = ILNR, IRNR
C
      DO IR = ILNR, IRNR
C       .
C       . Put the vector function of RQST1 into VF1 for node IR
C       .
        CALL RQSTVF( RQST1, VF1, GAUX, PA, DPA, FTF1, FTF2, FTF3,
     1               LH, NTHPTS, NPHPTS, MMAX, ZCF1, NR, IR )
C       .
C       . Put the vector function of RQST2 into VF2 for node IR
C       .
        CALL RQSTVF( RQST2, VF2, GAUX, PA, DPA, FTF1, FTF2, FTF3,
     1               LH, NTHPTS, NPHPTS, MMAX, ZCF2, NR, IR )
C       .
C       . Take cross product of vectors 1 and 2
C       .
        CALL VFCP( VF1, VF2, VF3, NPHPTS, NTHPTS )
C       .
C       . Transform back into RQST3
C       .
        CALL VFRQST( RQST3, VF3, GAUX, GAUW, PA, DPA, FTF1, FTF2,
     1               FTF3, ZCF3, LH, NTHPTS, NPHPTS, MMAX, NR, IR )
C       .
C
      ENDDO
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Radial QST Curl Add *************************************
C            -      --- -    -   *************************************
C Steve Gibbons Tue Feb 15 08:17:08 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C If RQST contains a QST decomposition of a vector function          C
C then CRQST is returned containing                                  C
C                                                                    C
C  A * CRQST + B * curl ( RQST )                                     C
C                                                                    C
C There must be NR grid nodes for both functions and both functions  C
C must be stored with harmonics of degree l up to LH.                C
C                                                                    C
C The radial value of the node, j is stored in XARR( j )             C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     LH        : Maximum value of degree, l.                        C
C     NR        : Number of radial grid nodes in each function.      C
C     M0        : Basic wavenumber. Modes M which do not satisfy     C
C                 MOD( M, M0 ) = 0 are bypassed. This increases      C
C                 the speed in 2.5D calculations.                    C
C                                                                    C
C     MMAX      : Maximum wavenumber. Modes M which do not satisfy   C
C                 M .le. MMAX are ignored.                           C
C                                                                    C
C     NBN       : Number of bounding nodes. See RQSTDR.              C
C                                                                    C
C     NFDCM     : Leading dimension of FDCM. At least (2*NBN+1)      C
C     NDVDS     : Number of highest derivative for which             C
C                  coefficients are stored by the array FDCM.        C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     ILNC      : Number of left most node which can be used to      C
C                     calculate derivatives.                         C
C     IRNC      : Number of right most node which can be used to     C
C                     calculate derivatives.                         C
C                                                                    C
C  ILNC and IRNC correspond to NLMC and NRMC in the call to FDCMBD.  C
C                                                                    C
C     ICLS      : Set to 1 to zero the array. No action for other    C
C                                                     values.        C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RQST      : Dim ( LH*(LH+2), 3, NR )                           C
C                                                                    C
C                 Input array containing scaloidal/spheroidal        C
C                  decomposition of vector.                          C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C     CRQST     : Dim ( LH*(LH+2), 3, NR ) - Is returned containing  C
C                 the curl of the function in RQST.                  C
C                                                                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     FDCM      : Dim ( NFDCM, NR, NDRVS ). Finite diff. coeff.s     C
C                Must be formed in advance by a call to FDCMBD.      C
C                                                                    C
C     A         : Factor multiplying original values of CRQST.       C
C                                                                    C
C     B         : Factor multiplying values of curl of RQST.         C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RQSTCA( LH, NR, M0, MMAX, NBN, NFDCM, NDVDS, ILNR,
     1                   IRNR, ILNC, IRNC, RQST, CRQST, XARR, FDCM,
     2                   ICLS, A, B )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, LH, M0, MMAX, NBN, NFDCM, NDVDS, ILNR, IRNR,
     1        ILNC, IRNC, ICLS
      DOUBLE PRECISION XARR( NR ), A, B,
     1                 FDCM( NFDCM, NR, NDVDS ),
     2                 RQST( LH*(LH+2), 3, NR ),
     3                 CRQST( LH*(LH+2), 3, NR )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IH, L, M, ICS, IR, IQ, IS, IT, IHD, ICOMP
      DOUBLE PRECISION D0F, D1F, DERV(1), ZERO, RAD, SQRLL1
      PARAMETER ( ZERO = 0.0d0, IQ = 1, IS = 2, IT = 3, IHD = 1 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      IF ( M0.EQ.0 ) THEN
        PRINT *,' Subroutine RQSTCA.'
        PRINT *,' M0 = ', M0
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . First zero all elements of CRQST which correspond
C     . to IR with IR.GE.ILNR and IR.LE.IRNC if required.
C     .
      IF ( ICLS.EQ.1 ) THEN
       DO IR = ILNR, IRNR
         DO ICOMP = 1, 3
           DO IH = 1, LH*(LH+2)
             CRQST( IH, ICOMP, IR ) = ZERO
           ENDDO
         ENDDO
       ENDDO
      ENDIF
C     .
      DO IH = 1, LH*(LH+2)
        CALL LMFIND( IH, L, M, ICS )
        IF ( M.GT.MMAX ) GOTO 50
        IF ( MOD( M, M0).NE.0 ) GOTO 50
C       .
C       . curl of scaloidal function q(r)
C       . subtracts -sqrll1( l )q(r)/r from toroidal part
C       .
        DO IR = ILNR, IRNR
          RAD = XARR( IR )
          D0F = RQST( IH, IQ, IR )
          CRQST( IH, IT, IR ) = A*CRQST( IH, IT, IR ) -
     1                          B*SQRLL1( L )*D0F/RAD
        ENDDO
C       .
C       . curl of spheroidal function s(r)
C       . adds ( ds(r)/dr + s(r)/r ) to toroidal part
C       .
        DO IR = ILNR, IRNR
          RAD = XARR( IR )
          D0F = RQST( IH, IS, IR )
          CALL RQSTDR( RQST, IR, IH, NBN, IHD, NFDCM, NR, NDVDS,
     1                 DERV, ILNC, IRNC, FDCM, LH, IS )
          D1F = DERV( 1 )
          CRQST( IH, IT, IR ) = CRQST( IH, IT, IR ) +
     1                                   B*( D1F + D0F/RAD )
        ENDDO
C       .
C       . curl of toroidal function t(r)
C       . subtracts sqrll1( l ) t(r)/r from the scaloidal
C       . part and 
C       . subtracts ( dt(r)/dr + t(r)/r ) from the spheroidal
C       . part
C       .
        DO IR = ILNR, IRNR
          RAD = XARR( IR )
          D0F = RQST( IH, IT, IR )
          CALL RQSTDR( RQST, IR, IH, NBN, IHD, NFDCM, NR, NDVDS,
     1                 DERV, ILNC, IRNC, FDCM, LH, IT )
          D1F = DERV( 1 )
          CRQST( IH, IQ, IR ) = A*CRQST( IH, IQ, IR ) -
     1                          B*SQRLL1( L )*D0F/RAD
          CRQST( IH, IS, IR ) = A*CRQST( IH, IS, IR ) -
     1                          B*( D1F + D0F/RAD )
        ENDDO
C       .
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Radial QST array 2 Solution Vector **********************
C            -      ---         -        -      **********************
C Steve Gibbons Tue Sep 28 14:40:56 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds the poloidal and toroidal components of the RQST array        C
C to the appropriate elements of RQSTSV.                             C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     LH        : Maximum spherical harmonic degree, l.              C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C     INARR     : Int. parameter array corresponding to V.           C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NR     See INDFUN for details         C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHT       : Array length ( * ) - atleast length NH             C
C                                                                    C
C         MHT( IH ) = 1 --> harmonic is poloidal velocity            C
C         MHT( IH ) = 2 --> harmonic is toroidal velocity            C
C         MHT( IH ) = 3 --> harmonic is temperature.                 C
C         MHT( IH ) = 4 --> harmonic is poloidal magnetic field      C
C         MHT( IH ) = 5 --> harmonic is toroidal magnetic field      C
C                                                                    C
C     MHL       : Array length ( * ) - atleast length NH             C
C                  Sph. harm. degree, l.                             C
C     MHM       : Array length ( * ) - atleast length NH             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     CHVMFF    : Velocity/magnetic field select.                    C
C                 Set to either 'VEL' or 'MAG'                       C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     RQST      : Output array containing scaloidal/spheroidal       C
C                  decomposition of vector.                          C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C     V         : Solution vector. Legnth must be atleast NR*NH      C
C                                                                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     FAC       : Constant scalar to multiply before addition to V.  C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RQSTSV( NR, LH, ILNR, IRNR, INARR, MHT, MHL, MHM, 
     1                   CHVMFF, RQST, V, XARR, FAC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, LH, ILNR, IRNR, INARR( * ),
     1        MHT( * ), MHL( * ), MHM( * )
      DOUBLE PRECISION V( * ), XARR( NR ),
     2                 RQST( LH*(LH+2), 3, NR ), FAC
      CHARACTER *(3) CHVMFF
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER NRR, NH, IFORMF, IND, INDFUN, L, M, ICS, IH, IHARM,
     1        IPOL, ITOR, IR, INDSHC
      DOUBLE PRECISION D0F, RAD, SQRLL1
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check input parameters ...
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( NR.NE.NRR ) THEN
        PRINT *,' Subroutine RQSTSV'
        PRINT *,' NR         = ', NR
        PRINT *,' INARR( 2 ) = ', NRR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
        PRINT *,' Subroutine RQSTSV.'
        PRINT *,' IFORMF = ', IFORMF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Let's check validity of CHVMFF
C     .
      IF ( CHVMFF.NE.'VEL' .AND. CHVMFF.NE.'vel' .AND.
     1     CHVMFF.NE.'Vel' .AND. CHVMFF.NE.'MAG' .AND.
     2     CHVMFF.NE.'mag' .AND. CHVMFF.NE.'Mag'  ) THEN
        PRINT *,' Subroutine RQSTSV.'
        PRINT *,' CHVMFF = ', CHVMFF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( CHVMFF.EQ.'VEL' .OR. CHVMFF.EQ.'vel' .OR.
     1     CHVMFF.EQ.'Vel' ) THEN
        IPOL = 1
        ITOR = 2
      ENDIF
C     .
      IF ( CHVMFF.EQ.'MAG' .OR. CHVMFF.EQ.'mag' .OR.
     1     CHVMFF.EQ.'Mag' ) THEN
        IPOL = 4
        ITOR = 5
      ENDIF
C     .
C     . Loop around the harmonics
C     .
      DO IH = 1, NH
        IF (          MHT( IH ).NE.IPOL     .AND.
     1                MHT( IH ).NE.ITOR     )    GOTO 50
        L = MHL( IH )
        IF ( L.GT.LH ) THEN
          PRINT *,' Subroutine RQSTSV.'
          PRINT *,' Harmonic ',IH,' has L = ',L
          PRINT *,' LH = ', LH
          PRINT *,' Program aborted.'
          STOP
        ENDIF
        IF (          MHM( IH ).GE.0      ) THEN
          M =  MHM( IH )
          ICS = 1
        ELSE
          M = -MHM( IH )
          ICS = 2
        ENDIF
        IHARM = INDSHC( L, M, ICS )
c       .
c       . poloidal harmonics
c       .
        IF ( MHT( IH ).EQ.IPOL ) THEN
C          .
           DO IR = ILNR, IRNR
             RAD = XARR( IR )
             IND = INDFUN( IR, IH, INARR )
             D0F = RQST( IHARM, 1, IR )
             V( IND ) = V( IND ) + FAC*D0F*RAD/DBLE( L*L + L )
           ENDDO
C          .
        ENDIF
c       .
c       . toroidal harmonics
c       .
        IF ( MHT( IH ).EQ.ITOR ) THEN
C          .
           DO IR = ILNR, IRNR
             IND = INDFUN( IR, IH, INARR )
             D0F = RQST( IHARM, 3, IR )
             V( IND ) = V( IND ) - FAC*D0F/SQRLL1( L )
           ENDDO
C          .
        ENDIF
c       .
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Vorticity Matrix Linear Term Addition ***********
C            -       -         -      -      -    -        ***********
C Steve Gibbons Thu Nov 18 19:00:33 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds to a matrix A the linear terms to the vorticity equation such C
C that multiplying A by VI will give an output vector consisting     C
C of ( p, \tau, \Theta ) such that the output is                     C
C                                                                    C
C        CD \nabla^2 \Theta                                          C
C                                                                    C
C      + CI \nabla^2 \curl v                                         C
C                                                                    C
C      - CG \curl ( k \times v )                                     C
C                                                                    C
C      - CA d theta / d t                                            C
C                                                                    C
C      - CE \curl d v / d t                                          C
C                                                                    C
C      + CH \curl ( \Theta {\bm r } )                                C
C                                                                    C
C      + v . ( CB1 r + CB2 r^{-2} , 0 , 0 )                          C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR      See INDFUN for details       C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHT      : Array length ( * ) - atleast length NH              C
C                                                                    C
C         MHT( IH ) = 1 --> harmonic is poloidal velocity            C
C         MHT( IH ) = 2 --> harmonic is toroidal velocity            C
C         MHT( IH ) = 3 --> harmonic is temperature.                 C
C         MHT( IH ) = 4 --> harmonic is poloidal magnetic field      C
C         MHT( IH ) = 5 --> harmonic is toroidal magnetic field      C
C                                                                    C
C     MHL      : Array length ( * ) - atleast length NH              C
C                  Sph. harm. degree, l.                             C
C     MHM      : Array length ( * ) - atleast length NH              C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHP      : Array length ( * ) - atleast length NH              C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MHTR     : Array length ( * ) - atleast length NH              C
C                 Type of function in equation rows.                 C
C                 Under normal circumstances, MHTR is formed by      C
C                                                                    C
C                 CALL CINDSW( NH, MHT, MHTR )                       C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     KL        : Number of lower diagonals in matrix                C
C                                                                    C
C     NCFM      : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C      (NDRVM must be atleast 4 and NDRVS must be 4 for atleast      C
C       grid nodes IR = 2, NR - 1 ).                                 C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C     NTHP      : The number of theta points.                        C
C     NPHP      : The number of phi points.                          C
C                                                                    C
C     MMAX      : Maximum sph. harmonic order, m.                    C
C                                                                    C
C     LH        : Maximum spherical harmonic degree, l.              C
C                                                                    C
C     ICLS      : Zeros the matrix A on entry if and only if ICLS=1. C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NCFM, NR, NDRVM+1, NDCS ).            C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     GAUX      : Cosines of the NTHP evaluated by the routine       C
C                  gauwts. Dimension ( NTHP ).                       C
C     GAUW      : Corresponding weights. As above.                   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2, NTHP )       C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C     FTF1      : Work array - dim. (2*NPHP)                         C
C     FTF2      : Work array - dim. (2*NPHP)                         C
C     FTF3      : Work array - dim. (2*NPHP)                         C
C     VF        : Work array - dim. ( NPHP, NTHP, 3)                 C
C     QST       : Work array - dim. ( LH*(LH+2), 3)                  C
C                                                                    C
C     PARAM     : Array dim ( 8 ) containing above param.s           C
C                                                                    C
C            PARAM(  1 ) = CA                                        C
C            PARAM(  2 ) = CB1                                       C
C            PARAM(  3 ) = CB2                                       C
C            PARAM(  4 ) = CD                                        C
C            PARAM(  5 ) = CE                                        C
C            PARAM(  6 ) = CG                                        C
C            PARAM(  7 ) = CH                                        C
C            PARAM(  8 ) = CI                                        C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AVMLTA( NR, INARR, MHT, MHL, MHM, MHP, MHTR, NBN, KL,
     1                   NCFM, NDRVM, SVFDC, A, N1, N2, NDCS, XARR,
     2                   NTHP, NPHP, MMAX, LH, GAUX, GAUW, PA, DPA,
     3                   FTF1, FTF2, FTF3, VF, QST, PARAM, ICLS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHT( * ), MHL( * ), MHM( * ), MHP( * ),
     1        MHTR( * ), NBN, KL, NCFM, NDRVM, N1, N2, NDCS, NTHP,
     2        NPHP, MMAX, LH, ICLS
      DOUBLE PRECISION PARAM( 8 ), XARR( NR ), A( N1, N2 ),
     1                 SVFDC( NCFM, NR, NDRVM+1, NDCS )
      DOUBLE PRECISION
     1                 QST( LH*(LH+2), 3),
     2                 VF( NPHP, NTHP, 3), FTF1( 2*NPHP ),
     3                 FTF2( 2*NPHP ), FTF3( 2*NPHP )
      DOUBLE PRECISION
     1                 GAUX( NTHP ), GAUW( NTHP ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHP)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IMF, NH, NDRVS, ICMP, ICMPO, IOP, IFORMF, NRR,
     1        ILNPOL, ILNTOR, ILNTHE, IRNPOL, IRNTOR, IRNTHE, KLE
      DOUBLE PRECISION CA, CB1, CB2, CD, CE, CG, CH, CI, FAC, ZERO
      PARAMETER ( ZERO = 0.0d0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IMF = 1
C
      CA     = PARAM( 1 )
      CB1    = PARAM( 2 )
      CB2    = PARAM( 3 )
      CD     = PARAM( 4 )
      CE     = PARAM( 5 )
      CG     = PARAM( 6 )
      CH     = PARAM( 7 )
      CI     = PARAM( 8 )
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IFORMF.NE.3 ) THEN
        PRINT *,' Subroutine AVMLTA.'
        PRINT *,' IFORMF   = ', IFORMF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( NRR.NE.NR ) THEN
        PRINT *,' Subroutine AVMLTA.'
        PRINT *,' NR       = ', NR
        PRINT *,' INARR(2) = ', NRR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( KL.NE.((NBN+1)*NH - 1) ) THEN
        PRINT *,' Subroutine AVMLTA'
        PRINT *,' KL  = ', KL
        PRINT *,' NH  = ', NH
        PRINT *,' NBN = ', NBN
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( N1.NE.(3*KL+1) .AND. N1.NE.(2*KL+1) ) THEN
        PRINT *,' Subroutine AVMLTA'
        PRINT *,' N1 = ', N1
        PRINT *,' KL = ', KL
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( N1.EQ.(3*KL+1) ) THEN
        KLE = KL
      ELSE
        KLE = 0
      ENDIF
C
      IF ( N2.NE.NR*NH ) THEN
        PRINT *,' Subroutine AVMLTA'
        PRINT *,' N2 = ', N2
        PRINT *,' NR = ', NR
        PRINT *,' NH = ', NH
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Clear matrix if requested
C
      IF ( ICLS.EQ.1 ) THEN
        IOP = 0
        CALL MATOP( A, ZERO, N1, N2, IOP )
      ENDIF
C
      ILNPOL = 2
      IRNPOL = NR - 1
      ILNTOR = 3
      IRNTOR = NR - 2
      ILNTHE = 2
      IRNTHE = NR - 1
C
      NDRVS = 4
C
C First; Laplacian of temperature
C
      ICMP  = 3
      FAC   = CD
      CALL AMLP( NR, INARR, MHT, MHL, MHM, MHP, ICMP, MHTR,
     1           MHL, MHM, FAC, NBN, NDRVS, NDRVM, NCFM,
     2           ILNTHE, IRNTHE, SVFDC, XARR, NDCS, A,
     3           N1, N2, IMF, KL, KL, KLE )
C
C Curl of Laplacian for velocity
C
      FAC = CI
      CALL AMLC( NR, INARR, MHT, MHL, MHM, MHP, MHTR, MHL,
     1           MHM, FAC, NBN, NDRVS, NDRVM, ILNPOL, IRNPOL,
     2           ILNTOR, IRNTOR, XARR, NCFM, A, N1, N2, IMF,
     3           KL, KL, KLE, NDCS, SVFDC )
C
C Curl ( k x V )
C
      FAC = (-1.0d0)*CG
      CALL AMCCFA( NR, INARR, MHT, MHL, MHM, MHP, MHTR, MHL, MHM,
     1      FAC, NBN, NDRVS, NDRVM, ILNPOL, IRNPOL, ILNTOR, IRNTOR,
     2      LH, NTHP, NPHP, XARR, NCFM, A, N1, N2, IMF, KL, KL, KLE,
     3      NDCS, SVFDC, MMAX, GAUX, GAUW, PA, DPA, FTF1, FTF2,
     4      FTF3, VF, QST )
C
C d theta / dt
C
      FAC = (-1.0d0)*CA
      ICMP = 3
      CALL AMTA( NR, INARR, MHT, MHL, MHM, MHP, ICMP,
     1           MHTR, MHL, MHM, ICMP, FAC, ILNTHE, IRNTHE, A,
     2           N1, N2, IMF, KL, KL, KLE, NDRVS, NDRVM, NCFM,
     3           NDCS, SVFDC, XARR, NBN )
C
C curl dv/dt
C
      FAC   = (-1.0d0)*CE
      ICMP  = 1
      ICMPO = 2
      CALL AMCL( NR, INARR, MHT, MHL, MHM, MHP, ICMP, MHTR,
     1           MHL, MHM, ICMPO, FAC, NBN, NDRVS, NDRVM,
     2           ILNTOR, IRNTOR, XARR, NCFM, SVFDC, A, N1, N2,
     3           IMF, KL, KL, KLE, NDCS )
C
      FAC   = (-1.0d0)*CE
      ICMP  = 2
      ICMPO = 1
      CALL AMCL( NR, INARR, MHT, MHL, MHM, MHP, ICMP, MHTR,
     1           MHL, MHM, ICMPO, FAC, NBN, NDRVS, NDRVM,
     2           ILNPOL, IRNPOL, XARR, NCFM, SVFDC, A, N1, N2,
     3           IMF, KL, KL, KLE, NDCS )
C
C buoyancy term
C
      FAC   = CH
      ICMP  = 3
      ICMPO = 2
      CALL AMTA( NR, INARR, MHT, MHL, MHM, MHP, ICMP,
     1           MHTR, MHL, MHM, ICMPO, FAC, ILNTOR, IRNTOR, A,
     2           N1, N2, IMF, KL, KL, KLE, NDRVS, NDRVM, NCFM,
     3           NDCS, SVFDC, XARR, NBN )
C
C heat source terms
C
      FAC = 1.0d0
      CALL AMHST( NR, INARR, MHT, MHL, MHM, MHP, MHTR,
     1            MHL, MHM, FAC, NBN, NDRVS, NDRVM, ILNTHE, IRNTHE,
     2            XARR, NCFM, SVFDC, A, N1, N2, CB1, CB2,
     3            IMF, KL, KL, KLE, NDCS )
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Recalled coefficient Velocity_0 cross Curl Velocity Add *
C            -                    -        -       -    -        -   *
C Steve Gibbons Tue Jan 18 09:22:22 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Subtracts the v_0 x curl v  terms from the matrix for solving      C
C the vorticity equation. The v_0 terms are contained in a vector    C
C VEC0 which has the same grid spacing as that in the matrix         C
C (NR grid points defined by the array XARR).                        C
C                                                                    C
C Unlike IV0CVA which evaluates the vector interactions in situ,     C
C RV0CVA searches through the arrays IHNALP, IHNBET, IHNGAM and TVHI C
C (as pre-calculated by VCCPCC) with the help of VICEXR for          C
C the non-zero interactions.                                         C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ).               C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     ILNRP     : First radial node to act on.                       C
C                  when contributing to the poloidal vorticity eqn.s C
C     IRNRP     : Last radial node to act on.                        C
C                  when contributing to the poloidal vorticity eqn.s C
C     ILNRT     : First radial node to act on.                       C
C                  when contributing to the toroidal vorticity eqn.s C
C     IRNRT     : Last radial node to act on.                        C
C                  when contributing to the toroidal vorticity eqn.s C
C                                                                    C
C     INI       : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INI( 1 ) = IFORMF                                  C
C                 INI( 2 ) = NRR      See INDFUN for details         C
C                 INI( 3 ) = NH                                      C
C                                                                    C
C     MTI      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to input vec.)    C
C     MLI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MPI      : Array length ( * ) - atleast length NHI             C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MTO      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to output vec.)   C
C     MLO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     IN0       : Int. parameter array corresponding to VEC0.        C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 IN0( 1 ) = IFORM0                                  C
C                 IN0( 2 ) = NR0      See INDFUN for details         C
C                 IN0( 3 ) = NH0                                     C
C                                                                    C
C     MT0      : Array length ( * ) - atleast length NH0             C
C                  See above for key. (corresponds to VEC0).         C
C     ML0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. degree, l.                             C
C     MM0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MP0      : Array length ( * ) - atleast length NH0             C
C                  Pointer array to finite difference coefficients.  C
C                  MP0( ih ) = is, which is the 4th index of         C
C                  array SVFDC0 - indicates f.d. scheme used.        C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NBN0      : Number of nodes on each side of point for          C
C                  central differences in VEC0.                      C
C                                                                    C
C     NDCS0     : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC0.                       C
C     NDRVS0    : Highest derivative stored in SVFDC0.               C
C     NDRVM0    : Limit on NDRVS0. Array bound for SVFDC0.           C
C                                                                    C
C     NFDCM0    : Leading dim of SVFDC0. See SVFDCF0.                C
C                  (Must be atleast 2*NBN0 + 1 )                     C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     IHNALP   : Number of alpha harmonics. Dim ( * )                C
C     IHNBET   : Number of beta harmonics. Dim ( * )                 C
C     IHNGAM   : Number of gamma harmonics. Dim ( * )                C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of v0. grad Theta to be added.          C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     VEC0      : Dim ( * ). Vector containing v0.                   C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM , NR, NDRVM +1, NDCS  ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     SVFDC0    : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM0, NR, NDRVM0+1, NDCS0 ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     CVI       : Coefficients of vector interaction. Dim ( * )      C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. ( * )        C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RV0CVA( NR, N1, N2, KL, KU, KLE, IMF, ILNRP, IRNRP,
     1    ILNRT, IRNRT, INI, MTI, MLI, MMI, MPI, MTO, MLO, MMO, IN0,
     2    MT0, ML0, MM0, MP0, NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0,
     3    NDCS0, NDRVS0, NDRVM0, NFDCM0, A, FAC, XARR, VEC0, SVFDC,
     4    SVFDC0, NVI, IHNALP, IHNBET, IHNGAM, TVHI, CVI )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, N1, N2, KL, KU, KLE, IMF, ILNRP, IRNRP, ILNRT,
     1        IRNRT, INI( * ), MTI( * ), MLI( * ), MMI( * ), MPI( * ),
     2        MTO( * ), MLO( * ), MMO( * ), IN0( * ), MT0( * ),
     3        ML0( * ), MM0( * ), MP0( * )
      INTEGER NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0, NDCS0, NDRVS0,
     1        NDRVM0, NFDCM0, NVI, IHNALP( * ), IHNBET( * ), 
     2        IHNGAM( * )
      CHARACTER *(4) TVHI( * )
      DOUBLE PRECISION A( N1, N2 ), FAC, XARR( NR ), VEC0( * ),
     1                 SVFDC( NFDCM , NR, NDRVM +1, NDCS  ),
     2                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 ),
     3                 CVI( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHA, IHB, IHG, LA, LB, LG, MA, MB, MG, ICSA, ICSB,
     1        ICSG, IQSTA, IQSTB, IQSTG, IOLDF, IHD, IHD0,
     2        IPARS( 7 ), NHA, NHB, NHG, INDG, INDSHC, IS, IS0,
     3        INDA, INDB
C     .
C     . ioldf = 1 --> existing alpha function, new beta function
C     .
      PARAMETER ( IOLDF = 1 )
C     .
      DOUBLE PRECISION DPARS( 1 ), LOW, WORK( 6 ),
     1                 CQTS, CQTT, CQSS, CQST, CSTQ, CSQS,
     2                 CSQT, CSSQ, CTTQ, CTQS, CTQT, CTSQ
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL INVCVT
      CHARACTER *(4) REQVIT
      LOGICAL ONZIC
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NHA = IN0( 3 )
      NHB = INI( 3 )
      NHG = INI( 3 )
C     .
C     . Early exit with zero value of multiplier
C     .
      IF ( DABS( FAC ).LT.LOW ) RETURN
C     .
C     . IHA is the 'alpha' harmonic.
C     . This is the velocity.
C     . In this case the velocity is in the VEC0
C     . vector and so loop around IHA from 1 to NH0
C     .
      DO IHA = 1, NHA
C       .
C       . Consider the case of alpha poloidal
C       .
        IF ( MT0( IHA ).EQ.1 ) THEN
          LA = ML0( IHA )
          IF ( MM0( IHA ).LT.0 ) THEN
            MA   = -MM0( IHA )
            ICSA = 2
          ELSE
            MA   = MM0( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS0    = MP0( IHA )
C         .
          IQSTA = 1
C         .
C         . Now loop IHB around harmonics in solution vector
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MTI( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLI( IHB )
              IF ( MMI( IHB ).LT.0 ) THEN
                MB   = -MMI( IHB )
                ICSB = 2
              ELSE
                MB   = MMI( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS     = MPI( IHB )
C             .
              IQSTB = 3
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{qts}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CQTS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQTS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 3
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CQTS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{qtt}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CQTT'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQTT, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 2
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CQTT
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           .
C           . Case of beta toroidal
C           .
            IF ( MTI( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLI( IHB )
              IF ( MMI( IHB ).LT.0 ) THEN
                MB   = -MMI( IHB )
                ICSB = 2
              ELSE
                MB   = MMI( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS     = MPI( IHB )
C             .
              IQSTB = 2
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{qss}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CQSS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQSS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 2
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CQSS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{qst}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CQST'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQST, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CQST
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end ihb = 1, nhb)
C         .
          IQSTA = 2
C         .
C         . Now loop IHB around harmonics in solution vector
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MTI( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLI( IHB )
              IF ( MMI( IHB ).LT.0 ) THEN
                MB   = -MMI( IHB )
                ICSB = 2
              ELSE
                MB   = MMI( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS     = MPI( IHB )
C             .
              IQSTB = 3
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{stq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CSTQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSTQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 2
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CSTQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           . Case of beta toroidal
C           .
            IF ( MTI( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLI( IHB )
              IF ( MMI( IHB ).LT.0 ) THEN
                MB   = -MMI( IHB )
                ICSB = 2
              ELSE
                MB   = MMI( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS     = MPI( IHB )
C             .
              IQSTB = 1
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{sqs}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CSQS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSQS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 2
C                 .
                  DPARS( 1 ) = CSQS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{sqt}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CSQT'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSQT, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CSQT
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
              IQSTB = 2
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{ssq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CSSQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSSQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CSSQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end loop ihb = 1, nhb)
C         .
        ENDIF
C       .
C       . Consider the case of alpha toroidal
C       .
        IF ( MT0( IHA ).EQ.2 ) THEN
          LA = ML0( IHA )
          IF ( MM0( IHA ).LT.0 ) THEN
            MA   = -MM0( IHA )
            ICSA = 2
          ELSE
            MA   = MM0( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS0    = MP0( IHA )
C         .
          IQSTA = 3
C         .
C         . Now loop IHB around harmonics in solution vector
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MTI( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLI( IHB )
              IF ( MMI( IHB ).LT.0 ) THEN
                MB   = -MMI( IHB )
                ICSB = 2
              ELSE
                MB   = MMI( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS     = MPI( IHB )
C             .
              IQSTB = 3
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{ttq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CTTQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTTQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 2
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CTTQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           .
C           . Case of beta toroidal
C           .
            IF ( MTI( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = MLI( IHB )
              IF ( MMI( IHB ).LT.0 ) THEN
                MB   = -MMI( IHB )
                ICSB = 2
              ELSE
                MB   = MMI( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS     = MPI( IHB )
C             .
              IQSTB = 1
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{tqs}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CTQS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTQS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CTQS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{tqt}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CTQT'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTQT, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CTQT
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
              IQSTB = 2
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{tsq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CTSQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTSQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CTSQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHA, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end ihb = 1, nhb)
C         .
        ENDIF
C       .
      ENDDO
C     (end loop iha = 1, nha)
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Recalled coefficient Velocity cross Curl Velocity_0 Add *
C            -                    -        -     -    -        - -   *
C Steve Gibbons Tue Jan 18 09:22:22 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Subtracts the v x curl v_0  terms from the matrix for solving      C
C the vorticity equation. The v_0 terms are contained in a vector    C
C VEC0 which has the same grid spacing as that in the matrix         C
C (NR grid points defined by the array XARR).                        C
C                                                                    C
C Unlike IVCV0A which evaluates the vector interactions in situ,     C
C RVCV0A searches through the arrays IHNALP, IHNBET, IHNGAM and TVHI C
C (as pre-calculated by VCCPCC) with the help of VICEXR for          C
C the non-zero interactions.                                         C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ).               C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     ILNRP     : First radial node to act on.                       C
C                  when contributing to the poloidal vorticity eqn.s C
C     IRNRP     : Last radial node to act on.                        C
C                  when contributing to the poloidal vorticity eqn.s C
C     ILNRT     : First radial node to act on.                       C
C                  when contributing to the toroidal vorticity eqn.s C
C     IRNRT     : Last radial node to act on.                        C
C                  when contributing to the toroidal vorticity eqn.s C
C                                                                    C
C     INI       : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INI( 1 ) = IFORMF                                  C
C                 INI( 2 ) = NRR      See INDFUN for details         C
C                 INI( 3 ) = NH                                      C
C                                                                    C
C     MTI      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to input vec.)    C
C     MLI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MPI      : Array length ( * ) - atleast length NHI             C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MTO      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to output vec.)   C
C     MLO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     IN0       : Int. parameter array corresponding to VEC0.        C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 IN0( 1 ) = IFORM0                                  C
C                 IN0( 2 ) = NR0      See INDFUN for details         C
C                 IN0( 3 ) = NH0                                     C
C                                                                    C
C     MT0      : Array length ( * ) - atleast length NH0             C
C                  See above for key. (corresponds to VEC0).         C
C     ML0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. degree, l.                             C
C     MM0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MP0      : Array length ( * ) - atleast length NH0             C
C                  Pointer array to finite difference coefficients.  C
C                  MP0( ih ) = is, which is the 4th index of         C
C                  array SVFDC0 - indicates f.d. scheme used.        C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NBN0      : Number of nodes on each side of point for          C
C                  central differences in VEC0.                      C
C                                                                    C
C     NDCS0     : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC0.                       C
C     NDRVS0    : Highest derivative stored in SVFDC0.               C
C     NDRVM0    : Limit on NDRVS0. Array bound for SVFDC0.           C
C                                                                    C
C     NFDCM0    : Leading dim of SVFDC0. See SVFDCF0.                C
C                  (Must be atleast 2*NBN0 + 1 )                     C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     IHNALP   : Number of alpha harmonics. Dim ( * )                C
C     IHNBET   : Number of beta harmonics. Dim ( * )                 C
C     IHNGAM   : Number of gamma harmonics. Dim ( * )                C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of v0. grad Theta to be added.          C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     VEC0      : Dim ( * ). Vector containing v0.                   C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM , NR, NDRVM +1, NDCS  ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     SVFDC0    : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM0, NR, NDRVM0+1, NDCS0 ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     CVI       : Coefficients of vector interaction. Dim ( * )      C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. ( * )        C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RVCV0A( NR, N1, N2, KL, KU, KLE, IMF, ILNRP, IRNRP,
     1    ILNRT, IRNRT, INI, MTI, MLI, MMI, MPI, MTO, MLO, MMO, IN0,
     2    MT0, ML0, MM0, MP0, NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0,
     3    NDCS0, NDRVS0, NDRVM0, NFDCM0, A, FAC, XARR, VEC0, SVFDC,
     4    SVFDC0, NVI, IHNALP, IHNBET, IHNGAM, TVHI, CVI )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, N1, N2, KL, KU, KLE, IMF, ILNRP, IRNRP, ILNRT,
     1        IRNRT, INI( * ), MTI( * ), MLI( * ), MMI( * ),
     2        MPI( * ), MTO( * ), MLO( * ), MMO( * ), IN0( * ),
     3        MT0( * ), ML0( * ), MM0( * ), MP0( * )
      INTEGER NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0, NDCS0, NDRVS0,
     1        NDRVM0, NFDCM0, NVI, IHNALP( * ), IHNBET( * ),
     2        IHNGAM( * )
      CHARACTER *(4) TVHI( * )
      DOUBLE PRECISION A( N1, N2 ), FAC, XARR( NR ), VEC0( * ),
     1                 SVFDC( NFDCM , NR, NDRVM +1, NDCS  ),
     2                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 ),
     3                 CVI( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHA, IHB, IHG, LA, LB, LG, MA, MB, MG, ICSA, ICSB,
     1        ICSG, IQSTA, IQSTB, IQSTG, IOLDF, IHD, IHD0,
     2        IPARS( 7 ), NHA, NHB, NHG, INDG, INDSHC, IS, IS0,
     3        INDA, INDB
C     .
C     . ioldf = 2 --> new alpha function, existing beta function
C     .
      PARAMETER ( IOLDF = 2 )
C     .
      DOUBLE PRECISION DPARS( 1 ), LOW, WORK( 6 ),
     1                 CQTS, CQTT, CQSS, CQST, CSTQ, CSQS,
     2                 CSQT, CSSQ, CTTQ, CTQS, CTQT, CTSQ
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL INVCVT
      CHARACTER *(4) REQVIT
      LOGICAL ONZIC
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NHA = INI( 3 )
      NHB = IN0( 3 )
      NHG = INI( 3 )
C     .
C     . Early exit with zero value of multiplier
C     .
      IF ( DABS( FAC ).LT.LOW ) RETURN
C     .
C     . IHA is the 'alpha' harmonic.
C     . This is the velocity.
C     . In this case the velocity is in matrix solution
C     . vector and so loop around IHA from 1 to NHI
C     .
      DO IHA = 1, NHA
C       .
C       . Consider the case of alpha poloidal
C       .
        IF ( MTI( IHA ).EQ.1 ) THEN
          LA = MLI( IHA )
          IF ( MMI( IHA ).LT.0 ) THEN
            MA   = -MMI( IHA )
            ICSA = 2
          ELSE
            MA   = MMI( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS     = MPI( IHA )
C         .
          IQSTA = 1
C         .
C         . Now loop IHB around harmonics in VEC0
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MT0( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = ML0( IHB )
              IF ( MM0( IHB ).LT.0 ) THEN
                MB   = -MM0( IHB )
                ICSB = 2
              ELSE
                MB   = MM0( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS0    = MP0( IHB )
C             .
              IQSTB = 3
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{qts}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CQTS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQTS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 3
C                 .
                  DPARS( 1 ) = CQTS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{qtt}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CQTT'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQTT, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 2
C                 .
                  DPARS( 1 ) = CQTT
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           .
C           . Case of beta toroidal
C           .
            IF ( MT0( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = ML0( IHB )
              IF ( MM0( IHB ).LT.0 ) THEN
                MB   = -MM0( IHB )
                ICSB = 2
              ELSE
                MB   = MM0( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS0    = MP0( IHB )
C             .
              IQSTB = 2
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{qss}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CQSS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQSS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 2
C                 .
                  DPARS( 1 ) = CQSS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{qst}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CQST'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CQST, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CQST
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end ihb = 1, nhb)
C         .
          IQSTA = 2
C         .
C         . Now loop IHB around harmonics in VEC0
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MT0( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = ML0( IHB )
              IF ( MM0( IHB ).LT.0 ) THEN
                MB   = -MM0( IHB )
                ICSB = 2
              ELSE
                MB   = MM0( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS0    = MP0( IHB )
C             .
              IQSTB = 3
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{stq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CSTQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSTQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
C                 .
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 2
C                 .
                  DPARS( 1 ) = CSTQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           . Case of beta toroidal
C           .
            IF ( MT0( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = ML0( IHB )
              IF ( MM0( IHB ).LT.0 ) THEN
                MB   = -MM0( IHB )
                ICSB = 2
              ELSE
                MB   = MM0( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS0    = MP0( IHB )
C             .
              IQSTB = 1
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{sqs}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CSQS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSQS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 2
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CSQS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{sqt}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CSQT'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSQT, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CSQT
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
              IQSTB = 2
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{ssq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CSSQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CSSQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CSSQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end loop ihb = 1, nhb)
C         .
        ENDIF
C       .
C       . Consider the case of alpha toroidal
C       .
        IF ( MTI( IHA ).EQ.2 ) THEN
          LA = MLI( IHA )
          IF ( MMI( IHA ).LT.0 ) THEN
            MA   = -MMI( IHA )
            ICSA = 2
          ELSE
            MA   = MMI( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS     = MPI( IHA )
C         .
          IQSTA = 3
C         .
C         . Now loop IHB around harmonics in VEC0
C         .
          DO IHB = 1, NHB
C           .
C           . Case of beta poloidal
C           .
            IF ( MT0( IHB ).EQ.1 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = ML0( IHB )
              IF ( MM0( IHB ).LT.0 ) THEN
                MB   = -MM0( IHB )
                ICSB = 2
              ELSE
                MB   = MM0( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS0    = MP0( IHB )
C             .
              IQSTB = 3
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{ttq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CTTQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTTQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 2
C                 .
                  DPARS( 1 ) = CTTQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
C           .
C           . Case of beta toroidal
C           .
            IF ( MT0( IHB ).EQ.2 ) THEN
C             .
C             . Calculate indices of velocity harm. beta
C             .
              LB = ML0( IHB )
              IF ( MM0( IHB ).LT.0 ) THEN
                MB   = -MM0( IHB )
                ICSB = 2
              ELSE
                MB   = MM0( IHB )
                ICSB = 1
              ENDIF
              INDB   = INDSHC( LB, MB, ICSB )
C             .
              IS0    = MP0( IHB )
C             .
C             . Evaluate q_{beta} in VF2
C             .
              IQSTB = 1
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{tqs}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CTQS'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTQS, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 2
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 1
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CTQS
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
C               . Case of Gamma poloidal
C               . See if we have C_{tqt}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.1 ) THEN
                  REQVIT = 'CTQT'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTQT, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 3
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 0
C                 .
                  DPARS( 1 ) = CTQT
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRP, IRNRP, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
              IQSTB = 2
C             .
C             . Loop around output harmonics
C             .
              DO IHG = 1, NHG
                LG = MLO( IHG )
                IF ( MMO( IHG ).LT.0 ) THEN
                  MG   = -MMO( IHG )
                  ICSG = 2
                ELSE
                  MG   = MMO( IHG )
                  ICSG = 1
                ENDIF
C               .
                INDG   = INDSHC( LG, MG, ICSG )
C               .
C               . Case of Gamma toroidal
C               . See if we have C_{tsq}^{abg} interaction
C               .
                IF ( MTO( IHG ).EQ.2 ) THEN
                  REQVIT = 'CTSQ'
                  CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                   INDB, INDG, TVHI, REQVIT, CVI, CTSQ, ONZIC )
C                 .
                  IF ( ONZIC ) THEN
C                 .
                  IQSTG = 1
                  IPARS( 1 ) = IQSTA
                  IPARS( 2 ) = IQSTB
                  IPARS( 3 ) = IQSTG
                  IPARS( 4 ) = IOLDF
                  IPARS( 5 ) = LA
                  IPARS( 6 ) = LB
                  IPARS( 7 ) = LG
C                 .
                  IHD        = 0
                  IHD0       = 1
C                 .
                  DPARS( 1 ) = CTSQ
C                 .
                  CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG,
     1      INI, IHD, NBN, ILNRT, IRNRT, NFDCM, NR, NDCS, IS, NDRVS,
     2      NDRVM, IPARS, INVCVT, A, FAC, XARR, WORK, DPARS, SVFDC,
     3      IHB, IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0,
     4      VEC0, NFDCM0, SVFDC0 )
C                 .
                  ENDIF
                ENDIF
C               .
              ENDDO
C             (end loop ihg = 1, nhg)
C             .
            ENDIF
C           .
          ENDDO
C         (end ihb = 1, nhb)
C         .
        ENDIF
C       .
      ENDDO
C     (end loop iha = 1, nha)
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Recalled coefficient Velocity_0 . Gradient of Theta Add *
C            -                    -        -   -           -     -   *
C Steve Gibbons Tue Nov 23 07:51:01 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds the v_0 . \nabla Theta terms to the matrix for solving        C
C the heat equation. The v_0 terms are contained in a vector         C
C VEC0 which has the same grid spacing as that in the matrix         C
C (NR grid points defined by the array XARR).                        C
C                                                                    C
C Unlike IV0GTA which evaluates the vector interactions in situ,     C
C RV0GTA searches through the arrays IHNALP, IHNBET, IHNGAM and TVHI C
C (as pre-calculated by VSPCC) with the help of VICEXR for           C
C the non-zero interactions.                                         C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ).               C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     ILN       : Left-most node at which to start adding rows to    C
C                   matrix.                                          C
C     IRN       : Right-most node at which to start adding rows to   C
C                   matrix.                                          C
C                                                                    C
C     INI       : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INI( 1 ) = IFORMF                                  C
C                 INI( 2 ) = NRR      See INDFUN for details         C
C                 INI( 3 ) = NH                                      C
C                                                                    C
C     MTI      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to input vec.)    C
C     MLI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MPI      : Array length ( * ) - atleast length NHI             C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MTO      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to output vec.)   C
C     MLO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     IN0       : Int. parameter array corresponding to VEC0.        C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 IN0( 1 ) = IFORM0                                  C
C                 IN0( 2 ) = NR0      See INDFUN for details         C
C                 IN0( 3 ) = NH0                                     C
C                                                                    C
C     MT0      : Array length ( * ) - atleast length NH0             C
C                  See above for key. (corresponds to VEC0).         C
C     ML0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. degree, l.                             C
C     MM0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MP0      : Array length ( * ) - atleast length NH0             C
C                  Pointer array to finite difference coefficients.  C
C                  MP0( ih ) = is, which is the 4th index of         C
C                  array SVFDC0 - indicates f.d. scheme used.        C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NBN0      : Number of nodes on each side of point for          C
C                  central differences in VEC0.                      C
C                                                                    C
C     NDCS0     : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC0.                       C
C     NDRVS0    : Highest derivative stored in SVFDC0.               C
C     NDRVM0    : Limit on NDRVS0. Array bound for SVFDC0.           C
C                                                                    C
C     NFDCM0    : Leading dim of SVFDC0. See SVFDCF0.                C
C                  (Must be atleast 2*NBN0 + 1 )                     C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     IHNALP   : Number of alpha harmonics. Dim ( * )                C
C     IHNBET   : Number of beta harmonics. Dim ( * )                 C
C     IHNGAM   : Number of gamma harmonics. Dim ( * )                C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of v0. grad Theta to be added.          C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     VEC0      : Dim ( * ). Vector containing v0.                   C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM , NR, NDRVM +1, NDCS  ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     SVFDC0    : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM0, NR, NDRVM0+1, NDCS0 ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     CVI       : Coefficients of vector interaction. Dim ( * )      C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. ( * )        C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RV0GTA( NR, N1, N2, KL, KU, KLE, IMF, ILN, IRN, INI,
     1    MTI, MLI, MMI, MPI, MTO, MLO, MMO, IN0, MT0, ML0, MM0, MP0,
     2    NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0, NDCS0, NDRVS0, NDRVM0, 
     3    NFDCM0, A, FAC, XARR, VEC0, SVFDC, SVFDC0, 
     4    NVI, IHNALP, IHNBET, IHNGAM, TVHI, CVI )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, N1, N2, KL, KU, KLE, IMF, ILN, IRN, INI( * ),
     1        MTI( * ), MLI( * ), MMI( * ), MPI( * ), MTO( * ), 
     2        MLO( * ), MMO( * ), IN0( * ), MT0( * ), ML0( * ),
     3        MM0( * ), MP0( * )
      INTEGER NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0, NDCS0, NDRVS0,
     1        NDRVM0, NFDCM0, NVI, IHNALP( * ), IHNBET( * ),
     2        IHNGAM( * )
      CHARACTER *(4) TVHI( * )
      DOUBLE PRECISION A( N1, N2 ), FAC, XARR( NR ), VEC0( * ),
     1                 SVFDC( NFDCM , NR, NDRVM +1, NDCS  ),
     2                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 ),
     3                 CVI( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHA, IHB, IHG, LA, LB, LG, MA, MB, MG, ICSA, ICSB,
     1        ICSG, IQSTA, IQSTB, IOLDF, IHD, IHD0, IPARS( 5 ),
     2        NHA, NHB, NHG, INDG, INDSHC, IS, IS0, INDA, INDB
C     .
C     . ioldf = 1 --> existing velocity function: new temp. func.
C     .
      PARAMETER ( IOLDF = 1 )
C     .
      DOUBLE PRECISION DPARS( 1 ), LOW, SQQ, SSS, STS,
     1                 WORK( 6 )
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL INVGTT
      CHARACTER *(4) REQVIT
      LOGICAL ONZIC
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      NHA = IN0( 3 )
      NHB = INI( 3 )
      NHG = INI( 3 )
C     .
C     . Early exit with zero value of multiplier
C     .
      IF ( DABS( FAC ).LT.LOW ) RETURN
C     .
C     . IHA is the 'alpha' harmonic.
C     . This is the velocity.
C     . In this case the velocity is in VEC0 and so
C     . loop around IHA from 1 to NH0
C     .
      DO IHA = 1, NHA
C       .
C       . Go onto next alpha harmonic if it is not a velocity term
C       .
        IF ( MT0( IHA ).NE.1 .AND. MT0( IHA ).NE.2 ) GOTO 50
C       .
C       . Consider the case of alpha poloidal
C       .
        IF ( MT0( IHA ).EQ.1 ) THEN
          LA = ML0( IHA )
          IF ( MM0( IHA ).LT.0 ) THEN
            MA   = -MM0( IHA )
            ICSA = 2
          ELSE
            MA   = MM0( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS0    = MP0( IHA )
C         .
          IQSTA = 1
C         .
C         . Now loop IHB around harmonics in solution
C         . vector and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MTI( IHB ).NE.3 ) GOTO 51
C           .
C           . Calculate indices of temperature harm. beta
C           .
            LB = MLI( IHB )
            IF ( MMI( IHB ).LT.0 ) THEN
              MB   = -MMI( IHB )
              ICSB = 2
            ELSE
              MB   = MMI( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IS     = MPI( IHB )
C           .
            IQSTB = 1
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTO( IHG ).NE.3 ) GOTO 52
C             .
              LG = MLO( IHG )
              IF ( MMO( IHG ).LT.0 ) THEN
                MG   = -MMO( IHG )
                ICSG = 2
              ELSE
                MG   = MMO( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              REQVIT = 'SPQQ'
              CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                INDB, INDG, TVHI, REQVIT, CVI, SQQ, ONZIC )
C             .
              IF ( .NOT. ONZIC ) GOTO 52
C             .
C             . OK - we have an S^{abg}_{qq} interaction
C             .
              IHD  = 1
              IHD0 = 0
C             .
              DPARS( 1 ) = SQQ
C             .
              IPARS( 1 ) = IQSTA
              IPARS( 2 ) = IQSTB
              IPARS( 3 ) = IOLDF
              IPARS( 4 ) = LA
              IPARS( 5 ) = LB
C             .
              CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG, INI,
     1      IHD, NBN, ILN, IRN, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, INVGTT, A, FAC, XARR, WORK, DPARS, SVFDC, IHA,
     3      IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
C             .
 52         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 52)
C           (if dabs( sqq ).lt.low ) goto 52)
            ENDDO
C           .
 51       CONTINUE
C         (if mti( ihb ).ne.3 ) goto 51)
          ENDDO
C         .
          IQSTA = 2
C         .
C         . Now loop IHB around harmonics in solution
C         . vector and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MTI( IHB ).NE.3 ) GOTO 53
C           .
C           . Also go on to next harmonic if this is the
C           . monopole. This is because we will evaluate
C           . s_{beta} in VF2 which is ofcourse zero for
C           . l = 0.
C           .
            LB = MLI( IHB )
            IF ( LB.EQ.0 ) GOTO 53
C           .
C           . Calculate indices of temperature harm. beta
C           .
            IF ( MMI( IHB ).LT.0 ) THEN
              MB   = -MMI( IHB )
              ICSB = 2
            ELSE
              MB   = MMI( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IS     = MPI( IHB )
C           .
            IQSTB = 2
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTO( IHG ).NE.3 ) GOTO 54
C             .
              LG = MLO( IHG )
              IF ( MMO( IHG ).LT.0 ) THEN
                MG   = -MMO( IHG )
                ICSG = 2
              ELSE
                MG   = MMO( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              REQVIT = 'SPSS'
              CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                INDB, INDG, TVHI, REQVIT, CVI, SSS, ONZIC )
C             .
              IF ( .NOT. ONZIC ) GOTO 54
C             .
C             . OK - we have an S^{abg}_{ss} interaction
C             .
              IHD  = 0
              IHD0 = 1
C             .
              DPARS( 1 ) = SSS
C             .
              IPARS( 1 ) = IQSTA
              IPARS( 2 ) = IQSTB
              IPARS( 3 ) = IOLDF
              IPARS( 4 ) = LA
              IPARS( 5 ) = LB
C             .
              CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG, INI,
     1      IHD, NBN, ILN, IRN, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, INVGTT, A, FAC, XARR, WORK, DPARS, SVFDC, IHA,
     3      IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
C             .
 54         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 54)
C           (if dabs( sss ).lt.low ) goto 54)
            ENDDO
C           .
 53       CONTINUE
C         (if mti( ihb ).ne.3 ) goto 53)
C         (if lb.eq.0 ) goto 53)
          ENDDO
C         .
        ENDIF
C       .
C       . Consider the case of alpha toroidal
C       .
        IF ( MT0( IHA ).EQ.2 ) THEN
          LA = ML0( IHA )
          IF ( MM0( IHA ).LT.0 ) THEN
            MA   = -MM0( IHA )
            ICSA = 2
          ELSE
            MA   = MM0( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS0    = MP0( IHA )
C         .
          IQSTA = 3
C         .
C         . Now loop IHB around harmonics in solution
C         . vector and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MTI( IHB ).NE.3 ) GOTO 55
C           .
C           . Also go on to next harmonic if this is the
C           . monopole. This is because we will evaluate
C           . s_{beta} in VF2 which is ofcourse zero for
C           . l = 0.
C           .
            LB = MLI( IHB )
            IF ( LB.EQ.0 ) GOTO 55
C           .
C           . Calculate indices of temperature harm. beta
C           .
            IF ( MMI( IHB ).LT.0 ) THEN
              MB   = -MMI( IHB )
              ICSB = 2
            ELSE
              MB   = MMI( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IS     = MPI( IHB )
C           .
            IQSTB = 2
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTO( IHG ).NE.3 ) GOTO 56
C             .
              LG = MLO( IHG )
              IF ( MMO( IHG ).LT.0 ) THEN
                MG   = -MMO( IHG )
                ICSG = 2
              ELSE
                MG   = MMO( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              REQVIT = 'SPTS'
              CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                INDB, INDG, TVHI, REQVIT, CVI, STS, ONZIC )
C             .
              IF ( .NOT. ONZIC ) GOTO 56
C             .
C             . OK - we have an S^{abg}_{ts} interaction
C             .
              IHD  = 0
              IHD0 = 0
C             .
              DPARS( 1 ) = STS
C             .
              IPARS( 1 ) = IQSTA
              IPARS( 2 ) = IQSTB
              IPARS( 3 ) = IOLDF
              IPARS( 4 ) = LA
              IPARS( 5 ) = LB
C             .
              CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHB, IHG, INI,
     1      IHD, NBN, ILN, IRN, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, INVGTT, A, FAC, XARR, WORK, DPARS, SVFDC, IHA,
     3      IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
C             .
 56         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 56)
C           (if dabs( sts ).lt.low ) goto 56)
            ENDDO
C           .
 55       CONTINUE
C         (if mti( ihb ).ne.3 ) goto 55)
C         (if lb.eq.0 ) goto 55)
          ENDDO
C         .
        ENDIF
C       .
 50   CONTINUE
C     ( if mt0( iha ).ne.1 .and. mt0( iha ).ne.2 ) goto 50 )
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Recalled coef. Velocity . Gradient of Inhomogeneous     *
C            -              -          -           -                 *
C                                                  temperature_0 Add *
C                                                              - -   *
C Steve Gibbons Wed Jan 19 10:19:07 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Adds the v . \nabla T_0 terms to the matrix for solving            C
C the heat equation. The v_0 terms are contained in a vector         C
C VEC0 which has the same grid spacing as that in the matrix         C
C (NR grid points defined by the array XARR).                        C
C                                                                    C
C Unlike IVGT0A which evaluates the vector interactions in situ,     C
C RVGI0A searches through the arrays IHNALP, IHNBET, IHNGAM and TVHI C
C (as pre-calculated by VSPCC) with the help of VICEXR for           C
C the non-zero interactions.                                         C
C                                                                    C
C In addition to Theta, the inhomogeneous temperature function is    C
C added by the use of the routine INVGIT as opposed to INVGTT.       C
C                                                                    C
C The inhomog. temp. coef.s are passed in through the array CAFIT    C
C (see ITHCAR) and the indices are passed in by the array MI0.       C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NR        : Number of radial grid nodes.                       C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ).               C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     ILN       : Left-most node at which to start adding rows to    C
C                   matrix.                                          C
C     IRN       : Right-most node at which to start adding rows to   C
C                   matrix.                                          C
C                                                                    C
C     INI       : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INI( 1 ) = IFORMF                                  C
C                 INI( 2 ) = NRR      See INDFUN for details         C
C                 INI( 3 ) = NH                                      C
C                                                                    C
C     MTI      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to input vec.)    C
C     MLI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MPI      : Array length ( * ) - atleast length NHI             C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MTO      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to output vec.)   C
C     MLO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMO      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     IN0       : Int. parameter array corresponding to VEC0.        C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 IN0( 1 ) = IFORM0                                  C
C                 IN0( 2 ) = NR0      See INDFUN for details         C
C                 IN0( 3 ) = NH0                                     C
C                                                                    C
C     MT0      : Array length ( * ) - atleast length NH0             C
C                  See above for key. (corresponds to VEC0).         C
C     ML0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. degree, l.                             C
C     MM0      : Array length ( * ) - atleast length NH0             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MP0      : Array length ( * ) - atleast length NH0             C
C                  Pointer array to finite difference coefficients.  C
C                  MP0( ih ) = is, which is the 4th index of         C
C                  array SVFDC0 - indicates f.d. scheme used.        C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NBN0      : Number of nodes on each side of point for          C
C                  central differences in VEC0.                      C
C                                                                    C
C     NDCS0     : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC0.                       C
C     NDRVS0    : Highest derivative stored in SVFDC0.               C
C     NDRVM0    : Limit on NDRVS0. Array bound for SVFDC0.           C
C                                                                    C
C     NFDCM0    : Leading dim of SVFDC0. See SVFDCF0.                C
C                  (Must be atleast 2*NBN0 + 1 )                     C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     IHNALP   : Number of alpha harmonics. Dim ( * )                C
C     IHNBET   : Number of beta harmonics. Dim ( * )                 C
C     IHNGAM   : Number of gamma harmonics. Dim ( * )                C
C                                                                    C
C     MI0      : Dim ( * ) - atleast atleast length NH0.             C
C                For each temperature harmonic, IH, MI0( IH ) gives  C
C                the index of the array CAFIT which stores the       C
C                coefficients for that radial function.              C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C                                                                    C
C                If MI0( IH ) = IITH, then CA, CB and CC are         C
C                respectively stored in CAFIT( 1, IITH ),            C
C                CAFIT( 2, IITH ) and CAFIT( 3, IITH ).              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of v0. grad Theta to be added.          C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     VEC0      : Dim ( * ). Vector containing v0.                   C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM , NR, NDRVM +1, NDCS  ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     SVFDC0    : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM0, NR, NDRVM0+1, NDCS0 ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     CVI       : Coefficients of vector interaction. Dim ( * )      C
C                                                                    C
C     CAFIT     : Dimension ( 3, * ). See MI0.                       C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. ( * )        C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RVGI0A( NR, N1, N2, KL, KU, KLE, IMF, ILN, IRN, INI,
     1    MTI, MLI, MMI, MPI, MTO, MLO, MMO, IN0, MT0, ML0, MM0, MP0,
     2    NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0, NDCS0, NDRVS0, NDRVM0, 
     3    NFDCM0, A, FAC, XARR, VEC0, SVFDC, SVFDC0,
     4    NVI, IHNALP, IHNBET, IHNGAM, TVHI, CVI, MI0, CAFIT )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, N1, N2, KL, KU, KLE, IMF, ILN, IRN, INI( * ),
     1        MTI( * ), MLI( * ), MMI( * ), MPI( * ), MTO( * ), 
     2        MLO( * ), MMO( * ), IN0( * ), MT0( * ), ML0( * ),
     3        MM0( * ), MP0( * )
      INTEGER NBN, NDCS, NDRVS, NDRVM, NFDCM, NBN0, NDCS0, NDRVS0,
     1        NDRVM0, NFDCM0, NVI, IHNALP( * ), IHNBET( * ),
     2        IHNGAM( * ), MI0( * )
      CHARACTER *(4) TVHI( * )
      DOUBLE PRECISION A( N1, N2 ), FAC, XARR( NR ), VEC0( * ),
     1                 SVFDC( NFDCM , NR, NDRVM +1, NDCS  ),
     2                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 ),
     3                 CVI( * ), CAFIT( 3, * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHA, IHB, IHG, LA, LB, LG, MA, MB, MG, ICSA, ICSB,
     1        ICSG, IQSTA, IQSTB, IOLDF, IHD, IHD0, IPARS( 5 ),
     2        NHA, NHB, NHG, INDG, INDSHC, IS, IS0, INDA, INDB,
     3        IITH
C     .
C     . ioldf = 2 --> new velocity function: existing temp. func.
C     .
      PARAMETER ( IOLDF = 2 )
C     .
      DOUBLE PRECISION DPARS( 6 ), LOW, SQQ, SSS, STS,
     1                 WORK( 6 ), RI, RO, CA, CB, CC
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL INVGIT
      CHARACTER *(4) REQVIT
      LOGICAL ONZIC
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      NHA = INI( 3 )
      NHB = IN0( 3 )
      NHG = INI( 3 )
C     .
      RI = XARR(  1 )
      RO = XARR( NR )
C     .
C     . Early exit with zero value of multiplier
C     .
      IF ( DABS( FAC ).LT.LOW ) RETURN
C     .
C     . IHA is the 'alpha' harmonic.
C     . This is the velocity.
C     . In this case the velocity is in matrix solution
C     . vector and so loop around IHA from 1 to NHI
C     .
      DO IHA = 1, NHA
C       .
C       . Go onto next alpha harmonic if it is not a velocity term
C       .
        IF ( MTI( IHA ).NE.1 .AND. MTI( IHA ).NE.2 ) GOTO 50
C       .
C       . Consider the case of alpha poloidal
C       .
        IF ( MTI( IHA ).EQ.1 ) THEN
          LA = MLI( IHA )
          IF ( MMI( IHA ).LT.0 ) THEN
            MA   = -MMI( IHA )
            ICSA = 2
          ELSE
            MA   = MMI( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS     = MPI( IHA )
C         .
          IQSTA = 1
C         .
C         . Now loop IHB around harmonics in
C         . VEC0 and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MT0( IHB ).NE.3 ) GOTO 51
C           .
C           . Calculate indices of temperature harm. beta
C           .
            LB = ML0( IHB )
            IF ( MM0( IHB ).LT.0 ) THEN
              MB   = -MM0( IHB )
              ICSB = 2
            ELSE
              MB   = MM0( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IITH   = MI0( IHB )
            CA     = CAFIT( 1, IITH )
            CB     = CAFIT( 2, IITH )
            CC     = CAFIT( 3, IITH )
C           .
            IS0    = MP0( IHB )
C           .
            IQSTB = 1
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTO( IHG ).NE.3 ) GOTO 52
C             .
              LG = MLO( IHG )
              IF ( MMO( IHG ).LT.0 ) THEN
                MG   = -MMO( IHG )
                ICSG = 2
              ELSE
                MG   = MMO( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              REQVIT = 'SPQQ'
              CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                INDB, INDG, TVHI, REQVIT, CVI, SQQ, ONZIC )
C             .
              IF ( .NOT. ONZIC ) GOTO 52
C             .
C             . OK - we have an S^{abg}_{qq} interaction
C             .
              IHD  = 0
              IHD0 = 1
C             .
              DPARS( 1 ) = SQQ
              DPARS( 2 ) = RI
              DPARS( 3 ) = RO
              DPARS( 4 ) = CA
              DPARS( 5 ) = CB
              DPARS( 6 ) = CC
C             .
              IPARS( 1 ) = IQSTA
              IPARS( 2 ) = IQSTB
              IPARS( 3 ) = IOLDF
              IPARS( 4 ) = LA
              IPARS( 5 ) = LB
C             .
              CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG, INI,
     1      IHD, NBN, ILN, IRN, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, INVGIT, A, FAC, XARR, WORK, DPARS, SVFDC, IHB,
     3      IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
C             .
 52         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 52)
C           (if dabs( sqq ).lt.low ) goto 52)
            ENDDO
C           .
 51       CONTINUE
C         (if mt0( ihb ).ne.3 ) goto 51)
          ENDDO
C         .
          IQSTA = 2
C         .
C         . Now loop IHB around harmonics in
C         . VEC0 and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MT0( IHB ).NE.3 ) GOTO 53
C           .
C           . Also go on to next harmonic if this is the
C           . monopole. This is because we will evaluate
C           . s_{beta} in VF2 which is ofcourse zero for
C           . l = 0.
C           .
            LB = ML0( IHB )
            IF ( LB.EQ.0 ) GOTO 53
C           .
C           . Calculate indices of temperature harm. beta
C           .
            IF ( MM0( IHB ).LT.0 ) THEN
              MB   = -MM0( IHB )
              ICSB = 2
            ELSE
              MB   = MM0( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IITH   = MI0( IHB )
            CA     = CAFIT( 1, IITH )
            CB     = CAFIT( 2, IITH )
            CC     = CAFIT( 3, IITH )
C           .
            IS0    = MP0( IHB )
C           .
            IQSTB = 2
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTO( IHG ).NE.3 ) GOTO 54
C             .
              LG = MLO( IHG )
              IF ( MMO( IHG ).LT.0 ) THEN
                MG   = -MMO( IHG )
                ICSG = 2
              ELSE
                MG   = MMO( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              REQVIT = 'SPSS'
              CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                INDB, INDG, TVHI, REQVIT, CVI, SSS, ONZIC )
C             .
              IF ( .NOT. ONZIC ) GOTO 54
C             .
C             . OK - we have an S^{abg}_{ss} interaction
C             .
              IHD  = 1
              IHD0 = 0
C             .
              DPARS( 1 ) = SSS
              DPARS( 2 ) = RI
              DPARS( 3 ) = RO
              DPARS( 4 ) = CA
              DPARS( 5 ) = CB
              DPARS( 6 ) = CC
C             .
              IPARS( 1 ) = IQSTA
              IPARS( 2 ) = IQSTB
              IPARS( 3 ) = IOLDF
              IPARS( 4 ) = LA
              IPARS( 5 ) = LB
C             .
              CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG, INI,
     1      IHD, NBN, ILN, IRN, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, INVGIT, A, FAC, XARR, WORK, DPARS, SVFDC, IHB,
     3      IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
C             .
 54         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 54)
C           (if dabs( sss ).lt.low ) goto 54)
            ENDDO
C           .
 53       CONTINUE
C         (if mt0( ihb ).ne.3 ) goto 53)
C         (if lb.eq.0 ) goto 53)
          ENDDO
C         .
        ENDIF
C       .
C       . Consider the case of alpha toroidal
C       .
        IF ( MTI( IHA ).EQ.2 ) THEN
          LA = MLI( IHA )
          IF ( MMI( IHA ).LT.0 ) THEN
            MA   = -MMI( IHA )
            ICSA = 2
          ELSE
            MA   = MMI( IHA )
            ICSA = 1
          ENDIF
          INDA   = INDSHC( LA, MA, ICSA )
C         .
          IS     = MPI( IHA )
C         .
          IQSTA = 3
C         .
C         . Now loop IHB around harmonics in
C         . VEC0 and for temperature
C         .
          DO IHB = 1, NHB
C           .
C           . Go onto next beta harmonic if it is not temperature
C           .
            IF ( MT0( IHB ).NE.3 ) GOTO 55
C           .
C           . Also go on to next harmonic if this is the
C           . monopole. This is because we will evaluate
C           . s_{beta} in VF2 which is ofcourse zero for
C           . l = 0.
C           .
            LB = ML0( IHB )
            IF ( LB.EQ.0 ) GOTO 55
C           .
C           . Calculate indices of temperature harm. beta
C           .
            IF ( MM0( IHB ).LT.0 ) THEN
              MB   = -MM0( IHB )
              ICSB = 2
            ELSE
              MB   = MM0( IHB )
              ICSB = 1
            ENDIF
            INDB   = INDSHC( LB, MB, ICSB )
C           .
            IITH   = MI0( IHB )
            CA     = CAFIT( 1, IITH )
            CB     = CAFIT( 2, IITH )
            CC     = CAFIT( 3, IITH )
C           .
            IS0    = MP0( IHB )
C           .
            IQSTB = 2
C           .
C           . Now loop 'gamma' harmonic around the
C           . output harmonics in our matrix.
C           .
            DO IHG = 1, NHG
C             .
C             . Calculate indices of temperature harm. gamma
C             .
              IF ( MTO( IHG ).NE.3 ) GOTO 56
C             .
              LG = MLO( IHG )
              IF ( MMO( IHG ).LT.0 ) THEN
                MG   = -MMO( IHG )
                ICSG = 2
              ELSE
                MG   = MMO( IHG )
                ICSG = 1
              ENDIF
C             .
              INDG   = INDSHC( LG, MG, ICSG )
C             .
              REQVIT = 'SPTS'
              CALL VICEXR( NVI, IHNALP, IHNBET, IHNGAM, INDA,
     1                INDB, INDG, TVHI, REQVIT, CVI, STS, ONZIC )
C             .
              IF ( .NOT. ONZIC ) GOTO 56
C             .
C             . OK - we have an S^{abg}_{ts} interaction
C             .
              IHD  = 0
              IHD0 = 0
C             .
              DPARS( 1 ) = STS
              DPARS( 2 ) = RI
              DPARS( 3 ) = RO
              DPARS( 4 ) = CA
              DPARS( 5 ) = CB
              DPARS( 6 ) = CC
C             .
              IPARS( 1 ) = IQSTA
              IPARS( 2 ) = IQSTB
              IPARS( 3 ) = IOLDF
              IPARS( 4 ) = LA
              IPARS( 5 ) = LB
C             .
              CALL INNLCA( N1, N2, KL, KU, KLE, IMF, IHA, IHG, INI,
     1      IHD, NBN, ILN, IRN, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, INVGIT, A, FAC, XARR, WORK, DPARS, SVFDC, IHB,
     3      IHD0, NDCS0, IS0, NBN0, IN0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
C             .
 56         CONTINUE
C           (if mto( ihg ).ne.3 ) goto 56)
C           (if dabs( sts ).lt.low ) goto 56)
            ENDDO
C           .
 55       CONTINUE
C         (if mt0( ihb ).ne.3 ) goto 55)
C         (if lb.eq.0 ) goto 55)
          ENDDO
C         .
        ENDIF
C       .
 50   CONTINUE
C     ( if mti( iha ).ne.1 .and. mti( iha ).ne.2 ) goto 50 )
      ENDDO

      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Adapted Matrix Surplus Diagonal Element Addition ********
C            -       -      -       -        -       -        ********
C Steve Gibbons Wed Oct 27 09:12:14 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C By using finite difference schemes where homogeneous boundary      C
C conditions are implicit in the coefficients used at points close   C
C to the boundary, either the end point or the two end points at     C
C each boundary become obsolete and must be arbitrarily filled       C
C to prevent singularity of the matrix.                              C
C                                                                    C
C AMSDEA loops around each harmonic, checks to see which scheme is   C
C used for this harmonic, looks to see what condition is implied     C
C at the boundary and then adds 0, 1 or 2 diagonal values of         C
C DIAGEL. If we are merely solving a linear system, DIAGEL is        C
C arbitrary. If we solving an eigensystem, DIAGEL will become an     C
C eigenvalue and so should be as highly negative as is necessary     C
C to prevent confusion with the 'real' eigenvalues.                  C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C    ALL other values of IMF are disqualified for this routine.      C
C                                                                    C
C     INARR     : Array of integers. Dimension ( * )                 C
C                 At present the elements of INARR are as follows.   C
C                                                                    C
C                 INARR( 1 ) = IFORMF. Format flag.                  C
C                  This flag decides how the elements are arranged   C
C                  in the solution vector.                           C
C                                                                    C
C                  The current options are:-                         C
C                                                                    C
C                   IFORMF = 1, 3. INDFUN = ( IR - 1 )*NH + IH       C
C                   IFORMF = 2, 4. INDFUN = ( IH - 1 )*NR + IR       C
C                                                                    C
C  where IR and IH are the current grid node and harmonic resp.      C
C  and NR and NH are the total numbers of nodes and harmonics        C
C  in the solution vector.                                           C
C                                                                    C
C                 INARR( 2 ) = NR. Number of radial grid nodes.      C
C                 INARR( 3 ) = NH. Number of harmonics in sol. vect. C
C                                                                    C
C     MHP       : Array length ( * ) - atleast length NH             C
C                  Pointer array to finite difference coefficients.  C
C                  MHPI( ih ) = is, which is the 4th index of        C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     IBCARR    : Dimension ( NDCS ). This must be the array MHIBC   C
C                 submitted to SVFDCF in the case CHBND(1:1) = 'I'   C
C                 and the array MHOBC submitted to SVFDCF in the     C
C                 case CHBND(1:1) = 'O'                              C
C                                                                    C
C     IBCARR( IS ) contains the integer IBC which corresponds        C
C    to the following boundary conditions :-                         C
C                                                                    C
C   IBC       Boundary condition                   No. of nodes      C
C   ---       ------------------                   ------------      C
C                                                                    C
C    1           None                                    0           C
C    2           f = 0                                   1           C
C    3           df/dr = 0                               1           C
C    4           f = 0   and     df/dr = 0               2           C
C    5           f = 0   and   d^2f/dr^2 = 0             2           C
C    6           f/r - df/dr = 0                         1           C
C    7           Insulating magnetic field               1           C
C                                                                    C
C                                                                    C
C                                                                    C
C     NDCS       : Number of distinct differencing coeff.s           C
C                  represented in SVFDC.                             C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     CHBND     : Boundary flag (*). Either 'Inner' or 'Outer'       C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     DIAGEL    : D.p. const. to be added to diagonals.              C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMSDEA( A, N1, N2, KL, KU, KLE, IMF, INARR, 
     1                   MHP, IBCARR, CHBND, DIAGEL, NDCS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER N1, N2, KL, KU, KLE, IMF, INARR( * ), MHP( * ), NDCS,
     1        IBCARR( NDCS )
      DOUBLE PRECISION A( N1, N2 ), DIAGEL
      CHARACTER *(*)   CHBND
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER NR, NH, IRAD, INDFUN, ISN, IEN, IH, IS, IOF,
     1        NRC, IRC, IBC
      DOUBLE PRECISION ZERO
      PARAMETER ( ZERO = 0.0d0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      NR = INARR( 2 )
      NH = INARR( 3 )
C     .
C     . Check on IMF (1 is only acceptable value)
C     .
      IF ( IMF.NE.1 ) THEN
        PRINT *,' Subroutine AMSDEA'
        PRINT *,' IMF = ', IMF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Check on size of N2
C     .
      IF ( N2.NE.NH*NR ) THEN
        PRINT *,' Subroutine AMSDEA'
        PRINT *,' N2 = ', N2
        PRINT *,' NR = ', NR
        PRINT *,' NH = ', NH
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Set inner outer flag
C     .
      IF ( CHBND(1:1).EQ.'I' .OR. CHBND(1:1).EQ.'i' ) THEN
        IOF = 1
        GOTO 50
      ENDIF
C     .
      IF ( CHBND(1:1).EQ.'O' .OR. CHBND(1:1).EQ.'o' ) THEN
        IOF = 2
        GOTO 50
      ENDIF
C     .
      PRINT *,' Subroutine AMSDEA'
      PRINT *,' CHBND = ', CHBND
      PRINT *,' Program aborted.'
      STOP
C     .
 50   CONTINUE
C     .
C     . Begin loop around harmonics
C     .
      DO IH = 1, NH
        IS  = MHP( IH )
        IF ( IS.LT.1 .OR. IS.GT.NDCS ) THEN
          PRINT *,' Subroutine AMSDEA'
          PRINT *,' IS   = ', IS
          PRINT *,' NDCS = ', NDCS
          PRINT *,' Program aborted.'
          STOP
        ENDIF
        IBC = IBCARR( IS )
        IF ( IBC.EQ.1 ) GOTO 51
C ............................ inner boundary case
C
        IF ( IOF.EQ.1 ) THEN
C         .
          IF ( IBC.EQ.2 .OR. IBC.EQ.3 .OR. IBC.EQ.6
     1           .OR. IBC.EQ.7 ) THEN
             ISN = 1
             IEN = 1
             GOTO 61
          ENDIF
C         .
          IF ( IBC.EQ.4 .OR. IBC.EQ.5 ) THEN
             ISN = 1
             IEN = 2
             GOTO 61
          ENDIF
C         .
          PRINT *,' Subroutine AMSDEA'
          PRINT *,' IBCARR(',IS,') = ', IBC
          PRINT *,' Program aborted.'
          STOP
        ENDIF
C ............................ outer boundary case
C
        IF ( IOF.EQ.2 ) THEN
C         .
          IF ( IBC.EQ.2 .OR. IBC.EQ.3 .OR. IBC.EQ.6
     1           .OR. IBC.EQ.7 ) THEN
             ISN = NR
             IEN = NR
             GOTO 61
          ENDIF
C         .
          IF ( IBC.EQ.4 .OR. IBC.EQ.5 ) THEN
             ISN = NR - 1
             IEN = NR
             GOTO 61
          ENDIF
C         .
          PRINT *,' Subroutine AMSDEA'
          PRINT *,' IBCARR(',IS,') = ', IBC
          PRINT *,' Program aborted.'
          STOP
        ENDIF
C ............................ 
 61     CONTINUE
        DO IRAD = ISN, IEN
C           .
C           . Zero the row of the matrix
C           .
            IRC = 1
            NRC = INDFUN( IRAD, IH, INARR )
            CALL BMRCOP( KL, KU, KLE, N2, IRC, NRC, A,
     1                   ZERO, ZERO )
C           .
C           . Enter value of the diagonal element
C           .
            A( KLE + KU + 1, NRC ) = DIAGEL
C           .
        ENDDO
C ............................ 
 51   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Newton Raphson Convection Woodbury Matrices Form ********
C            -      -       -          -        -        -    ********
C Steve Gibbons Wed Mar 15 14:52:18 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C When solving the vorticity and heat equations using a Newton-      C
C Raphson type method: either for boundary forced stationary flows   C
C or for solutions steady in a drifitng frame, we will need to       C
C provide a column for solving for the drift rate (if applicable -   C
C this is when OTCDC = .TRUE.) and we will need to change rows to    C
C prevent arbitrary rotations.                                       C
C                                                                    C
C The t_1^0 harmonic needs such a relation if boundaries are         C
C stress free. In this case, OT10 is .TRUE. and IT10 contains the    C
C number of the T_1^0 harmonic.                                      C
C                                                                    C
C The t_1^{1c} and t_1^{1s} harmonics needs such a relation if       C
C boundaries are stress free and the Coriolis force is absent from   C
C the matrix. In this case, OT11C and OT11S are .TRUE. and IT11C and C
C IT11S respectively contain the numbers of the T_1^{1c} and         C
C T_1^{1s} harmonics.                                                C
C                                                                    C
C There are a maximum number of 4 such operations. The actual        C
C number is given by the number NTS.                                 C
C                                                                    C
C The appropriate terms are then dealt with in the matrix A, the     C
C right hand vector, RHS, and the matrices U and V for use in        C
C the routine BMWDFS.                                                C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. Must be equal to KL in this routine.      C
C                                                                    C
C     NTS       : Number of special row/columns (see above).         C
C     ITCDC     : Number of harmonic to be fixed in rotating frame.  C
C     IT10      : Number of T_1^{0c} harmonic.                       C
C     IT11C     : Number of T_1^{1c} harmonic.                       C
C     IT11S     : Number of T_1^{1s} harmonic.                       C
C                                                                    C
C Note that ITCDC, IT10, IT11C and IT11S are only referred to if     C
C OTCDC, OT10, OT11C and OT11S are respectively .TRUE.               C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Dim( * ). Format info. (See INDFUN)                C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dimensions ( N1, N2 ) format as above      C
C     RHS       : Right hand vector. Dim (N2).                       C
C     U         : Matrix dim ( N2, NTS ). See above for guidance.    C
C     V         : Matrix dim ( N2, NTS ). See above for guidance.    C
C                                                                    C
C     XARR      : Array of dimension (  NR  ).                       C
C                  XARR( i ) contains the value of x or r at the     C
C                   i^{th} radial grid node.                         C
C                                                                    C
C     DFTDV     : Drifting frame time derivative vector. Dim (N2).   C
C                                                                    C
C  Logical                                                           C
C  -------                                                           C
C                                                                    C
C     OTCDC     : .T. if and only if drift rate column to be formed. C
C     OT10      : .T. if and only if T_1^0 needs frame fixing.       C
C     OT11C     : .T. if and only if T_1^{1c} needs frame fixing.    C
C     OT11S     : .T. if and only if T_1^{1s} needs frame fixing.    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE NRCWMF( N1, N2, KL, KU, KLE, NTS, ITCDC, IT10, IT11C,
     1                   IT11S, NR, INARR, OTCDC, OT10, OT11C, OT11S,
     2                   A, RHS, U, V, XARR, DFTDV )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER N1, N2, KL, KU, KLE, NTS, ITCDC, IT10, IT11C, IT11S,
     1        NR, INARR( * )
      LOGICAL OTCDC, OT10, OT11C, OT11S
      DOUBLE PRECISION A( N1, N2 ), RHS( N2 ), U( N2, NTS ),
     1                 V( N2, NTS ), XARR( NR ), DFTDV( N2 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER NNDS, NTS2, IOP, IRR, INDFUN, IND, IR, IRC, IGO, IH,
     1        INODE
      DOUBLE PRECISION ZERO, HI, DLOW, QUOT, X0
      PARAMETER ( NNDS = 6, ZERO = 0.0d0, DLOW = 1.0d-7 )
      INTEGER IWORK( NNDS )
      DOUBLE PRECISION WORK1( NNDS ), WORK2( NNDS ),
     1                 COEFM( NNDS, NNDS )
      LOGICAL ODO
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C 
      NTS2 = 0
      IF ( OTCDC ) NTS2 = NTS2 + 1
      IF ( OT10  ) NTS2 = NTS2 + 1
      IF ( OT11C ) NTS2 = NTS2 + 1
      IF ( OT11S ) NTS2 = NTS2 + 1
      IF ( NTS2.NE.NTS ) THEN
        PRINT *,' Subroutine NRCWMF.'
        PRINT *,' NTS = ', NTS,' but logical var.s suggest ', NTS2
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C Early escape??
C
      IF ( NTS.EQ.0 ) RETURN
C
C Clear the arrays U and V
C
      IOP = 0
      CALL MATOP( U, ZERO, N2, NTS, IOP )
      CALL MATOP( V, ZERO, N2, NTS, IOP )
C
      NTS2 = 0
      IRR  = NR/2
C
C Do time derivative column.
C This is a column operation so put vector in U
C matrix and location in V
C
      IF ( OTCDC ) THEN
        NTS2 = NTS2 + 1
        IND  = INDFUN( IRR, ITCDC, INARR )
        DO IR = 1, N2
          U( IR, NTS2 ) = DFTDV( IR )
        ENDDO
        U( IND, NTS2 ) = U( IND, NTS2 ) - 1.0d0
        V( IND, NTS2 ) = 1.0d0
        IRC = 2
        CALL BMRCOP( KL, KU, KLE, N2, IRC, IND, A, ZERO, ZERO )
        A( KLE + KU + 1, IND ) = 1.0d0
      ENDIF
C
C Sort out toroidal solid body rotations
C
      DO IGO = 1, 3
        ODO  = .FALSE.
        IF ( IGO.EQ.1 .AND. OT10  ) THEN
          ODO = .TRUE.
          IH  = IT10
        ENDIF
        IF ( IGO.EQ.2 .AND. OT11C ) THEN
          ODO = .TRUE.
          IH  = IT11C
        ENDIF
        IF ( IGO.EQ.3 .AND. OT11S ) THEN
          ODO = .TRUE.
          IH  = IT11S
        ENDIF
        IF ( ODO ) THEN
          NTS2 = NTS2 + 1
          IND  = INDFUN( IRR, IH, INARR )
          IRC = 1
          CALL BMRCOP( KL, KU, KLE, N2, IRC, IND, A, ZERO, ZERO )
          A( KLE + KU + 1, IND ) = 1.0d0
          U( IND, NTS2 )         = 1.0d0
          V( IND, NTS2 )         = (-1.0d0)
          RHS( IND )             = ZERO   
C         .
C         . Loop IR from 2, NR - 1 and fill in
C         . the 'obvious' values.
C         .
          DO IR = 2, NR - 1
            IND = INDFUN( IR, IH, INARR )
            HI = XARR( IR + 1 ) - XARR( IR - 1 )
            V( IND, NTS2 ) = V( IND, NTS2 ) + 0.5d0*HI/XARR( IR )
          ENDDO
C         .
C         . Now add components from inner boundary
C         .
          IF ( XARR( 1 ).GT.DLOW ) THEN
            X0 = XARR( 1 )
            DO INODE = 1, NNDS
              WORK1( INODE ) = XARR( INODE )
            ENDDO
            CALL GFDCFD( X0, WORK1, NNDS, COEFM, NNDS, IWORK, WORK2 )
C           .
C The coeff of f( x_i ) in the derivative of f at xarr( 1 )
C is now stored in COEFM( 2, i )
C           .
            QUOT = 1.0d0 - X0*COEFM( 2, 1 )
            IF ( ABS( QUOT ).LT.DLOW ) THEN
              PRINT *,' Subroutine NRCWMF.'
              PRINT *,' QUOT = ', QUOT
              PRINT *,' Program aborted.'
              STOP
            ENDIF
C           .
            HI = XARR( 2 ) - XARR( 1 )
            DO IR = 2, NNDS
              IND = INDFUN( IR, IH, INARR )
              V( IND, NTS2 ) = V( IND, NTS2 ) +
     1                    0.5d0*HI*COEFM( 2, IR )/(QUOT*X0)
            ENDDO
C           .
          ENDIF
C         .
C Now add components from outer boundary
C         .
          X0 = XARR( NR )
          HI = X0 - XARR( NR - 1 )
          DO INODE = 1, NNDS
            WORK1( INODE ) = XARR( NR + 1 - INODE )
          ENDDO
          CALL GFDCFD( X0, WORK1, NNDS, COEFM, NNDS, IWORK, WORK2 )
C         .
C The coeff of f( x_i ) in the derivative of f at xarr( nr )
C is now stored in COEFM( 2, nr + 1 - i )
C         .
          QUOT = 1.0d0 - X0*COEFM( 2, 1 )
          IF ( ABS( QUOT ).LT.DLOW ) THEN
            PRINT *,' Subroutine NRCWMF.'
            PRINT *,' QUOT = ', QUOT
            PRINT *,' Program aborted.'
            STOP
          ENDIF
C         .
          DO INODE = 2, NNDS
            IR = NR + 1 - INODE
            IND = INDFUN( IR, IH, INARR )
            V( IND, NTS2 ) = V( IND, NTS2 ) +
     1                  0.5d0*HI*COEFM( 2, INODE )/(QUOT*X0)
          ENDDO
C         .
        ENDIF
      ENDDO
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Banded Matrix WooDbury Formula Solve ********************
C            -      -      -  -     -       -     ********************
C Steve Gibbons Sat Mar  4 12:37:40 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C Given a banded matrix, A, stored in LAPACK format (i.e. element    C
C A( i, j ) is stored in A( kle + ku + 1 + i - j , j ) .... ),       C
C then BMWDFS solves the matrix equation                             C
C                                                                    C
C     ( A + [UVM] ) x = b                                            C
C                                                                    C
C where the matrix [UVM] is the product of matrices U ( N2, NP )     C
C and the transpose of V ( N2, NP ).                                 C
C                                                                    C
C NP is the number of additional rows AND columns with which the     C
C banded matrix A is to be altered. For example if the linear        C
C system above is to be modified from the banded formation by the    C
C addition of 2 columns ( say columns 5 and 7 ) and 3 rows           C
C ( say rows 1, 7 and 8) then NP would be set to  5 (=2+3).          C
C                                                                    C
C  (PROCEDURE FOR COLUMN ALTERATION .... )                           C
C                                                                    C
C Now the 1st column of U must contain the elements of the additnl.  C
C elements to column 5 and the 1st column of V must be all zero      C
C except for the number 1.0d0 in row 5. Similarly,                   C
C the 2nd column of U must contain the elements of the additional    C
C elements to column 7 and the 2nd column of V must be all zero      C
C except for the number 1.0d0 in row 7.                              C
C                                                                    C
C  (PROCEDURE FOR ROW ALTERATION .... )                              C
C                                                                    C
C However, the 3rd column of U must be zero except for a 1.0d0 in    C
C row 1. The element V( i, 3 ) will contain the value of element     C
C (1, i ) of the matrix [UVH].                                       C
C                                                                    C
C Similarly, column 4 ( 5 ) of U must be zero except for a 1.0d0     C
C in row 7 ( 8 ). Column 4 ( 5 ) of V must contain the elements of   C
C the new row 7 ( 8 ).                                               C
C                                                                    C
C Hope this is sufficient to illustrate the principle.               C
C                                                                    C
C This routine differs from the earlier version BMWDSL in that       C
C it does not automatically perform an LU decomposition.             C
C This is to allow for repeated solution of a matrix equation        C
C where the matrix has previously been LU decomposed.                C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     NP        : Number of additional operations to matrix.         C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. Must be equal to KL in this routine.      C
C                                                                    C
C     IPIV      : Work array dim ( N2 ) (LAPACK pivotting info)      C
C     IPIVH     : Work array dim ( NP ) (LAPACK pivotting info)      C
C                                                                    C
C     ILUDF     : LU decomposition flag.                             C
C                 =1 if matrix has just been formed and LU decomp.   C
C                    is required.                                    C
C                 =2 if LU decomp. has already been done and we      C
C                    simply require a further solution.              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dimensions ( N1, N2 ) format as above      C
C     RHS       : Vector dim ( N2 ). Corresponds to (b) in above eq. C
C                 Solution X is returned in RHS.                     C
C     U         : Matrix dim ( N2, NP ). See above for guidance.     C
C     V         : Matrix dim ( N2, NP ). See above for guidance.     C
C                                                                    C
C     HMAT      : Matrix dim ( NP, NP ). Workspace.                  C
C     VTY       : Matrix dim ( NP, 1  ). Workspace.                  C
C     HVTY      : Matrix dim ( NP, 1  ). Workspace.                  C
C     UHVTY     : Matrix dim ( N2, 1  ). Workspace.                  C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE BMWDFS( N1, N2, NP, KL, KU, KLE, IPIV, IPIVH, A,
     1                   RHS, U, V, HMAT, VTY, HVTY, UHVTY, ILUDF )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER N1, N2, NP, KL, KU, KLE, IPIV( N2 ), IPIVH( NP ),
     1        ILUDF
      DOUBLE PRECISION A( N1, N2 ), RHS( N2 ), U( N2, NP ),
     1                 V( N2, NP ), HMAT( NP, NP ), VTY( NP, 1 ),
     2                 HVTY( NP, 1 ), UHVTY( N2, 1 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER NRHS, INFO, I, MM, NN, KK
      DOUBLE PRECISION ALPHA, BETA
      CHARACTER *(1) TRANSA, TRANSB
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      INFO = 0
C
C Check inputs
C
      IF ( N1.NE.(KL+KU+KLE+1) ) THEN
        PRINT *,' Subroutine BMWDFS, N1 = ', N1
        PRINT *,' KL  = ', KL
        PRINT *,' KU  = ', KU
        PRINT *,' KLE = ', KLE
        STOP
      ENDIF
C
C Check size of KLE
C
      IF ( KL.NE.KLE ) THEN
        PRINT *,' Subroutine BMWDFS, KL = ', KL
        PRINT *,' Should be equal to KLE = ', KLE
        STOP
      ENDIF
C     .
      IF ( ILUDF.NE.1 .AND. ILUDF.NE.2 ) THEN
        PRINT *,' Subroutine BMWDFS.'
        PRINT *,' ILUDF = ', ILUDF
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
C First perform LU decomposition upon A.
C
      IF ( ILUDF.EQ.1 )
     1           CALL DGBTRF( N2, N2, KL, KU, A, N1, IPIV, INFO )
C
C Check for an error from LU decomp.
C
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine BMWDFS.'
         PRINT *,' The LAPACK subroutine DGBTRF has'
         PRINT *,' returned ',INFO,' as a value of '
         PRINT *,' INFO in LU decomposition of (A) matrix.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C We now follow the prescription of Numerical Recipes in C
C (hereafter referred to as NR)
C 2nd edition ISBN 0-521-43108-5 page 76 to implement
C Woodbury formula to solve system.
C
C First we solve the system A. y = RHS
C
C     .
      TRANSA = 'N'
      NRHS = 1
C     .
      CALL DGBTRS( TRANSA, N2, KL, KU, NRHS, A, N1,
     1             IPIV, RHS, N2, INFO )
C     .
C     . Check that solution has occured without error
C     .
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine BMWDFS.'
         PRINT *,' The LAPACK subroutine DGBTRS'
         PRINT *,' has returned ',INFO,' as a value of'
         PRINT *,' INFO solving A.y = RHS.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . RHS now contains the vector NR refers to as y
C     . If NP is 0 then we can make an early exit!
C     .
      IF ( NP.EQ.0 ) RETURN
C     .
C     . Now we solve the auxiliary problems A.Z = U
C     . and so NRHS must be set to NP
C     .
      NRHS = NP
C     .
      CALL DGBTRS( TRANSA, N2, KL, KU, NRHS, A, N1,
     1             IPIV, U, N2, INFO )
C     .
C     . Check that solution has occured without error
C     .
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine BMWDFS.'
         PRINT *,' The LAPACK subroutine DGBTRS'
         PRINT *,' has returned ',INFO,' as a value of'
         PRINT *,' INFO solving A.Z = U.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . U now contains the vectors NR refers to as Z
C     . We must now construct matrix HMAT in stages
C     . First calculate V^T.Z: for this we use DGEMM.
C     .
      TRANSA = 'T'
      TRANSB = 'N'
      ALPHA  = 1.0d0
      BETA   = 0.0d0
C
      MM = NP
      NN = NP
      KK = N2
C
      CALL DGEMM ( TRANSA, TRANSB, MM, NN, KK,
     1             ALPHA, V, N2, U, N2, BETA, HMAT, NP)
C
C     .
C     . Now add the identity matrix to HMAT
C     .
      DO I = 1, NP
        HMAT( I, I ) = HMAT( I, I ) + 1.0d0
      ENDDO
C     .
C     . Now invert the square matrix HMAT
C     . First perform LU decomposition,
C     .
      CALL DGETRF( NP, NP, HMAT, NP, IPIVH, INFO )
C     .
C     . Check that LU decomposition has gone without
C     . problem.
C     .
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine BMWDFS.'
         PRINT *,' The LAPACK subroutine DGETRF has'
         PRINT *,' returned ',INFO,' as a value of '
         PRINT *,' INFO in LU decomposition of (H) matrix.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Now compute the inverse with the LAPACK routine
C     . DGETRI. For the workspace, we will supply
C     . UHVTY as this has plenty of space ( N2 elements )
C     . and has yet to be used.
C     .
      CALL DGETRI( NP, HMAT, NP, IPIVH, UHVTY, N2, INFO )
C     .
C     . Check that inversion has gone without problem.
C     .
      IF ( INFO.NE.0 ) THEN
         PRINT *,' Subroutine BMWDFS.'
         PRINT *,' The LAPACK subroutine DGETRI has'
         PRINT *,' returned ',INFO,' as a value of '
         PRINT *,' INFO in inversion of (H) matrix.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Our matrix HMAT now represents the matrix H in
C     . NR on page 76 eqn. (2.7.19)
C     . We now proceed with a suite of matrix multiplications
C     . to evaluate the solutions as in eqn (2.7.21)
C     .
C     . First multiply V transpose by y ( RHS )
C     .
      TRANSA = 'T'
      TRANSB = 'N'
      ALPHA  = 1.0d0
      BETA   = 0.0d0
C
      MM = NP
      NN = 1
      KK = N2
C
      CALL DGEMM ( TRANSA, TRANSB, MM, NN, KK,
     1             ALPHA, V, N2, RHS, N2, BETA, VTY, NP)
C      
C     .
C     . Now premultiply resulting matrix (VTY) by
C     . HMAT (calculated above)
C     .
      TRANSA = 'N'
      TRANSB = 'N'
      ALPHA  = 1.0d0
      BETA   = 0.0d0
C
      MM = NP
      NN = 1
      KK = NP
C
      CALL DGEMM ( TRANSA, TRANSB, MM, NN, KK,
     1             ALPHA, HMAT, NP, VTY, NP, BETA, HVTY, NP)
C
C     .
C     . Now premultiply resulting matrix (HVTY) by
C     . HMAT (calculated above)
C     .
      TRANSA = 'N'
      TRANSB = 'N'
      ALPHA  = 1.0d0
      BETA   = 0.0d0
C
      MM = N2
      NN = 1
      KK = NP
C
      CALL DGEMM ( TRANSA, TRANSB, MM, NN, KK,
     1             ALPHA, U, N2, HVTY, NP, BETA, UHVTY, N2)
C
C  OK - so now evaluate solution!!!
C
      DO I = 1, N2
        RHS( I ) = RHS( I ) - UHVTY( I, 1 )
      ENDDO
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Solution Vector ComPLete ************************
C            -       -        -      -  --    ************************
C Steve Gibbons Wed Oct 27 14:10:12 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C A solution vector whose end nodes are defined implicitly by the    C
C boundary conditions rather than given explicitly may have 1 or 2   C
C nodes 'missing' at each boundary.                                  C
C                                                                    C
C ASVCPL uses the finite difference coefficients in SVFDC to fill in C
C these points. It is not usually necessary to do this when further  C
C calculations are required as ASVDR will disregard all such values. C
C However, it is preferable when observing a solution that all       C
C elements are present.                                              C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     INARR     : Int. parameter array corresponding to ASV          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NR      See INDFUN for details        C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHP       : Array length ( * ) - atleast length NH             C
C                  Pointer array to finite difference coefficients.  C
C                  MHP( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     MHIBC     : MHIBC( is ) describes the inner boundary           C
C                  condition for scheme IS.                          C
C                                                                    C
C  MHIBC( is ) = 1 --> No condition is to be assumed at the bndry.   C
C  MHIBC( is ) = 2 --> Function must vanish at the bndry.            C
C  MHIBC( is ) = 3 --> First derivative must vanish at the bndry.    C
C  MHIBC( is ) = 4 --> Function must vanish at the bndry AND         C
C                       first derivative must vanish at the bndry.   C
C  MHIBC( is ) = 5 --> Function must vanish at the bndry AND         C
C                       second derivative must vanish at the bndry.  C
C  MHIBC( is ) = 6 --> r df/dr - f(r) = 0   at the bndry.            C
C  MHIBC( is ) = 7 --> insulating magnetic field.                    C
C                                                                    C
C     MHOBC     : MHOBC( is ) describes the outer boundary           C
C                  condition for scheme IS. (See above for key.)     C
C                                                                    C
C     NFDCM     : Leading order of the array SVFDC.                  C
C                 This must be atleast (2*NBN + 1)                   C
C     NDRVS     : Number of derivatives stored in SVFDC.             C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NBN       : Number of bounding nodes as supplied to SVFDCF.    C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     ASV       : Solution vector. Dim ( * )                         C
C                 Length must be atleast NRI*NH                      C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ASVCPL( ASV, NR, NDCS, INARR, MHP, MHIBC, MHOBC,
     1                   NFDCM, NDRVS, NDRVM, NBN, SVFDC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, NDCS, INARR( * ), MHP( * ), MHIBC( NDCS ),
     1        MHOBC( NDCS ), NFDCM, NDRVS, NDRVM, NBN
      DOUBLE PRECISION ASV( * ), SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IH, IS, IR, ISN, IEN, NH, IND, INDFUN, IHD, IBC
      DOUBLE PRECISION DERV( 1 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IHD = 0
      NH  = INARR( 3 )
C     .
C     . Loop around harmonics
C     .
      DO IH = 1, NH
        IS = MHP( IH )
        IF ( IS.LT.1 .OR. IS.GT.NDCS ) THEN
          PRINT *,' Subroutine ASVCPL.'
          PRINT *,' Harmonic ', IH
          PRINT *,' IS    = ', IS
          PRINT *,' NDCS  = ', NDCS
          PRINT *,' Program aborted.'
          STOP
        ENDIF
C
C Inner boundary
C
        IBC = MHIBC( IS )
        IF ( IBC.EQ.1 ) GOTO 50
C       .
        IF ( IBC.EQ.2 .OR. IBC.EQ.3 .OR. IBC.EQ.6
     1         .OR. IBC.EQ.7 ) THEN
           ISN = 1
           IEN = 1
           GOTO 51
        ENDIF
C       .
        IF ( IBC.EQ.4 .OR. IBC.EQ.5 ) THEN
           ISN = 1
           IEN = 2
           GOTO 51
        ENDIF
C       .
        PRINT *,' Subroutine ASVCPL'
        PRINT *,' MHIBC(',IS,') = ', IBC
        PRINT *,' Program aborted.'
        STOP
C       .
 51     CONTINUE
        DO IR = ISN, IEN
C         .
C         . Find index of element
C         .
          IND = INDFUN( IR, IH, INARR )
C         .
          CALL ASVDR ( ASV, IR, IS, IH, NBN, IHD, NFDCM, NR, NDRVS,
     1                 NDRVM, DERV, INARR, SVFDC, NDCS )
C         .
          ASV( IND ) = DERV( 1 )
C         .
        ENDDO
C       .
 50     CONTINUE
C
C Outer boundary
C
        IBC = MHOBC( IS )
        IF ( IBC.EQ.1 ) GOTO 60
C       .
        IF ( IBC.EQ.2 .OR. IBC.EQ.3 .OR. IBC.EQ.6
     1         .OR. IBC.EQ.7 ) THEN
           ISN = NR
           IEN = NR
           GOTO 61
        ENDIF
C       .
        IF ( IBC.EQ.4 .OR. IBC.EQ.5 ) THEN
           ISN = NR-1
           IEN = NR
           GOTO 61
        ENDIF
C       .
        PRINT *,' Subroutine ASVCPL'
        PRINT *,' MHOBC(',IS,') = ', IBC
        PRINT *,' Program aborted.'
        STOP
C       .
 61     CONTINUE
        DO IR = ISN, IEN
C         .
C         . Find index of element
C         .
          IND = INDFUN( IR, IH, INARR )
C         .
          CALL ASVDR ( ASV, IR, IS, IH, NBN, IHD, NFDCM, NR, NDRVS,
     1                 NDRVM, DERV, INARR, SVFDC, NDCS )
C         .
          ASV( IND ) = DERV( 1 )
C         .
        ENDDO
C       .
 60     CONTINUE
C
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine RADius VaLue Find ***************************************
C            ---    - -   -    ***************************************
C Steve Gibbons Thu Sep 16 13:03:18 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C  Gives the value of radius for a given grid node, IR.              C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IR        : Number of radial grid node.                        C
C     INARR     : Array of integers. Dimension ( * )                 C
C                 At present the elements of INARR are as follows.   C
C                                                                    C
C                 INARR( 1 ) = IFORMF. Format flag.                  C
C                  This flag decides how the elements are arranged   C
C                  in the solution vector.                           C
C                                                                    C
C                 INARR( 2 ) = NR. Number of radial grid nodes.      C
C                 INARR( 3 ) = NH.                                   C
C                                                                    C
C INARR must be the same array which is passed to INDFUN.            C
C                                                                    C
C If IFORMF = 1 or IFORMF = 2 then                                   C
C            RAD    = RI + DBLE( IR - 1 )*H                          C
C  where     H      = ( RO - RI )/DBLE( NR - 1 )                     C
C                                                                    C
C If IFORMF = 3 or IFORMF = 4 then RAD = XARR( IR )                  C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RAD       : Returned as the value of the radius.               C
C                                                                    C
C     DPARR     : Array of dimension ( * ).                          C
C                                                                    C
C      DPARR( 1 ) = RI                                               C
C      DPARR( 2 ) = RO                                               C
C                                                                    C
C     XARR      : Array of dimension ( * ).                          C
C                 May contain coefficients for abscissae in some     C
C                  non-uniform differencing scheme.                  C
C                                                                    C
C     H         : Distance between adjacent grid nodes.              C
C                 Output variable only as it is calculated in situ.  C
C                 Only valid for uniform mesh schemes.               C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RADVLF ( RAD, IR, INARR, DPARR, XARR, H )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IR, INARR( * )
      DOUBLE PRECISION RAD, DPARR( * ), XARR( * ), H
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IFORMF, NR
      DOUBLE PRECISION RI, RO, TOL
      PARAMETER ( TOL = 1.0d-6 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      H      = 0.0d0
C
      RI     = DPARR( 1 )
      RO     = DPARR( 2 )
C
      IFORMF = INARR( 1 )
      NR     = INARR( 2 )
C
      IF ( IR.LT.1 .OR. IR.GT.NR ) THEN
        PRINT *,' Function RADVLF. NR = ', NR
        PRINT *,' IR = ', IR,' Program aborted.'
        STOP
      ENDIF
C
      IF ( NR.LT.2 ) THEN
        PRINT *,' Function RADVLF.'
        PRINT *,' NR = ', NR,' Program aborted.'
        STOP
      ENDIF
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
        H = ( RO - RI )/DBLE( NR - 1 )
        IF ( H.LT.TOL ) THEN
          PRINT *,' Function RADVLF.'
          PRINT *,' H = ', H,' Program aborted.'
          STOP
        ENDIF
        RAD = RI + DBLE( IR - 1 )*H
        RETURN
      ENDIF
C
      IF ( IFORMF.EQ.3 .OR. IFORMF.EQ.4 ) THEN
        RAD = XARR( IR )
        RETURN
      ENDIF
C
      PRINT *,' Function RADVLF. IFORMF = ', IFORMF
      PRINT *,' Not current option. Program aborted.'
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine MATrix OPeration ****************************************
C Steve Gibbons 23.4.97 Does operation on a two-dimensional array.   C
C                                                Can set equal to a  C
C                       constant; multiply by a constant or have a   C
C                       constant added to it.                        C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IOP	: Type of operation to be done.                      C
C                    WHOLE MATRIX OPERATIONS                         C
C                  IOP=0  -->  Each element of the matrix = CONST    C
C                  IOP=1  -->  Each el. is multiplied by CONST       C
C                  IOP=2  -->  Each el. is added to CONST            C
C     NDIM1     : First dimension of the matrix.	             C
C     NDIM2     : Second dimension of the matrix.	             C
C  Double Precision                                                  C
C  ----------------                                                  C
C     MAT	: Matrix with dimension ( NDIM1, NDIM2 )             C
C     CONST     : Double precision constant.                         C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE MATOP ( MAT, CONST, NDIM1, NDIM2, IOP)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NDIM1, NDIM2, IOP
      DOUBLE PRECISION MAT ( NDIM1, NDIM2 ), CONST
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I, J
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First do case IOP=0 
      IF ( IOP.EQ.0 ) THEN
         DO J = 1, NDIM2
            DO I = 1, NDIM1
               MAT ( I, J) = CONST
            ENDDO
         ENDDO
         RETURN
      ENDIF
C Now do case IOP=1
      IF ( IOP.EQ.1 ) THEN
         DO J = 1, NDIM2
            DO I = 1, NDIM1
               MAT ( I, J) = MAT ( I, J)*CONST
            ENDDO
         ENDDO
         RETURN
      ENDIF
C Now do case IOP=2
      IF ( IOP.EQ.2 ) THEN
         DO J = 1, NDIM2
            DO I = 1, NDIM1
               MAT ( I, J) = MAT ( I, J) + CONST
            ENDDO
         ENDDO
         RETURN
      ENDIF
      PRINT *,' Subroutine MATOP. IOP must be 0,1 or 2.'
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine Single Harmonic VECtor Transform ************************
C            -      -        ---    -         ************************
C Steve Gibbons 26.8.97                                              C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     L         : Spherical harmonic degree, l.                      C
C     M         : Spherical harmonic order, m.                       C
C     ICS       : =1 for cos m phi dependence and 2 for sin m phi.   C
C     IQST	: Number of function.                                C
C                  IQST = 1 : Q - scaloidal harmonic. Evaluates      C
C                     ( Y , 0 , 0 )                                  C
C                  IQST = 2 : S - spheroidal harm. Evaluates         C
C                     ( 0 , dY/dtheta , 1/sintheta dY/dphi )*fac     C
C                  IQST = 3 : T - toroidal harmonic. Evaluates       C
C                     ( 0 , - 1/sintheta dY/dphi , dY/dtheta )*fac   C
C                                                                    C
C   where fac = 1/sqrt( l*l + l )                                    C
C                                                                    C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     LH        : Maximum spherical harmonic degree, l.              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     PA         : Schmidt Normalised Legendre Functions             C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2, NTHPTS )     C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA        : Derivatives of the above.                         C
C                                                                    C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF	: Vector Function                                    C
C                 has dimensions ( NPHPTS, NTHPTS, 3 )               C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE SHVECT ( L, M, ICS, IQST, VF, GAUX, PA, DPA,
     1                    NTHPTS, NPHPTS, LH )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, NTHPTS, NPHPTS, IQST, L, M, ICS
      DOUBLE PRECISION VF ( NPHPTS, NTHPTS, 3 ), GAUX( NTHPTS )
      DOUBLE PRECISION PA ( ( LH + 1 )*( LH + 2 )/2, NTHPTS ),
     1                 DPA ( ( LH + 1 )*( LH + 2 )/2, NTHPTS )
      DOUBLE PRECISION PI
      PARAMETER (PI=3.14159265358979312D0)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION X, S, THETA, ZERO, PHI, PINT, FA, SQRLL1
      INTEGER ITHETA, IOP, ITHREE, IP, IPHI
      PARAMETER ( ZERO=0.0d0, ITHREE=3 )
C____________________________________________________________________C
C Functions used :-
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C set VF array to zero.
      IOP = 0
      CALL CUBEOP ( VF, ZERO, NPHPTS, NTHPTS, ITHREE, IOP )
C     .
      IF ( ICS.NE.1 .AND. ICS.NE.2 ) THEN
        PRINT *,' Subroutine SHVECT.'
        PRINT *,' ICS = ', ICS,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( M.LT.0 .OR. M.GT.L ) THEN
        PRINT *,' Subroutine SHVECT.'
        PRINT *,' M = ',M,' L = ', L
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( NTHPTS.LE.L ) THEN
         PRINT *,' Subroutine SHVECT.'
         PRINT *,' NTHPTS must be atleast ', L + 1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( NPHPTS.LE.(2*M+1) ) THEN
         PRINT *,' Subroutine SHVECT.'
         PRINT *,' NPHPTS must be atleast ',(2*M+1)
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IP   = L*(L+1)/2+M+1
      PINT = 2.0d0*PI/DBLE( NPHPTS )
      FA   = 1.0d0/SQRLL1( L )
C
C********************************************************************
C*********** First case IQST = 1 ... SCALOIDAL FUNCTION **************
C********************************************************************
      IF (IQST.EQ.1) THEN
C ............. start to loop around theta points ...................
        DO ITHETA = 1, NTHPTS
         X = GAUX( ITHETA )
         THETA = ACOS( X )
         S = DSIN( THETA )
C ............. First consider case M = 0
         IF (M.EQ.0) THEN
           DO IPHI = 1, NPHPTS
             VF ( IPHI, ITHETA, 1 ) = PA ( IP, ITHETA )
           ENDDO
         ELSE
           DO IPHI = 1, NPHPTS
              PHI = DBLE(IPHI - 1 )*PINT
              IF (ICS.EQ.1) THEN
                VF ( IPHI, ITHETA, 1 ) = PA ( IP, ITHETA )*
     1                                  DCOS( M*PHI )
              ELSE
                VF ( IPHI, ITHETA, 1 ) = PA ( IP, ITHETA )*
     1                                  DSIN( M*PHI )
              ENDIF
           ENDDO
         ENDIF
        ENDDO
C ............. ended looping around theta points ...................
        RETURN
      ENDIF
C
C********************************************************************
C*********** End of case IQST = 1 ( scaloidal ) **********************
C********************************************************************
C
C
C********************************************************************
C*********** First case IQST = 2 ... SPHEROIDAL FUNCTION *************
C********************************************************************
      IF (IQST.EQ.2) THEN
C ............. start to loop around theta points ...................
        DO ITHETA = 1, NTHPTS
         X = GAUX( ITHETA )
         THETA = ACOS( X )
         S = DSIN( THETA )
C ............. First consider case M = 0
        IF (M.EQ.0) THEN
           DO IPHI = 1, NPHPTS
              VF ( IPHI, ITHETA, 2 ) = DPA ( IP, ITHETA )*FA
           ENDDO
         ELSE
           DO IPHI = 1, NPHPTS
              PHI = DBLE(IPHI - 1 )*PINT
              IF (ICS.EQ.1) THEN
                VF ( IPHI, ITHETA, 2 ) = DPA ( IP, ITHETA )*FA*
     1                                  DCOS( M*PHI )
                VF ( IPHI, ITHETA, 3 ) = PA ( IP, ITHETA )*FA*
     1                             M*DSIN( M*PHI )*(-1.0d0/S)
              ELSE
                VF ( IPHI, ITHETA, 2 ) = DPA ( IP, ITHETA )*FA*
     1                                  DSIN( M*PHI )
                VF ( IPHI, ITHETA, 3 ) = PA ( IP, ITHETA )*FA*
     1                                  M*DCOS( M*PHI )/S
              ENDIF
           ENDDO
         ENDIF 
 
        ENDDO
C ............. ended looping around theta points ...................
        RETURN
      ENDIF
C
C********************************************************************
C*********** End of case IQST = 2 ( spheroidal ) *********************
C********************************************************************
C
C
C********************************************************************
C*********** First case IQST = 3 ... TOROIDAL FUNCTION ***************
C********************************************************************
      IF (IQST.EQ.3) THEN
C ............. start to loop around theta points ...................
        DO ITHETA = 1, NTHPTS
         X = GAUX( ITHETA )
         THETA = ACOS( X )
         S = DSIN( THETA )
C ............. First consider case M = 0
        IF (M.EQ.0) THEN
           DO IPHI = 1, NPHPTS
              VF ( IPHI, ITHETA, 3 ) = DPA ( IP, ITHETA )*FA
           ENDDO
         ELSE
           DO IPHI = 1, NPHPTS
              PHI = DBLE(IPHI - 1 )*PINT
              IF (ICS.EQ.1) THEN
                VF ( IPHI, ITHETA, 3 ) = DPA ( IP, ITHETA )*FA*
     1                                  DCOS( M*PHI )
                VF ( IPHI, ITHETA, 2 ) = PA ( IP, ITHETA )*FA*
     1                                  M*DSIN( M*PHI )/S
              ELSE
                VF ( IPHI, ITHETA, 3 ) = DPA ( IP, ITHETA )*FA*
     1                                  DSIN( M*PHI )
                VF ( IPHI, ITHETA, 2 ) = PA ( IP, ITHETA )*FA*
     1                             (-1.0d0)*M*DCOS( M*PHI )/S
              ENDIF
           ENDDO
         ENDIF
 
        ENDDO
C ............. ended looping around theta points ...................
        RETURN
      ENDIF
C
C********************************************************************
C*********** End of case IQST = 3 ( toroidal ) ***********************
C********************************************************************
C
      PRINT *,' IQST must be 1, 2 or 3 in SHVECT.'
      PRINT *,' Program aborted. '
      STOP
      END
C*********************************************************************
C*********************************************************************
C Subroutine Vector Function Dot Product *****************************
C            -      -        -   -       *****************************
C Steve Gibbons Fri Sep 24 16:35:41 BST 1999                         C
C____________________________________________________________________C
C To have two input vector function arrays of dimension              C
C ( NPHPTS , NTHPTS, 3 ) of which the scalar products are taken to   C
C give a scalar vector SF with dimension ( NPHPTS, NTHPTS ).         C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NPHPTS	: Number of phi points.                              C
C     NTHPTS	: Number of theta points.                            C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF1	: First vector function. Dim ( NPHPTS , NTHPTS, 3 )  C
C     VF2	: Second vector function. Dim ( NPHPTS , NTHPTS, 3 ) C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     SF	: Scalar function. Dim ( NPHPTS, NTHPTS )            C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VFDP ( VF1, VF2, SF, NPHPTS, NTHPTS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NPHPTS, NTHPTS
      DOUBLE PRECISION VF1 ( NPHPTS , NTHPTS, 3 ),
     1                 VF2 ( NPHPTS , NTHPTS, 3 ),
     2                 SF ( NPHPTS, NTHPTS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER ITHETA, IPHI, ICOMP, IOP
      DOUBLE PRECISION ZERO
      PARAMETER ( ZERO = 0.0d0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C .... let's set SF to zero.
c
      IOP = 0
      CALL MATOP ( SF, ZERO, NPHPTS, NTHPTS, IOP )
c
C .... let's loop around icomp, then nthpts, then nphpts
      DO ICOMP = 1, 3
         DO ITHETA = 1, NTHPTS
            DO IPHI = 1, NPHPTS
               SF( IPHI, ITHETA ) = SF( IPHI, ITHETA ) +
     1       VF1( IPHI, ITHETA, ICOMP )*VF2( IPHI, ITHETA, ICOMP )
            ENDDO
         ENDDO
      ENDDO
C____________________________________________________________________C
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine FORward Scalar Spherical Transform (array version) ******
C            ---     -      -         -                              C
C Steve Gibbons 23.4.97                                              C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     SF	: Scalar Function. This is an array containing a     C
C                  function over a set of theta and phi points.      C
C                    Dimensions are                                  C
C                      ( NPHPTS , NTHPTS )                           C
C                                                                    C
C                 SF( i, j ) contains the value a scalar function    C
C                 at theta = acos( x_j ) where x_j is the j^{th}     C
C                 element of GAUX returned by GAUWTS and             C
C                 phi = 2 pi ( i - 1 ) / nphpts                      C
C                                                                    C
C     GAUW      : Gauss weights as calculated by GAUWTS. ( NTHPTS )  C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     ZCOEF     : Coefficient of the l=0 spherical harmonic.         C
C                                                                    C
C  Integer                                                           C
C  -------							     C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum spherical harmonic order, m.               C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     SHC	: Spherical Harmonic Coefficients.                   C
C                  Has the usual ordering.                           C
C                   SHC( l*l ) = P_l^0                               C
C                   SHC( l*l + 2*m - 1 ) = P_l^mc ( m non zero )     C
C                   SHC( l*l + 2*m ) = P_l^ms ( m non zero )         C
C                  Dimension is ( LH*( LH + 2) )                     C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     FTF       : Array for fourier transforming.                    C
C                  Has dimensions ( 2*NPHPTS )                       C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE FORSST ( SHC, SF, GAUW, PA, FTF, LH, MMAX,
     1                    NTHPTS, NPHPTS, ZCOEF )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER          LH, NTHPTS, NPHPTS, MMAX
      DOUBLE PRECISION SHC( LH*( LH + 2) ),
     1                 SF( NPHPTS , NTHPTS ), GAUW(NTHPTS)
      DOUBLE PRECISION FTF( 2*NPHPTS ), ZCOEF,
     1                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IOP,ITHETA,ILEV,INDCOS,INDSIN,LENV,ISIGN,I,M, IP
      DOUBLE PRECISION ZERO,WEIGHT
      PARAMETER ( ZERO = 0.0d0 )
C____________________________________________________________________C
C Functions used :-
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C    
C Check the validity of arguments .....
C (Don't bother checking NPHPTS is a power of 2
C as this will be done by FFTRLV)
C
      IF ( NTHPTS.LE.LH ) THEN
         PRINT *,' Subroutine FORSST.'
         PRINT *,' NTHPTS must be atleast ', LH + 1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( NPHPTS.LE.(2*MMAX+1) ) THEN
         PRINT *,' Subroutine FORSST.'
         PRINT *,' NPHPTS must be atleast ',2*MMAX+1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C_____________________________________________________________________
C
      ISIGN = 1
C ... zero the array of spherical harm coeffs --> IOP = 0
      IOP = 0
      LENV = LH*(LH+2)
      CALL VECOP ( SHC, ZERO, LENV, IOP )
      ZCOEF = 0.0d0
 
C ............... begin looping around theta points ..................
      DO ITHETA = 1, NTHPTS
         LENV = 2*NPHPTS
         CALL VECOP ( FTF, ZERO, LENV, IOP )
         WEIGHT = GAUW( ITHETA )
C ................ now (considering equation we have w_j,
C all of the P_l^m(cos(theta_j) ) so now need the Fourier transform
C of the SF for (theta_j) ......
         DO I = 1, NPHPTS
            FTF ( 2*I - 1) = SF( I, ITHETA )
            ZCOEF = ZCOEF + WEIGHT * SF( I, ITHETA )/DBLE(NPHPTS)
         ENDDO
C ................ o.k. now let's Fourier Transform .................
C Array ftf currently contains value of function at phi point
C (i) in element ftf( 2i - 1 ) ...
C
         CALL FFTRLV ( FTF, NPHPTS, ISIGN )
C
C ftf now contains c_m in ftf(2m+1) and s_m in ftf(2m+2)
C ................ let's loop around the harmonics ..................
         DO ILEV = 1, LH         
            INDCOS = ILEV*ILEV
C ................................... first let's do the M = 0 case .
            M = 0
            IP = ILEV*(ILEV+1)/2+M+1
            SHC ( INDCOS ) = SHC( INDCOS ) + PA( IP , ITHETA)*
     1                        WEIGHT*FTF( 1 )
            INDCOS = INDCOS + 1
            INDSIN = INDCOS + 1
C ............ now let's loop around M from 1 to ILEV ..............
            DO M = 1, MIN( ILEV, MMAX )
               IP = ILEV*(ILEV+1)/2+M+1
               SHC(INDCOS) = SHC(INDCOS) + PA(IP, ITHETA)*
     1                        WEIGHT*FTF(2*M+1)
               SHC(INDSIN) = SHC(INDSIN) + PA(IP, ITHETA)*
     1                        WEIGHT*FTF(2*M+2)
               INDCOS = INDCOS + 2
               INDSIN = INDSIN + 2
            ENDDO
         ENDDO
C .................. end loop around the harmonics ..................
      ENDDO
C ................. end looping around theta points ..................
C Now just loop around the SHC's to multiply by the schmidt normalisation
C and scale factor of fft.
      ZCOEF = ZCOEF / 2.0d0
      DO ILEV = 1, LH
         WEIGHT = DBLE( 2*ILEV + 1 )/4.0d0
         DO M = 0 , 2*MIN( ILEV, MMAX )
            SHC( ILEV*ILEV + M ) = SHC ( ILEV*ILEV + M ) * WEIGHT
         ENDDO
      ENDDO
      RETURN
      END
C*********************************************************************
C*********************************************************************
C Subroutine Vector Function Cross Product ***************************
C            -      -        -     -       ***************************
C Steve Gibbons 9.7.97                                               C
C____________________________________________________________________C
C To have two input vector function arrays of dimension              C
C ( NPHPTS , NTHPTS, 3 ) of which the vector product is taken to     C
C give a thrid vector VF3 with dimension ( NPHPTS , NTHPTS, 3 )      C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NPHPTS	: Number of phi points.                              C
C     NTHPTS	: Number of theta points.                            C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF1	: First vector function. Dim ( NPHPTS , NTHPTS, 3 )  C
C     VF2	: Second vector function. Dim ( NPHPTS , NTHPTS, 3 ) C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF3	: Third vector function. Dim ( NPHPTS , NTHPTS, 3 )  C
C____________________________________________________________________C
C                                                                    C
C      Let u = ( u1, u2, u3 ) and v = ( v1, v2, v3 )                 C
C      If w = ( w1, w2, w3 ) = u x v    then                         C
C                                                                    C
C                  w1 = u2 * v3 - u3 * v2                            C
C                  w2 = u3 * v1 - u1 * v3                            C
C                  w3 = u1 * v2 - u2 * v1                            C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VFCP ( VF1, VF2, VF3, NPHPTS, NTHPTS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NPHPTS, NTHPTS
      DOUBLE PRECISION VF1 ( NPHPTS, NTHPTS, 3 ),
     1                 VF2 ( NPHPTS, NTHPTS, 3 ),
     2                 VF3 ( NPHPTS, NTHPTS, 3 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER ITHETA, IPHI, IOP, I3
      DOUBLE PRECISION ZERO
      PARAMETER ( ZERO = 0.0d0, I3 = 3 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C .... let's set VF3 to zero.
c
      IOP = 0
      CALL CUBEOP ( VF3, ZERO, NPHPTS, NTHPTS, I3, IOP )
c
C .... let's loop around icomp, then nthpts, then nphpts
c
      DO ITHETA = 1, NTHPTS
         DO IPHI = 1, NPHPTS
c
            VF3 ( IPHI, ITHETA, 1 ) =
     1       VF1 ( IPHI, ITHETA, 2 )*VF2 ( IPHI, ITHETA, 3 ) -
     2       VF1 ( IPHI, ITHETA, 3 )*VF2 ( IPHI, ITHETA, 2 )
c
            VF3 ( IPHI, ITHETA, 2 ) =
     1       VF1 ( IPHI, ITHETA, 3 )*VF2 ( IPHI, ITHETA, 1 ) -
     2       VF1 ( IPHI, ITHETA, 1 )*VF2 ( IPHI, ITHETA, 3 )
c
            VF3 ( IPHI, ITHETA, 3 ) =
     1       VF1 ( IPHI, ITHETA, 1 )*VF2 ( IPHI, ITHETA, 2 ) -
     2       VF1 ( IPHI, ITHETA, 2 )*VF2 ( IPHI, ITHETA, 1 )
c
         ENDDO
      ENDDO
c 
C____________________________________________________________________C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Vector Function TO QST coefficients *********************
C            -      -        -- ---              *********************
C Steve Gibbons 26.4.97                                              C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum spherical harmonic order, m.               C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     GAUW      : Corresponding weights. As above.                   C
C     VF        : Vector Function. An array of dimensions            C
C                  ( NPHPTS, NTHPTS, 3) which contain the R, THETA   C
C                  and PHI components of a VECTOR at each point      C
C                  ... i.e. VF ( IPHI, ITHETA, 2 ) is the Theta      C
C                  compontent of the vector at (iphi, itheta).       C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     QST       : Output array containing scaloidal/spheroidal       C
C                  decomposition of vector c.f. eqn (38).            C
C                  Has dimensions (  LH*(LH+2) , 3).                 C
C               QST (l*l+2m,1) = q_l^ms(r_i)                         C
C    QST (l*l+2m-1+delta_m0,1) = q_l^mc(r_i)                         C
C               QST (l*l+2m,2) = s_l^ms(r_i)                         C
C    QST (l*l+2m-1+delta_m0,2) = s_l^mc(r_i)                         C
C               QST (l*l+2m,3) = t_l^ms(r_i)                         C
C    QST (l*l+2m-1+delta_m0,3) = t_l^mc(r_i)                         C
C                                                                    C
C     ZCOEF     : Coefficient of the monopole term in the R compon.  C
C                 This is not necessarily zero in general.           C
C                                                                    C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     FTF1      : Array for fourier transforming.                    C
C     FTF2      : Array for fourier transforming.                    C
C     FTF3      : Array for fourier transforming.                    C
C                  Has dimensions ( 2*NPHPTS )                       C
C                                                                    C
C None of these arrays need any input or output values but must be   C
C in parameter list for the sake of dimensioning.                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VF2QST ( QST, VF, GAUX, GAUW, PA, DPA, FTF1, FTF2,
     1                    FTF3, ZCOEF, LH, NTHPTS, NPHPTS, MMAX )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, NTHPTS, NPHPTS, MMAX
      DOUBLE PRECISION QST(  LH*(LH+2) , 3), ZCOEF,
     1                 VF( NPHPTS, NTHPTS, 3),
     2                 GAUX( NTHPTS ), GAUW( NTHPTS )
      DOUBLE PRECISION FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ), 
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IOP, ISIGN, ITHREE, ITHETA, 
     1        INDCOS, INDSIN, IP, IND1, L, M, IPHI
      DOUBLE PRECISION ZERO,X,SINE,TERM, WEIGHT, W1, W2
      PARAMETER ( ZERO = 0.0d0 , ITHREE=3 )
C____________________________________________________________________C
C Functions used :-
      DOUBLE PRECISION SQRLL1
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check the validity of arguments .....
C No need to check NPHPTS is power of 2 - this is done
C by FFTRLV ...
C ......... need to have MMAX < NPHPTS/2
C
      IF ( NTHPTS.LE.LH ) THEN
         PRINT *,' Subroutine VF2QST.'
         PRINT *,' NTHPTS must be atleast ', LH + 1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( NPHPTS.LE.(2*MMAX+1) ) THEN
         PRINT *,' Subroutine VF2QST.'
         PRINT *,' NPHPTS must be atleast ',(2*MMAX+1)
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
C_____________________________________________________________________
C
C ............ set array QST to zero .................................
      IOP = 0
      IND1 = LH*(LH+2)
      CALL MATOP ( QST, ZERO, IND1, ITHREE, IOP )
      ZCOEF = ZERO
C ....................................................................
C ...... now start to loop around theta points .......................
      DO ITHETA = 1, NTHPTS
C
C******** Evaluate lengendre functions at given theta ****************
C
         X = GAUX( ITHETA )
         SINE = DSIN ( ACOS ( X ) )
         WEIGHT = GAUW( ITHETA )
C        .
C        . Zero the arrays ftf1, ftf2 and ftf3
C        .
         IOP = 0
         IND1 = 2*NPHPTS
         CALL DVECZ( FTF1, IND1 )
         CALL DVECZ( FTF2, IND1 )
         CALL DVECZ( FTF3, IND1 )
C
C .................. firstly enter the VF information into FTF1, FTF2,
C .................. FTF3 for r, theta, phi components respectively of
C .................. VF.
C
         DO IPHI = 1, NPHPTS
            FTF1( 2*IPHI - 1 ) = VF( IPHI, ITHETA, 1 )
            FTF2( 2*IPHI - 1 ) = VF( IPHI, ITHETA, 2 )
            FTF3( 2*IPHI - 1 ) = VF( IPHI, ITHETA, 3 )
            ZCOEF = ZCOEF + WEIGHT*VF( IPHI, ITHETA, 1 )/4.0d0
         ENDDO
C .................. now perform Forward Discreet Fourier Transforms
C .................. on FTF1, FTF2, FTF3
         ISIGN = 1
         CALL FFTRLV ( FTF1, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF2, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF3, NPHPTS, ISIGN )
C ...................................................................
C .................. Now let's loop around the Harmonics. ...........
C ...................................................................
         DO L = 1, LH
            W1 = WEIGHT*(2.0d0*L + 1.0d0)/4.0d0
            W2 = W1/SQRLL1( L )
            INDCOS = L*L
C .................. Now let's loop around the order, but considering
C .................. the Case M = 0 separately. 
C ___ CASE M = 0 ___ ************************************************
            M = 0
            IP = L*(L+1)/2+M+1
            QST( INDCOS , 1 ) = QST( INDCOS , 1) +
     1                          W1*PA( IP ,ITHETA )*FTF1( 1 )
            QST( INDCOS , 2 ) = QST( INDCOS , 2) +
     1                          W2*DPA( IP ,ITHETA )*FTF2( 1 )
            QST( INDCOS , 3 ) = QST( INDCOS , 3) +
     1                          W2*DPA( IP ,ITHETA )*FTF3( 1 )
C
            INDCOS = INDCOS - 1
C
C ___ Looping around from 1 to L ___ ********************************
C
C
            DO M = 1, MIN( MMAX, L )
               IP = IP + 1
               TERM = W2*DBLE(M)*PA( IP ,ITHETA )/SINE
               INDCOS = INDCOS + 2
               INDSIN = INDCOS + 1
C                                                   ... eqn 194
C                                                       Qlm cos
C***.Equation for Qlm COS ***************************
               QST( INDCOS , 1 ) = QST( INDCOS , 1) +
     1          W1*PA( IP ,ITHETA )*FTF1( 2*M + 1)
C ..............contribution from B(rad)cos .........
C                                                   ... eqn 195
C                                                       Qlm sin
C***.Equation for Qlm SIN ***************************
               QST( INDSIN , 1 ) = QST( INDSIN , 1) +
     1          W1*PA( IP ,ITHETA )*FTF1( 2*M + 2)
C ..............contribution from B(rad)sin .........
C                                                   ... eqn 203
C                                                       Slm cos
C***.Equation for Slm COS ***************************
               QST( INDCOS , 2 ) = QST( INDCOS , 2) +
     1          W2*DPA( IP ,ITHETA )*FTF2( 2*M + 1 ) -
     2          TERM*FTF3( 2*M + 2 )
C ..............contribution from B(theta)cos .......
C ..............contribution from B(phi)sin .........
C                                                   ... eqn 204
C                                                       Slm sin
C***.Equation for Slm SIN ***************************
               QST( INDSIN , 2 ) = QST( INDSIN , 2) +
     1          W2*DPA( IP ,ITHETA )*FTF2( 2*M + 2 ) +
     2          TERM*FTF3( 2*M + 1 )
C ..............contribution from B(theta)sin .......
C ..............contribution from B(phi)cos .........
C                                                   ... eqn 206
C                                                       Tlm cos
C***.Equation for Tlm COS ***************************
               QST( INDCOS , 3 ) = QST( INDCOS , 3) +
     1          W2*DPA( IP ,ITHETA )*FTF3( 2*M + 1 ) +
     2          TERM*FTF2( 2*M + 2 )
C ..............contribution from B(phi)cos .........
C ..............contribution from B(theta)sin .......
C                                                   ... eqn 207
C                                                       Tlm sin
C***.Equation for Tlm SIN ***************************
               QST( INDSIN , 3 ) = QST( INDSIN , 3) -
     1          TERM*FTF2( 2*M + 1 ) +
     2          W2*DPA( IP ,ITHETA )*FTF3( 2*M + 2 )
C ..............contribution from B(theta)cos .......
C ..............contribution from B(phi)sin .........
C
            ENDDO
C
C
C Done looping around from 1 to L ___ *******************************
C
C
         ENDDO
C ...................................................................
C .................. Ended looping around the harmonics .............
C ...................................................................
      ENDDO
C ...... ended looping around theta points ...........................
C ....................................................................
      ZCOEF = 2.0d0*ZCOEF/DBLE(NPHPTS)
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Solution Vector DeRivative **********************
C            -       -        -      - -        **********************
C Steve Gibbons Mon Oct 25 15:17:59 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C V is a solution vector with NH (= inarr(3) ) harmonic radial       C
C functions and NR (= inarr(2) ) grid nodes in each function.        C
C The position of the j^{th} node of the i^{th} harmonic is given by C
C INDFUN( j, i, INARR) and the radial value is given by              C
C  XARR( j ) - an array which is passed to the routine FDCMBD        C
C in order to calculate the finite difference coefficients, FDCM.    C
C XARR itself is not referenced by ASVDR.                            C
C ASVDR returns the radial derivatives 0, 1, ..., IHD of radial      C
C function IH evaluated at node IR.                                  C
C                                                                    C
C IFORMF = INARR(1) should be either 3 or 4 since this is the        C
C arbitrarily spaced mesh version of the code.                       C
C                                                                    C
C NBN is the maximum number of nodes on                              C
C either side which maybe used in central differences.               C
C For instance, if to calculate the derivative of                    C
C f at r_j, you may use the values of f at r = r_{j-2}, r_{j-1},     C
C r_j, r_{j+1} and r_{j+2} then NBN = 2. The value of IHD is checked C
C only for being positive and no greater than NDRVS (the             C
C number of the highest derivative for which coefficients            C
C are stored by the array SVFDC), as SVFDC must be calculated in     C
C advance by a call to SVFDCF which checks NDRVS against             C
C the physical restrictions imposed by the value of NBN.             C
C                                                                    C
C NDRVM restricts the size of NDRVS and is a defining parameter      C
C of the array SVFDCF.                                               C
C                                                                    C
C NBN must be as supplied to SVFDCF.                                 C
C                                                                    C
C IS must be supplied to indicate the finite difference scheme       C
C being employed.                                                    C
C                                                                    C
C ASVDR will use whichever coefficients SVFDC( k, j, nd + 1, K ),    C
C that SVFDCF formed with K = IS.                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IR        : Number of radial grid node.                        C
C     IS        : Number of finite difference scheme used.           C
C     IH        : Number of radial function (harmonic).              C
C     NBN       : Number of bounding nodes. See above.               C
C     IHD       : Highest derivative requested.                      C
C     NFDCM     : Leading dimension of SVFDC. At least (2*NBN+1)     C
C     NR        : Number of radial grid nodes in each function.      C
C     NDRVS     : Number of highest derivative for which             C
C                  coefficients are stored by the array SVFDC.       C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C     INARR     : Integer array dimension ( * ).                     C
C                  Elements may be arbitrary except for              C
C                  INARR( 1 ) = IFORMF - flag for vector format.     C
C                                        See INDFUN                  C
C                  INARR( 2 ) = NRR. Must be consistent with NR.     C
C                  INARR( 3 ) = NH = total number of radial func.s   C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     V         : Solution vector. Dim ( * ) but length atleast      C
C                  NR*NH.                                            C
C     DERV      : Derivatives. Dim ( * ) but length atleast IHD      C
C                  DERV( i ) is returned containing the value of     C
C                  the i^[th} derivative.                            C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE ASVDR ( V, IR, IS, IH, NBN, IHD, NFDCM, NR, NDRVS,
     1                   NDRVM, DERV, INARR, SVFDC, NDCS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IR, IS, IH, NBN, IHD, NFDCM, NR, NDRVS, NDRVM,
     1        INARR( * ), NDCS
      DOUBLE PRECISION V( * ), DERV( * ), 
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      DOUBLE PRECISION COEF
      INTEGER INODE, ILN, IRN, INDFUN, ID, IND, NRR, IFORMF, IK, ID1
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check input parameters ...
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
C
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine ASVDR.'
         PRINT *,' INARR( 2 ) = ', NRR
         PRINT *,' NR = ', NR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( IFORMF.NE.3 .AND. IFORMF.NE.4 ) THEN
         PRINT *,' Subroutine ASVDR.'
         PRINT *,' INARR( 1 ) = ', IFORMF
         PRINT *,' This is an irregular grid routine.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( IR.LT.1 .OR. IR.GT.NR ) THEN
        PRINT *,' Subroutine ASVDR.'
        PRINT *,' IR   = ', IR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( IHD.LT.0 .OR. IHD.GT.NDRVS .OR. NDRVS.GT.NDRVM ) THEN
        PRINT *,' Subroutine ASVDR.'
        PRINT *,' IHD   = ', IHD
        PRINT *,' NDRVS = ', NDRVS
        PRINT *,' NDRVM = ', NDRVM
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( IS.LT.1 .OR. IS.GT.NDCS ) THEN
        PRINT *,' Subroutine ASVDR.'
        PRINT *,' IS    = ', IS
        PRINT *,' NDCS  = ', NDCS
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Calculate furthest left and furthest right mode
C     . to be used to form derivative.
C     .
      ILN = MAX(  1, IR - NBN )
      IRN = MIN( NR, IR + NBN )
C
      DO ID = 0, IHD
        ID1 = ID + 1
        DERV( ID1 ) = 0.0d0
        DO INODE = ILN, IRN
          IK = INODE - IR + NBN + 1
          COEF = SVFDC( IK, IR, ID1, IS )
          IND = INDFUN( INODE, IH, INARR )
          DERV( ID1 ) = DERV( ID1 ) + COEF*V( IND )
        ENDDO
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Radial QST to Vector Function ***************************
C            -      ---    -      -        ***************************
C Steve Gibbons Mon Sep 27 10:17:06 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum spherical harmonic order, m.               C
C     NR        : Number of radial grid nodes.                       C
C     IR        : Current radial grid node.                          C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C                                                                    C
C     RQST      : Input array containing scaloidal/spheroidal        C
C                  decomposition of vector.                          C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C     ZCOEFA    : Coefficients of the monopole term in the R compon. C
C                 This is not necessarily zero in general.           C
C                 Dimension ( NR )                                   C
C                                                                    C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF	: Vector Function. An array of dimensions            C
C		   ( NPHPTS, NTHPTS, 3) which contain the R, THETA   C
C 		   and PHI components of a VECTOR at each point      C
C                  ... i.e. VF ( IPHI, ITHETA, 2 ) is the Theta      C
C                  compontent of the vector at (iphi, itheta).       C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     FTF1      : Array for fourier transforming.                    C
C     FTF2      : Array for fourier transforming.                    C
C     FTF3      : Array for fourier transforming.                    C
C                  Has dimensions ( 2*NPHPTS )                       C
C                                                                    C
C None of these arrays need any input or output values but must be   C
C in parameter list for the sake of dimensioning.                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RQSTVF ( RQST, VF, GAUX, PA, DPA, FTF1, FTF2, FTF3,
     1                    LH, NTHPTS, NPHPTS, MMAX, ZCOEFA, NR, IR )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, NTHPTS, NPHPTS, MMAX, NR, IR
      DOUBLE PRECISION RQST(  LH*(LH+2) ,3 ,NR ), ZCOEFA( NR ),
     1                 VF( NPHPTS, NTHPTS, 3), GAUX( NTHPTS )
      DOUBLE PRECISION FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IOP, ISIGN, ITHREE, ITHETA, LENV, IPHI, 
     1        IP, IND1, IND2,  L, M, INDFTC, INDFTS
      DOUBLE PRECISION ZERO,X,SINE,TERM1, TERM2
      PARAMETER ( ZERO = 0.0d0 , ITHREE=3 )
C____________________________________________________________________C
C Functions used :-
c     INTEGER INDSHC
      DOUBLE PRECISION SQRLL1
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C   
C Check the validity of arguments .....
C No need to check NPHPTS is power of 2 - this is done
C by FFTRLV ...
C ......... need to have MMAX < NPHPTS/2
C
      IF ( NTHPTS.LE.LH ) THEN
         PRINT *,' Subroutine RQSTVF.'
         PRINT *,' NTHPTS must be atleast ', LH + 1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( NPHPTS.LE.(2*MMAX+1) ) THEN
         PRINT *,' Subroutine RQSTVF.'
         PRINT *,' NPHPTS must be atleast ',(2*MMAX+1)
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IOP = 0
C ............. set VF array to zero
      CALL CUBEOP ( VF, ZERO, NPHPTS, NTHPTS, ITHREE, IOP )

C ............. start to loop around theta points ...................
      DO ITHETA = 1, NTHPTS
C
         X = GAUX( ITHETA )
         SINE = DSIN( ACOS( X ) )
C
C ............. set FTF1, FTF2, FTF3 all to zero
         LENV = 2*NPHPTS
C
         CALL VECOP ( FTF1, ZERO, LENV, IOP )
         CALL VECOP ( FTF2, ZERO, LENV, IOP )
         CALL VECOP ( FTF3, ZERO, LENV, IOP )
C
C ............. start to loop around Harmonics ......................
         
         M = 0
         DO L = 1, LH
            IP = L*(L+1)/2+M+1
            FTF1( 1 ) = FTF1( 1 ) 
     1                   + PA( IP, ITHETA )*RQST( L*L , 1, IR )
            FTF2( 1 ) = FTF2( 1 ) 
     1            + DPA( IP, ITHETA )*RQST( L*L, 2, IR)/SQRLL1(L)
            FTF3( 1 ) = FTF3( 1 ) 
     1            + DPA( IP, ITHETA )*RQST( L*L, 3, IR)/SQRLL1(L)
         ENDDO
C ................. end of case M = 0
         DO M = 1, MIN( LH, MMAX )
            INDFTC = 2*M + 1
            INDFTS = 2*M + 2
            DO L = M, LH
               IP = L*(L+1)/2+M+1
c              ICS = 1
c              IND1 = INDSHC( L, M, ICS )
               IND1 = L*L + 2*M - 1
c              ICS = 2
c              IND2 = INDSHC( L, M, ICS )
               IND2 = L*L + 2*M
               TERM1 = M*PA( IP , ITHETA )/( SINE*SQRLL1( L ) )
               TERM2 = DPA( IP , ITHETA )/SQRLL1( L )
C
               FTF1( INDFTC ) = FTF1( INDFTC ) +
     1          PA( IP, ITHETA )*RQST( IND1, 1, IR )
               FTF1( INDFTS ) = FTF1( INDFTS ) +
     1          PA( IP, ITHETA )*RQST( IND2, 1, IR )
               FTF2( INDFTC ) = FTF2( INDFTC ) +
     1          TERM2*RQST( IND1, 2, IR ) - TERM1*RQST( IND2, 3, IR)
               FTF2( INDFTS ) = FTF2( INDFTS ) +
     1          TERM2*RQST( IND2, 2, IR ) + TERM1*RQST( IND1, 3, IR)
               FTF3( INDFTC ) = FTF3( INDFTC ) +
     1          TERM2*RQST( IND1, 3, IR ) + TERM1*RQST( IND2, 2, IR)
               FTF3( INDFTS ) = FTF3( INDFTS ) +
     1          TERM2*RQST( IND2, 3, IR ) - TERM1*RQST( IND1, 2, IR)
C
            ENDDO
         ENDDO
C ............. ended looping around Harmonics ......................
C
C ............... now perform Fourier Transforms on FTF1, FTF2, FTF3
C
         ISIGN = -1
         CALL FFTRLV ( FTF1, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF2, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF3, NPHPTS, ISIGN )
C
C ...................................................................
         DO IPHI = 1, NPHPTS
           VF ( IPHI, ITHETA, 1 ) = FTF1( 2*IPHI - 1 ) + ZCOEFA( IR )
           VF ( IPHI, ITHETA, 2 ) = FTF2( 2*IPHI - 1 )
           VF ( IPHI, ITHETA, 3 ) = FTF3( 2*IPHI - 1 )
         ENDDO
C
      ENDDO
C ............. ended looping around theta points ...................
C
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine GRadient INVerse Transform ******************************
C            --       ---     -         ******************************
C Steve Gibbons 8.7.97                                               C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     SHC       : Spherical Harmonic Coefficients.                   C
C                  Has the usual ordering.                           C
C                   SHC( l*l ) = P_l^0                               C
C                   SHC( l*l + 2*m - 1 ) = P_l^mc ( m non zero )     C
C                   SHC( l*l + 2*m ) = P_l^ms ( m non zero )         C
C                  Dimension is ( LH*( LH + 2) )                     C
C     DSHC	: Radial derivatives of the above.                   C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     RAD	: Radial value at which function is to be evaluated. C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2,NTHPTS)       C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C     DZCOEF	: Derivative of l=0 harmonic radial function.        C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum spherical harmonic order, m.               C
C                                                                    C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GRFN	: GRadient FuNction                                  C
C                 has dimensions ( NPHPTS, NTHPTS , 3 )              C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     FTF1      : Array for fourier transforming.                    C
C     FTF2      : Array for fourier transforming.                    C
C     FTF3      : Array for fourier transforming.                    C
C                  Have dimensions ( 2*NPHPTS )                      C
C                                                                    C
C None of these arrays need any input or output values but must be   C
C in parameter list for the sake of dimensioning.                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE GRINVT ( SHC, DSHC, GAUX, RAD, PA, DPA, FTF1, FTF2,
     1                    FTF3, GRFN, LH, NTHPTS, NPHPTS,
     2                    MMAX, DZCOEF )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, NTHPTS, NPHPTS, MMAX
      DOUBLE PRECISION RAD, SHC( LH*( LH + 2) ),
     1                 DSHC( LH*( LH + 2) ),
     2                 GRFN( NPHPTS, NTHPTS , 3 ),
     3                 GAUX( NTHPTS ), DZCOEF
      DOUBLE PRECISION FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2, NTHPTS ),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2, NTHPTS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IOP, ISIGN, ITHREE, ITHETA, LENV, IPHI,
     1        IP, L, M, IND1, IND2, IND
      DOUBLE PRECISION ZERO,X,SINE,THETA,PSI, DPSI, PSI2, DPSI2,
     1                 TOL
      PARAMETER ( ZERO = 0.0d0, ITHREE=3, TOL = 1.0d-6 )
C____________________________________________________________________C
C Functions used :-
c     INTEGER INDSHC
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check the validity of arguments .....
C No need to check NPHPTS is power of 2 - this is done
C by FFTRLV ...
C ......... need to have MMAX < NPHPTS/2
C
      IF ( NTHPTS.LE.LH ) THEN
         PRINT *,' Subroutine GRINVT.'
         PRINT *,' NTHPTS must be atleast ', LH + 1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( NPHPTS.LE.(2*MMAX+1) ) THEN
         PRINT *,' Subroutine GRINVT.'
         PRINT *,' NPHPTS must be atleast ',(2*MMAX+1)
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
C Pre-empt a division by zero with RAD
C
      IF ( ABS( RAD ).LT.TOL ) THEN
         PRINT *,' Subroutine GRINVT.'
         PRINT *,' RAD = ', RAD,' Division by zero imminent.'
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IOP = 0
      ISIGN = -1
C ............. set GRFN array to zero
      CALL CUBEOP ( GRFN, ZERO, NPHPTS, NTHPTS, ITHREE, IOP )
C
C ............. start to loop around theta points ...................
      DO ITHETA = 1, NTHPTS
         X = GAUX( ITHETA )
         THETA = ACOS( X )
         SINE = DSIN( THETA )
C
C ............. set FTF1, FTF2, FTF3 all to zero
         LENV = 2*NPHPTS
         CALL VECOP ( FTF1, ZERO, LENV, IOP )
         CALL VECOP ( FTF2, ZERO, LENV, IOP )
         CALL VECOP ( FTF3, ZERO, LENV, IOP )
C
C ............. start to loop around Harmonics ......................
C   						 ... case of M = 0 ..
         M = 0
         DO L = 1, LH
            IP = L*(L+1)/2+M+1
c           ICS = 1
c           IND = INDSHC( L, M, ICS )
            IND = L*L
            PSI = SHC( IND )
            DPSI = DSHC( IND )
            FTF1( 1 ) = FTF1( 1 ) + DPSI*PA( IP, ITHETA )
            FTF2( 1 ) = FTF2( 1 ) + PSI*DPA( IP, ITHETA )/RAD
         ENDDO
C					     ... end of case M = 0 ..
         DO M = 1, MIN( LH, MMAX )
            IND1 = 2*M + 1
            IND2 = 2*M + 2
            DO L = M, LH
               IP = L*(L+1)/2+M+1
c              ICS = 1
c              IND = INDSHC( L, M, ICS )
               IND = L*L + 2*M - 1
               PSI = SHC( IND )
               DPSI = DSHC( IND )
c              ICS = 2
c              IND = INDSHC( L, M, ICS )
               IND = L*L + 2*M
               PSI2 = SHC( IND )
               DPSI2 = DSHC( IND )
C
C ........( a little note ... here PSI = PSI_l^(mc) and PSI2 is
C ......... of course PSI_l^(ms) .............................)
C
C              ................................. radial component
               FTF1( IND1 ) = FTF1( IND1 ) + DPSI*PA(IP,ITHETA)
               FTF1( IND2 ) = FTF1( IND2 ) + DPSI2*PA(IP,ITHETA)
C              ................................. theta component
               FTF2( IND1 ) = FTF2( IND1 ) +
     1          DPA( IP, ITHETA )*PSI/RAD
               FTF2( IND2 ) = FTF2( IND2 ) +
     1          DPA( IP, ITHETA )*PSI2/RAD
C              ................................. phi component
               FTF3( IND1 ) = FTF3( IND1 ) +
     1          PSI2*PA( IP, ITHETA )*M/(RAD*SINE)
               FTF3( IND2 ) = FTF3( IND2 ) -
     1          PSI*PA( IP, ITHETA )*M/(RAD*SINE)
C 
            ENDDO
         ENDDO
C ............. ended looping around Harmonics ......................
C 
C ............... now perform Fourier Transforms on FTF1, FTF2, FTF3
         CALL FFTRLV ( FTF1, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF2, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF3, NPHPTS, ISIGN )
C ...................................................................
         DO IPHI = 1, NPHPTS
            GRFN ( IPHI, ITHETA, 1 ) = FTF1( 2*IPHI - 1 ) +
     1                                   DZCOEF
            GRFN ( IPHI, ITHETA, 2 ) = FTF2( 2*IPHI - 1 )
            GRFN ( IPHI, ITHETA, 3 ) = FTF3( 2*IPHI - 1 )
         ENDDO
C
      ENDDO
C ............. ended looping around theta points ...................
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Vector Function CORiolis force **************************
C            -      -        ---            **************************
C Steve Gibbons 5.5.97                                               C
C____________________________________________________________________C
C Calculates coriolis vector CORV = K x V of V.                      C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VF        : Vector Function. An array of dimensions            C
C                  ( NPHPTS, NTHPTS, 3) which contain the R, THETA   C
C                  and PHI components of a VECTOR at each point      C
C                  ... i.e. VF ( IPHI, ITHETA, 2 ) is the Theta      C
C                  compontent of the vector at (iphi, itheta).       C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VFCOR ( NTHPTS, NPHPTS, VF, GAUX )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NTHPTS, NPHPTS
      DOUBLE PRECISION VF ( NPHPTS, NTHPTS, 3)
      DOUBLE PRECISION GAUX ( NTHPTS )
C____________________________________________________________________C
C Variable Declarations - Working Variables .........................C
      INTEGER ITHETA, IPHI
      DOUBLE PRECISION VR,VTHE,VPHI,COSTH,SINTH,THETA
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C ............. loop around theta and phi points .....................
      DO ITHETA = 1, NTHPTS
         COSTH = GAUX( ITHETA )
         THETA = ACOS( COSTH )
         SINTH = DSIN( THETA )
         DO IPHI = 1, NPHPTS
            VR = VF ( IPHI, ITHETA, 1 )
            VTHE = VF ( IPHI, ITHETA, 2 )
            VPHI = VF ( IPHI, ITHETA, 3 )
            VF ( IPHI, ITHETA, 1 ) = -SINTH*VPHI
            VF ( IPHI, ITHETA, 2 ) = -COSTH*VPHI
            VF ( IPHI, ITHETA, 3 ) = COSTH*VTHE + SINTH*VR
         ENDDO
      ENDDO
C ............. ended looping around theta, phi points ...............
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Vector Function to Radial QST coefficients **************
C            -      -           -      ---              **************
C Steve Gibbons Mon Sep 27 09:41:55 BST 1999                         C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NTHPTS    : Number of theta points.                            C
C     NPHPTS    : Number of phi points.                              C
C     LH        : Maximum spherical harmonic degree, l.              C
C     MMAX      : Maximum spherical harmonic order, m.               C
C     NR        : Number of radial grid nodes.                       C
C     IR        : Current radial grid node.                          C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     GAUW      : Corresponding weights. As above.                   C
C     VF        : Vector Function. An array of dimensions            C
C                  ( NPHPTS, NTHPTS, 3) which contain the R, THETA   C
C                  and PHI components of a VECTOR at each point      C
C                  ... i.e. VF ( IPHI, ITHETA, 2 ) is the Theta      C
C                  compontent of the vector at (iphi, itheta).       C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     RQST      : Output array containing scaloidal/spheroidal       C
C                  decomposition of vector.                          C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C     ZCOEFA    : Coefficients of the monopole term in the R compon. C
C                 This is not necessarily zero in general.           C
C                 Dimension ( NR )                                   C
C                                                                    C
C____________________________________________________________________C
C Passed in arrays :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     FTF1      : Array for fourier transforming.                    C
C     FTF2      : Array for fourier transforming.                    C
C     FTF3      : Array for fourier transforming.                    C
C                  Has dimensions ( 2*NPHPTS )                       C
C                                                                    C
C None of these arrays need any input or output values but must be   C
C in parameter list for the sake of dimensioning.                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VFRQST ( RQST, VF, GAUX, GAUW, PA, DPA, FTF1, FTF2,
     1                    FTF3, ZCOEFA, LH, NTHPTS, NPHPTS, MMAX,
     2                    NR, IR )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER LH, NTHPTS, NPHPTS, MMAX, NR, IR
      DOUBLE PRECISION RQST(  LH*(LH+2) , 3, NR), ZCOEFA( NR ),
     1                 VF( NPHPTS, NTHPTS, 3),
     2                 GAUX( NTHPTS ), GAUW( NTHPTS )
      DOUBLE PRECISION FTF1( 2*NPHPTS ),
     1                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS ), 
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER ISIGN, ITHREE, ITHETA, 
     1        INDCOS, INDSIN, IP, IND1, L, M, IPHI, I1, I2
      DOUBLE PRECISION ZERO,X,SINE,TERM, WEIGHT, W1, W2
      PARAMETER ( ZERO = 0.0d0 , ITHREE=3 )
C____________________________________________________________________C
C Functions used :-
      DOUBLE PRECISION SQRLL1
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check the validity of arguments .....
C No need to check NPHPTS is power of 2 - this is done
C by FFTRLV ...
C ......... need to have MMAX < NPHPTS/2
C
      IF ( NTHPTS.LE.LH ) THEN
         PRINT *,' Subroutine VFRQST.'
         PRINT *,' NTHPTS must be atleast ', LH + 1
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( NPHPTS.LE.(2*MMAX+1) ) THEN
         PRINT *,' Subroutine VFRQST.'
         PRINT *,' NPHPTS must be atleast ',(2*MMAX+1)
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C
      IF ( IR.LT.1 .OR. IR.GT.NR ) THEN
         PRINT *,' Subroutine VFRQST.'
         PRINT *,' IR = ', IR,' NR = ', NR
         PRINT *,' Program stopped.'
         STOP
      ENDIF
C_____________________________________________________________________
C
C ............ set array RQST at node IR to zero .....................
      IND1 = LH*(LH+2)
      DO I2 = 1, ITHREE
        DO I1 = 1, IND1
          RQST( I1, I2, IR ) = ZERO
        ENDDO
      ENDDO
      ZCOEFA( IR ) = 0.0d0
C ....................................................................
C ...... now start to loop around theta points .......................
      DO ITHETA = 1, NTHPTS
C
C******** Evaluate lengendre functions at given theta ****************
C
         X = GAUX( ITHETA )
         SINE = DSIN ( ACOS ( X ) )
         WEIGHT = GAUW( ITHETA )
C        .
C        . Zero the arrays ftf1, ftf2 and ftf3
C        .
         IND1 = 2*NPHPTS
         CALL DVECZ( FTF1, IND1 )
         CALL DVECZ( FTF2, IND1 )
         CALL DVECZ( FTF3, IND1 )
C
C .................. firstly enter the VF information into FTF1, FTF2,
C .................. FTF3 for r, theta, phi components respectively of
C .................. VF.
C
         DO IPHI = 1, NPHPTS
            FTF1( 2*IPHI - 1 ) = VF( IPHI, ITHETA, 1 )
            FTF2( 2*IPHI - 1 ) = VF( IPHI, ITHETA, 2 )
            FTF3( 2*IPHI - 1 ) = VF( IPHI, ITHETA, 3 )
            ZCOEFA( IR ) = ZCOEFA( IR ) +
     1                   WEIGHT*VF( IPHI, ITHETA, 1 )/4.0d0
         ENDDO
C .................. now perform Forward Discreet Fourier Transforms
C .................. on FTF1, FTF2, FTF3
         ISIGN = 1
         CALL FFTRLV ( FTF1, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF2, NPHPTS, ISIGN )
         CALL FFTRLV ( FTF3, NPHPTS, ISIGN )
C ...................................................................
C .................. Now let's loop around the Harmonics. ...........
C ...................................................................
         DO L = 1, LH
            W1 = WEIGHT*(2.0d0*L + 1.0d0)/4.0d0
            W2 = W1/SQRLL1( L )
            INDCOS = L*L
C .................. Now let's loop around the order, but considering
C .................. the Case M = 0 separately. 
C ___ CASE M = 0 ___ ************************************************
            M = 0
            IP = L*(L+1)/2+M+1
            RQST( INDCOS, 1, IR ) = RQST( INDCOS, 1, IR) +
     1                          W1*PA( IP, ITHETA )*FTF1( 1 )
            RQST( INDCOS, 2, IR ) = RQST( INDCOS, 2, IR) +
     1                          W2*DPA( IP, ITHETA )*FTF2( 1 )
            RQST( INDCOS, 3, IR ) = RQST( INDCOS, 3, IR) +
     1                          W2*DPA( IP, ITHETA )*FTF3( 1 )
C
            INDCOS = INDCOS - 1
C
C ___ Looping around from 1 to L ___ ********************************
C
C
            DO M = 1, MIN( MMAX, L )
               IP = IP + 1
               TERM = W2*DBLE(M)*PA( IP ,ITHETA )/SINE
               INDCOS = INDCOS + 2
               INDSIN = INDCOS + 1
C                                                   ... eqn 194
C                                                       Qlm cos
C***.Equation for Qlm COS ***************************
               RQST( INDCOS, 1, IR ) = RQST( INDCOS, 1, IR) +
     1          W1*PA( IP, ITHETA )*FTF1( 2*M + 1)
C ..............contribution from B(rad)cos .........
C                                                   ... eqn 195
C                                                       Qlm sin
C***.Equation for Qlm SIN ***************************
               RQST( INDSIN, 1, IR ) = RQST( INDSIN, 1, IR) +
     1          W1*PA( IP, ITHETA )*FTF1( 2*M + 2)
C ..............contribution from B(rad)sin .........
C                                                   ... eqn 203
C                                                       Slm cos
C***.Equation for Slm COS ***************************
               RQST( INDCOS, 2, IR ) = RQST( INDCOS, 2, IR) +
     1          W2*DPA( IP, ITHETA )*FTF2( 2*M + 1 ) -
     2          TERM*FTF3( 2*M + 2 )
C ..............contribution from B(theta)cos .......
C ..............contribution from B(phi)sin .........
C                                                   ... eqn 204
C                                                       Slm sin
C***.Equation for Slm SIN ***************************
               RQST( INDSIN, 2, IR ) = RQST( INDSIN, 2, IR) +
     1          W2*DPA( IP, ITHETA )*FTF2( 2*M + 2 ) +
     2          TERM*FTF3( 2*M + 1 )
C ..............contribution from B(theta)sin .......
C ..............contribution from B(phi)cos .........
C                                                   ... eqn 206
C                                                       Tlm cos
C***.Equation for Tlm COS ***************************
               RQST( INDCOS, 3, IR ) = RQST( INDCOS, 3, IR) +
     1          W2*DPA( IP, ITHETA )*FTF3( 2*M + 1 ) +
     2          TERM*FTF2( 2*M + 2 )
C ..............contribution from B(phi)cos .........
C ..............contribution from B(theta)sin .......
C                                                   ... eqn 207
C                                                       Tlm sin
C***.Equation for Tlm SIN ***************************
               RQST( INDSIN, 3, IR ) = RQST( INDSIN, 3, IR) -
     1          TERM*FTF2( 2*M + 1 ) +
     2          W2*DPA( IP, ITHETA )*FTF3( 2*M + 2 )
C ..............contribution from B(theta)cos .......
C ..............contribution from B(phi)sin .........
C
            ENDDO
C
C
C Done looping around from 1 to L ___ *******************************
C
C
         ENDDO
C ...................................................................
C .................. Ended looping around the harmonics .............
C ...................................................................
      ENDDO
C ...... ended looping around theta points ...........................
C ....................................................................
      ZCOEFA( IR ) = 2.0d0*ZCOEFA( IR )/DBLE(NPHPTS)
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Radial QST DeRivative ***********************************
C            -      --- - -        ***********************************
C Steve Gibbons Tue Sep 28 11:27:29 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Calculates a derivative of a radial function to a harmonic         C
C in the RQST array.                                                 C
C                                                                    C
C NBN is the maximum number of nodes on                              C
C either side which maybe used in central differences.               C
C For instance, if to calculate the derivative of                    C
C f at r_j, you may use the values of f at r = r_{j-2}, r_{j-1},     C
C r_j, r_{j+1} and r_{j+2} then NBN = 2. The value of IHD is checked C
C only for being positive and no greater than NDVDS (the             C
C number of the highest derivative for which coefficients            C
C are stored by the array FDCM), as FDCM must be calculated in       C
C advance by a call to FDCMBD which checks NDVDS against             C
C the physical restrictions imposed by the value of NBN, ILNC and    C
C IRNC; which are respectively the furthest left and furthest right  C
C nodes which may be used to calculate derivatives and are the       C
C same values which must be supplied to FDCMBD as NLMC and NRMC.     C
C                                                                    C
C NBN must be as supplied to FDCMBD.                                 C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IR        : Number of radial grid node.                        C
C     IH        : Number of radial function (harmonic).              C
C                 Given as a function of l, m etc. by INDSHC         C
C                                                                    C
C     ICOMP     : 1 for Q, 2 for S and 3 for T.                      C
C                                                                    C
C     NBN       : Number of bounding nodes. See above.               C
C     IHD       : Highest derivative requested.                      C
C     NFDCM     : Leading dimension of FDCM. At least (2*NBN+1)      C
C     NR        : Number of radial grid nodes in each function.      C
C     LH        : Maximum value of degree, l.                        C
C     NDVDS     : Number of highest derivative for which             C
C                  coefficients are stored by the array FDCM.        C
C     ILNC      : Number of left most node which can be used to      C
C                     calculate derivatives.                         C
C     IRNC      : Number of right most node which can be used to     C
C                     calculate derivatives.                         C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     RQST      : Dim ( LH*(LH+2), 3, NR )                           C
C                                                                    C
C                 Input array containing scaloidal/spheroidal        C
C                  decomposition of vector.                          C
C                  Has dimensions (  LH*(LH+2) ,3, NR ).             C
C              RQST (l*l+2m,1,I) = q_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,1,I) = q_l^mc(r_i)                       C
C              RQST (l*l+2m,2,I) = s_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,2,I) = s_l^mc(r_i)                       C
C              RQST (l*l+2m,3,I) = t_l^ms(r_i)                       C
C   RQST (l*l+2m-1+delta_m0,3,I) = t_l^mc(r_i)                       C
C                                                                    C
C                                                                    C
C     DERV      : Derivatives. Dim ( * ) but length atleast IHD      C
C                  DERV( i ) is returned containing the value of     C
C                  the i^[th} derivative.                            C
C                                                                    C
C     FDCM      : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVS ).                   C
C                   Array is generated by the routine fdcmbd         C
C                 See documentation for FDCMBD for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE RQSTDR ( RQST, IR, IH, NBN, IHD, NFDCM, NR, NDVDS,
     1                    DERV, ILNC, IRNC, FDCM, LH, ICOMP )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IR, IH, NBN, IHD, NFDCM, NR, NDVDS, ILNC, IRNC, LH,
     1        ICOMP
      DOUBLE PRECISION RQST( LH*(LH+2), 3, NR ), DERV( * ), 
     1                 FDCM( NFDCM, NR, NDVDS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      DOUBLE PRECISION COEF, FAC
      INTEGER INODE, ILN, IRN, ID, IK
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Check input parameters ...
C
      IF ( IH.LT.1 .OR. IH.GT.(LH*LH + 2*LH) ) THEN
        PRINT *,' Subroutine RQSTDR.'
        PRINT *,' IH   = ', IH
        PRINT *,' LH   = ', LH
        PRINT *,' NH   = ', LH*(LH+2)
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( IR.LT.ILNC .OR. IR.GT.IRNC ) THEN
        PRINT *,' Subroutine RQSTDR.'
        PRINT *,' IR   = ', IR
        PRINT *,' ILNC = ', ILNC
        PRINT *,' IRNC = ', IRNC
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( IHD.LT.1 .OR. IHD.GT.NDVDS ) THEN
        PRINT *,' Subroutine RQSTDR.'
        PRINT *,' IHD   = ', IHD
        PRINT *,' NDVDS = ', NDVDS
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      IF ( ICOMP.NE.1 .AND. ICOMP.NE.2 .AND. ICOMP.NE.3 ) THEN
        PRINT *,' Subroutine RQSTDR.'
        PRINT *,' ICOMP = ', ICOMP
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Calculate furthest left and furthest right mode
C     . to be used to form derivative.
C     .
      ILN = MAX( ILNC, IR - NBN )
      IRN = MIN( IRNC, IR + NBN )
C
      DO ID = 1, IHD
        DERV( ID ) = 0.0d0
        DO INODE = ILN, IRN
          IK = INODE - IR + NBN + 1
          COEF = FDCM( IK, IR, ID )
          FAC  = RQST( IH, ICOMP, INODE )
          DERV( ID ) = DERV( ID ) + COEF*FAC
        ENDDO
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Adapted Matrix LaPlacian ********************************
C            -       -      - -       ********************************
C Steve Gibbons Wed Oct 27 07:04:48 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds FAC to all the elements of the matrix A which will add the    C
C laplacian of all harmonics IHI in solution vector VI (which        C
C satisfy MHTI( IHI ) = ICMP) to the corresponding harmonics IHO in  C
C vector VO (with MHTO( IHO ) = ICMP).                               C
C                                                                    C
C Multiplying VI by A (to form VO) should have the same result as    C
C calling NGSVLP with VI and VO.                                     C
C                                                                    C
C                                                                    C
C Now MHTI defines what each scalar function in a solution vector    C
C represents.                                                        C
C                                                                    C
C         MHTI( IH ) = 1 --> harmonic is poloidal velocity           C
C         MHTI( IH ) = 2 --> harmonic is toroidal velocity           C
C         MHTI( IH ) = 3 --> harmonic is temperature.                C
C         MHTI( IH ) = 4 --> harmonic is poloidal magnetic field     C
C         MHTI( IH ) = 5 --> harmonic is toroidal magnetic field     C
C                                                                    C
C The lapacian of a scalar with radial function f(r)                 C
C is a scalar with radial function D_l f(r) - l is degree of S.H.    C
C                                                                    C
C The lapacian of a toroidal harmonic with radial function f(r)      C
C is toroidal with radial function D_l f(r) - l is degree of S.H.    C
C                                                                    C
C The lapacian of a poloidal harmonic with radial function f(r)      C
C is poloidal with radial function D_l f(r) - l is degree of S.H.    C
C                                                                    C
C  This routine is therefore valid for all forms of harmonics        C
C (itype = 1, 2, 3, 4 and 5) and the result must go in the same      C
C type of harmonic as the original.                                  C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     INARR     : Int. parameter array corresponding to VI and VO.   C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR     See INDFUN for details        C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NH             C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NH             C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NH             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHPI      : Array length ( * ) - atleast length NHI            C
C                  Pointer array to finite difference coefficients.  C
C                  MHPI( ih ) = is, which is the 4th index of        C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     ICMP     : The type of harmonic we wish to take curl of.       C
C                                                 see above.         C
C                                                                    C
C     Note that MHTO, MHLO and MHMO correspond to                    C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C                (Not needed if we are doing tor --> pol but         C
C                 must be atleast 2 if doing pol --> tor )           C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C     IMF       : Matrix format flag. (See MATIND)                   C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMLP( NR, INARR, MHTI, MHLI, MHMI, MHPI, ICMP, MHTO,
     1                 MHLO, MHMO, FAC, NBN, NDRVS, NDRVM, NFDCM,
     2                 ILNR, IRNR, SVFDC, XARR, NDCS, A, N1, N2, IMF,
     3                 KL, KU, KLE )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        MHPI( * ), ICMP, MHTO( * ), MHLO( * ), MHMO( * ),
     2        NBN, NDRVS, NDRVM, NFDCM, ILNR, IRNR,
     3        N1, N2, IMF, KL, KU, KLE, NDCS
      DOUBLE PRECISION FAC, XARR( NR ), A( N1, N2 ),
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMF, NRR, NH, IHI, IHO, IHD, IPARS( 2 ), IS
      DOUBLE PRECISION LOW, JUNK( 1 ), WORK( 3 )
      EXTERNAL AMDLT
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      JUNK( 1 ) = 0.0d0
C
C Don't bother checking ILNR, IRNR, NDRVS or NBN
C as these errors will all be trapped by NGSVDR
C
C     .
C     . However do check ICMP
C     .
C
      IF ( ICMP.NE.1 .AND. ICMP.NE.2 .AND. ICMP.NE.3 .AND.
     1        ICMP.NE.4 .AND. ICMP.NE.5           )    THEN
         PRINT *,' Subroutine AMLP.'
         PRINT *,' ICMP = ', ICMP
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
         PRINT *,' Subroutine AMLP.'
         PRINT *,' IFORMF = ', IFORMF
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMLP.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRR  = ', NRR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( ABS(FAC).LT.LOW ) RETURN
      IHD = 2
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NH
        IF ( MHTI( IHI ).NE.ICMP ) GOTO 50
C
C ok - so our harmonic is of the correct type
C so let's look for its corresponding harmonic
C in VO
C
        IS = MHPI( IHI )
C
        DO IHO = 1, NH
          IF (   MHTO( IHO ).EQ.ICMP          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )   .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C set INARR2 variables ready to call NGMICA
C           .
            IPARS( 1 ) = 2
            IPARS( 2 ) = MHLI( IHI )
C           .
            CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMDLT, A, FAC, XARR,
     3                   WORK, JUNK, SVFDC )
C           .
          ENDIF 
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Matrix Laplcian and Curl ************************
C            -       -      -            -    ************************
C Steve Gibbons Fri Oct 15 14:48:25 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds FAC* all the elements of the matrix A which, when             C
C multiplied by the vector VI adds the curl of the Laplacian of all  C
C harmonics IHI in solution vector VI (satisfying MHTI(IHI) = ICMPI) C
C to the corresponding harmonics IHO in vector VO (which satsify     C
C MHTO( IHO ) = ICMPO.)                                              C
C                                                                    C
C Multiplying VI by A after running AMLC should be equivalent to     C
C calling ASVLC with VI.                                             C
C                                                                    C
C Now MHTI defines what each scalar function in a solution vector    C
C represents.                                                        C
C                                                                    C
C         MHTI( IH ) = 1 --> harmonic is poloidal velocity           C
C         MHTI( IH ) = 2 --> harmonic is toroidal velocity           C
C         MHTI( IH ) = 3 --> harmonic is temperature.                C
C         MHTI( IH ) = 4 --> harmonic is poloidal magnetic field     C
C         MHTI( IH ) = 5 --> harmonic is toroidal magnetic field     C
C                                                                    C
C and similarly MHTO for the resulting vector.                       C
C                                                                    C
C Taking the curl of a Laplacian of a toroidal harmonic with         C
C radial function x(r) results in a poloidal harmonic with scalar    C
C function D_l x(r).                                                 C
C                                                                    C
C Taking the curl of a Laplacian of a poloidal harmonic with         C
C radial function x(r) results in a toroidal harmonic with scalar    C
C function -D_l^2 x(r).                                              C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR      See INDFUN for details       C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHPI      : Array length ( * ) - atleast length NHI            C
C                  Pointer array to finite difference coefficients.  C
C                  MHPI( ih ) = is, which is the 4th index of        C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     Note that MHTO, MHLO and MHMO correspond to                    C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     ILNRP     : First radial node to act on.                       C
C                  when contributing to the poloidal vorticity eqn.s C
C     IRNRP     : Last radial node to act on.                        C
C                  when contributing to the poloidal vorticity eqn.s C
C     ILNRT     : First radial node to act on.                       C
C                  when contributing to the toroidal vorticity eqn.s C
C     IRNRT     : Last radial node to act on.                        C
C                  when contributing to the toroidal vorticity eqn.s C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C     IMF       : Matrix format flag. (See MATIND)                   C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMLC( NR, INARR, MHTI, MHLI, MHMI, MHPI, MHTO, MHLO,
     1                 MHMO, FAC, NBN, NDRVS, NDRVM, ILNRP, IRNRP,
     2                 ILNRT, IRNRT, XARR, NFDCM, A, N1, N2, IMF,
     3                 KL, KU, KLE, NDCS, SVFDC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        MHPI( * ), MHTO( * ), MHLO( * ), MHMO( * ),
     2        NBN, NDRVS, NDRVM, ILNRP, IRNRP, ILNRT, IRNRT,
     3        NFDCM, N1, N2, IMF, KL, KU, KLE, NDCS
      DOUBLE PRECISION FAC, XARR( NR ), A( N1, N2 ),
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMF, NRR, NH, IHI, IHO, ILNR, IRNR,
     1        IHD, ICMPO, IPARS( 2 ), IS
      DOUBLE PRECISION LOW, F2, JUNK( 1 ), WORK( 5 )
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL AMDLT
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Don't bother checking ILNR, IRNR, NDRVS or NBN
C as these errors will all be trapped by AMGLICA
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
         PRINT *,' Subroutine AMLC.'
         PRINT *,' IFORMF = ', IFORMF
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMLC.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRR  = ', NRR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( ABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NH
        IF ( MHTI( IHI ).NE.1 .AND. MHTI( IHI ).NE.2 ) GOTO 50
        IF ( MHTI( IHI ).EQ.1 ) ICMPO = 2
        IF ( MHTI( IHI ).EQ.2 ) ICMPO = 1
C
C so let's look for its corresponding harmonic
C in VO
C
        IS = MHPI( IHI )
C
        DO IHO = 1, NH
          IF (   MHTO( IHO ).EQ.ICMPO          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C Set INARR and F2 variables ready to call AMICA
C           .
            IF ( MHTI( IHI ).EQ.1 ) THEN
C             .
C             . We are curl-and-Laplacian-ing a poloidal harmonic
C             .
              IHD        = 4
              IPARS( 1 ) = 3
              IPARS( 2 ) = MHLI( IHI )
              F2         = (-1.0d0)*FAC
              ILNR       = ILNRT
              IRNR       = IRNRT
            ELSE
C             .
C             . We are curl-and-Laplacian-ing a toroidal harmonic
C             .
              IHD        = 2
              IPARS( 1 ) = 2
              IPARS( 2 ) = MHLI( IHI )
              F2         = FAC
              ILNR       = ILNRP
              IRNR       = IRNRP
C             .
            ENDIF
C           .
            CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMDLT, A, F2, XARR,
     3                   WORK, JUNK, SVFDC )
C           .
          ENDIF 
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Matrix Curl of Coriolis Force Add ***************
C            -       -      -       -        -     -   ***************
C Steve Gibbons Mon Nov 15 08:07:49 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds FAC* all the elements of the matrix A which, when             C
C multiplied by the vector VI adds the curl of the Coriolis Force    C
C to the appropriate elements of vector VO.                          C
C                                                                    C
C Multiplying VI by A after running AMCCFA should be equivalent to   C
C calling ASVCCF with VI.                                            C
C                                                                    C
C Now MTI defines what each scalar function in a solution vector     C
C represents.                                                        C
C                                                                    C
C         MTI( IH ) = 1 --> harmonic is poloidal velocity            C
C         MTI( IH ) = 2 --> harmonic is toroidal velocity            C
C         MTI( IH ) = 3 --> harmonic is temperature.                 C
C         MTI( IH ) = 4 --> harmonic is poloidal magnetic field      C
C         MTI( IH ) = 5 --> harmonic is toroidal magnetic field      C
C                                                                    C
C See the documentation to the subroutine AMCCFT for details of the  C
C different interactions. Alternatively, they are given in appendix  C
C B of my thesis ('Dynamo Models of the Earth's Magnetic Field')     C
C     (University of Leeds 1998)                                     C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to VI.          C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR      See INDFUN for details       C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MTI      : Array length ( * ) - atleast length NHI             C
C                  See above for key. (corresponds to input vec.)    C
C     MLI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. degree, l.                             C
C     MMI      : Array length ( * ) - atleast length NHI             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MPI      : Array length ( * ) - atleast length NHI             C
C                  Pointer array to finite difference coefficients.  C
C                  MPI( ih ) = is, which is the 4th index of         C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     Note that MTO, MLO and MMO correspond to                       C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     ILP       : First radial node to act on.                       C
C                  when contributing to the poloidal vorticity eqn.s C
C     IRP       : Last radial node to act on.                        C
C                  when contributing to the poloidal vorticity eqn.s C
C     ILT       : First radial node to act on.                       C
C                  when contributing to the toroidal vorticity eqn.s C
C     IRT       : Last radial node to act on.                        C
C                  when contributing to the toroidal vorticity eqn.s C
C                                                                    C
C     LH        : Maximum spherical harmonic degree, l.              C
C     NTHP      : The number of theta points.                        C
C     NPHP      : The number of phi points.                          C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C     IMF       : Matrix format flag. (See MATIND)                   C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C     MMAX      : Maximum sph. harmonic order, m.                    C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C     GAUX      : Cosines of the NTHP evaluated by the routine       C
C                  gauwts. Dimension ( NTHP ).                       C
C     GAUW      : Corresponding weights. As above.                   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dimension ( ( LH + 1 )*( LH + 2 )/2, NTHP )       C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C                                                                    C
C     FTF1      : Work array - dim. (2*NPHP)                         C
C     FTF2      : Work array - dim. (2*NPHP)                         C
C     FTF3      : Work array - dim. (2*NPHP)                         C
C     VF        : Work array - dim. ( NPHP, NTHP, 3)                 C
C     QST       : Work array - dim. ( LH*(LH+2), 3)                  C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMCCFA( NR, INARR, MTI, MLI, MMI, MPI, MTO, MLO, MMO,
     1          FAC, NBN, NDRVS, NDRVM, ILP, IRP, ILT, IRT, LH, NTHP,
     2          NPHP, XARR, NFDCM, A, N1, N2, IMF, KL, KU, KLE, NDCS,
     3          SVFDC, MMAX, GAUX, GAUW, PA, DPA, FTF1, FTF2, FTF3,
     4          VF, QST )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MTI( * ), MLI( * ), MMI( * ), MPI( * ),
     1        MTO( * ), MLO( * ), MMO( * ), NBN, NDRVS, NDRVM, ILP,
     2        IRP, ILT, IRT, LH, NTHP, NPHP, NFDCM, N1, N2, IMF, KL,
     3        KU, KLE, NDCS, MMAX
      DOUBLE PRECISION FAC, XARR( NR ), A( N1, N2 ),
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
      DOUBLE PRECISION
     1                 QST( LH*(LH+2), 3),
     2                 VF( NPHP, NTHP, 3), FTF1( 2*NPHP ),
     3                 FTF2( 2*NPHP ), FTF3( 2*NPHP )
      DOUBLE PRECISION
     1                 GAUX( NTHP ), GAUW( NTHP ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHP),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHP)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMF, NRR, NH, IHI, IHO, ILNR, IRNR,
     1        IHD, IPARS( 4 ), IS, LI, MI, ICSI, IQSTI,
     2        LO, MO, ICSO, IQSTO, IHARM, INDSHC
      DOUBLE PRECISION LOW, DPARS( 1 ), WORK( 3 ),
     1        QAB, SAB, TAB
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL AMCCFT
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Don't bother checking ILNR, IRNR, NDRVS or NBN
C as these errors will all be trapped by AMGLICA
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
         PRINT *,' Subroutine AMCCFA.'
         PRINT *,' IFORMF = ', IFORMF
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMCCFA.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRR  = ', NRR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( ABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NH
        IF ( MTI( IHI ).NE.1 .AND. MTI( IHI ).NE.2 ) GOTO 50
C
C Allocate whichever finite difference scheme
C belongs to the input harmonic
C
        IS = MPI( IHI )
C
C Consider separately the cases of input harmonic
C being poloidal and toroidal.
C
        IF ( MTI( IHI ).EQ.1 ) THEN
C         .
C         . Input harmonic is poloidal ...
C         .
          LI = MLI( IHI )
          IF ( MMI( IHI ).LT.0 ) THEN
            MI   = -MMI( IHI )
            ICSI = 2
          ELSE
            MI   = MMI( IHI )
            ICSI = 1
          ENDIF
C         .
C         . Call CORCOF with IQSTI = 1.
C         . This will give us K_{qs} and K_{qt} 
C         . (c.f. eq B.42 in thesis) - K_{qq} should be zero!
C         .
          IQSTI = 1
          CALL CORCOF( IQSTI, LI, MI, ICSI, QST, LH, NPHP, NTHP,
     1           FTF1, FTF2, FTF3, VF, GAUX, GAUW, PA, DPA, MMAX )
          IPARS( 1 ) = IQSTI
          IPARS( 2 ) = LI
C         .
C         . Now loop around the output harmonics
C         .
          DO IHO = 1, NH
C           .
            LO = MLO( IHO )
            IF ( MMO( IHO ).LT.0 ) THEN
              MO   = -MMO( IHO )
              ICSO = 2
            ELSE
              MO   = MMO( IHO )
              ICSO = 1
            ENDIF
            IHARM = INDSHC( LO, MO, ICSO )
            IF( IHARM.GT.0 ) SAB   = QST( IHARM, 2 )
            IF( IHARM.GT.0 ) TAB   = QST( IHARM, 3 )
C           .
C           . Case of poloidal harmonic
C           .
            IF ( MTO( IHO ).EQ.1 ) THEN
C              .
C              . Need to do K_{qt} interaction
C              .
               IHD        = 0
               ILNR       = ILP
               IRNR       = IRP
               IQSTO      = 3
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = TAB
C              .
               IF ( ABS( TAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
            ENDIF
C           .
C           . Case of toroidal harmonic
C           .
            IF ( MTO( IHO ).EQ.2 ) THEN
C              .
C              . Need to do K_{qs} interaction
C              .
               IHD        = 1
               ILNR       = ILT
               IRNR       = IRT
               IQSTO      = 2
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = SAB
C              .
               IF ( ABS( SAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
            ENDIF
C           .
          ENDDO
C         .
C         . Call CORCOF with IQSTI = 2.
C         . This will give us K_{sq}, K_{ss} and K_{st}
C         . (c.f. eq B.43 in thesis)
C         .
          IQSTI = 2
          CALL CORCOF( IQSTI, LI, MI, ICSI, QST, LH, NPHP, NTHP,
     1           FTF1, FTF2, FTF3, VF, GAUX, GAUW, PA, DPA, MMAX )
          IPARS( 1 ) = IQSTI
          IPARS( 2 ) = LI
C         .
C         . Now loop around the output harmonics
C         .
          DO IHO = 1, NH
C           .
            LO = MLO( IHO )
            IF ( MMO( IHO ).LT.0 ) THEN
              MO   = -MMO( IHO )
              ICSO = 2
            ELSE
              MO   = MMO( IHO )
              ICSO = 1
            ENDIF
            IHARM = INDSHC( LO, MO, ICSO )
            IF( IHARM.GT.0 ) QAB   = QST( IHARM, 1 )
            IF( IHARM.GT.0 ) SAB   = QST( IHARM, 2 )
            IF( IHARM.GT.0 ) TAB   = QST( IHARM, 3 )
C           .
C           . Case of poloidal harmonic
C           .
            IF ( MTO( IHO ).EQ.1 ) THEN
C              .
C              . Need to do K_{st} interaction
C              .
               IHD        = 1
               ILNR       = ILP
               IRNR       = IRP
               IQSTO      = 3
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = TAB
C              .
               IF ( ABS( TAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
            ENDIF
C           .
C           . Case of toroidal harmonic
C           .
            IF ( MTO( IHO ).EQ.2 ) THEN
C              .
C              . Need to do K_{sq} interaction
C              .
               IHD        = 1
               ILNR       = ILT
               IRNR       = IRT
               IQSTO      = 1
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = QAB
C              .
               IF ( ABS( QAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
C              . Need to do K_{ss} interaction
C              .
               IHD        = 2
               ILNR       = ILT
               IRNR       = IRT
               IQSTO      = 2
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = SAB
C              .
               IF ( ABS( SAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
            ENDIF
C           .
          ENDDO
C         .
        ENDIF
C       endif case of ihi poloidal
C    
        IF ( MTI( IHI ).EQ.2 ) THEN
C         .
C         . Input harmonic is toroidal ...
C         .
          LI = MLI( IHI )
          IF ( MMI( IHI ).LT.0 ) THEN
            MI   = -MMI( IHI )
            ICSI = 2
          ELSE
            MI   = MMI( IHI )
            ICSI = 1
          ENDIF
C         .
C         . Call CORCOF with IQSTI = 3.
C         . This will give us K_{tq}, K_{ts} and K_{tt}
C         . (c.f. eq B.44 in thesis)
C         .
          IQSTI = 3
          CALL CORCOF( IQSTI, LI, MI, ICSI, QST, LH, NPHP, NTHP,
     1           FTF1, FTF2, FTF3, VF, GAUX, GAUW, PA, DPA, MMAX )
          IPARS( 1 ) = IQSTI
          IPARS( 2 ) = LI
C         .
C         . Now loop around the output harmonics
C         .
          DO IHO = 1, NH
C           .
            LO = MLO( IHO )
            IF ( MMO( IHO ).LT.0 ) THEN
              MO   = -MMO( IHO )
              ICSO = 2
            ELSE
              MO   = MMO( IHO )
              ICSO = 1
            ENDIF
            IHARM = INDSHC( LO, MO, ICSO )
            IF( IHARM.GT.0 ) QAB   = QST( IHARM, 1 )
            IF( IHARM.GT.0 ) SAB   = QST( IHARM, 2 )
            IF( IHARM.GT.0 ) TAB   = QST( IHARM, 3 )
C           .
C           . Case of poloidal harmonic
C           .
            IF ( MTO( IHO ).EQ.1 ) THEN
C              .
C              . Need to do K_{tt} interaction
C              .
               IHD        = 0
               ILNR       = ILP
               IRNR       = IRP
               IQSTO      = 3
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = TAB
C              .
               IF ( ABS( TAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
            ENDIF
C           .
C           . Case of toroidal harmonic
C           .
            IF ( MTO( IHO ).EQ.2 ) THEN
C              .
C              . Need to do K_{tq} interaction
C              .
               IHD        = 0
               ILNR       = ILT
               IRNR       = IRT
               IQSTO      = 1
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = QAB
C              .
               IF ( ABS( QAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
C              . Need to do K_{ts} interaction
C              .
               IHD        = 1
               ILNR       = ILT
               IRNR       = IRT
               IQSTO      = 2
               IPARS( 3 ) = IQSTO
               IPARS( 4 ) = LO
               DPARS( 1 ) = SAB
C              .
               IF ( ABS( SAB ).GT.LOW ) THEN
C              .
               CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMCCFT, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C              .
               ENDIF
C              .
            ENDIF
C           .
          ENDDO
C         .
        ENDIF
C       endif case of ihi toroidal
C    
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Matrix Term Addition ****************************
C            -       -      -    -        ****************************
C Steve Gibbons Fri Oct 15 08:14:18 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Simply adds a factor of FAC to the elements of a matrix A which    C
C multiplies VI( i ) to give VO( i ). i.e. multiplying vector VI     C
C by A (after a call to AMTA) to form VO  should be equivalent       C
C to calling NGSVTA with VI and VO. Acts on each                     C
C harmonic, IH, such that MHTI( ih ) = ICMPI and grid node such that C
C ILNR .le. ir .le. IRNR - and j is every harmonic, JH, such that    C
C MHTO( jh ) = ICMPO and grid node, jr, such that                    C
C  ILNR .le. ir .le. IRNR                                            C
C                                                                    C
C Useful maybe if adding time derivatives to the forcing term or     C
C buoyancy to toroidal component of the vorticity.                   C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to VI and VO.   C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARR( 1 ) = IFORMF                                C
C                 INARR( 2 ) = NRR     See INDFUN for details        C
C                 INARR( 3 ) = NH                                    C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NH             C
C                  See below for key. (corresponds to input vec.)    C
C                                                                    C
C     MHTI( i ) = 1 for a poloidal velocity harmonic, i.             C
C     MHTI( i ) = 2 for a toroidal velocity harmonic, i.             C
C     MHTI( i ) = 3 for a temperature harmonic, i.                   C
C     MHTI( i ) = 4 for a poloidal magnetic field harmonic, i.       C
C     MHTI( i ) = 5 for a toroidal magnetic field harmonic, i.       C
C                                                                    C
C     MHLI      : Array length ( * ) - atleast length NH             C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NH             C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHPI      : Array length ( * ) - atleast length NHI            C
C                  Pointer array to finite difference coefficients.  C
C                  MHPI( ih ) = is, which is the 4th index of        C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     Note that INARRO, MHTO, MHLO and MHMO correspond to            C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     ICMPI     : The type of harmonic we wish to act upon.          C
C     ICMPO     : The type of harmonic we wish add term to.          C
C                                                                    C
C Note that ICMPI and ICMPO should generally be identical.           C
C An example of an exception would be when adding the buoyancy       C
C term to the vorticity - here, ICMPI would be 3 and ICMPO 2.        C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C     IMF       : Matrix format flag. (See MATIND)                   C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C                (Not needed if we are doing tor --> pol but         C
C                 must be atleast 2 if doing pol --> tor )           C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplication factor.                             C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMTA( NR, INARR, MHTI, MHLI, MHMI, MHPI, ICMPI,
     1                 MHTO, MHLO, MHMO, ICMPO, FAC, ILNR, IRNR, A,
     2                 N1, N2, IMF, KL, KU, KLE, NDRVS, NDRVM, NFDCM,
     3                 NDCS, SVFDC, XARR, NBN )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        MHPI( * ), ICMPI, MHTO( * ), MHLO( * ), MHMO( * ),
     2        ICMPO, ILNR, IRNR, N1, N2, IMF, KL, KU, KLE,
     3        NDRVS, NDRVM, NFDCM, NDCS, NBN
      DOUBLE PRECISION FAC, A( N1, N2 ), XARR( NR ),
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IHD, IHI, IHO, NRR, NH, IS, IPARS( 2 )
      DOUBLE PRECISION TOL, JUNK( 1 ), WORK( 1 )
      EXTERNAL AMDLT
      PARAMETER ( TOL = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      JUNK( 1 ) = 0.0d0
      IHD       = 0
C
C Check grid nodes ...
C
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C     .
C     . Easy exit
C     .
      IF ( ABS( FAC ).LT.TOL ) RETURN
C     .
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMTA.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRR  = ', NRR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
      DO IHI = 1, NH
        IF ( MHTI( IHI ).NE.ICMPI ) GOTO 50
C
C ok - so our harmonic is of the correct type
C so let's look for its corresponding harmonic
C in VO
C
        IS = MHPI( IHI )
C
        DO IHO = 1, NH
          IF (   MHTO( IHO ).EQ.ICMPO          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C
            IPARS( 1 ) = 1
C           .
            CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMDLT, A, FAC, XARR,
     3                   WORK, JUNK, SVFDC )
C
          ENDIF
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Adapted Matrix CurL *************************************
C            -       -      -  - *************************************
C Steve Gibbons Fri Oct 15 13:33:10 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds FAC to all the elements of the matrix A which, when           C
C multiplied by the vector VI adds the curl of all harmonics IHI     C
C in solution vector VI (satisfying MHTI( IHI ) = ICMPI) to the      C
C corresponding harmonics IHO in vector VO (which satsify            C
C MHTO( IHO ) = ICMPO.                                               C
C                                                                    C
C Multiplying VI by A after running AMCL should be equivalent to     C
C calling ASVCL with VI.                                             C
C                                                                    C
C Now MHTI defines what each scalar function in a solution vector    C
C represents.                                                        C
C                                                                    C
C         MHTI( IH ) = 1 --> harmonic is poloidal velocity           C
C         MHTI( IH ) = 2 --> harmonic is toroidal velocity           C
C         MHTI( IH ) = 3 --> harmonic is temperature.                C
C         MHTI( IH ) = 4 --> harmonic is poloidal magnetic field     C
C         MHTI( IH ) = 5 --> harmonic is toroidal magnetic field     C
C                                                                    C
C and similarly MHTO for the resulting vector.                       C
C                                                                    C
C The program aborts if ICMPI = 3 as curl has no meaning.            C
C                                                                    C
C Taking the curl of a toroidal harmonic with radial function        C
C x( r ) results in a poloidal harmonic with r.f. x(r)               C
C                                                                    C
C Hence ICMPI = 2(5) would normally correspond to ICMPO = 1(4)       C
C                                                                    C
C                                                                    C
C Taking the curl of a poloidal harmonic with radial function        C
C x( r ) results in a toroidal harmonic with r.f. -D_l x(r)          C
C                                                                    C
C Hence ICMPI = 1(4) would normally correspond to ICMPO = 2(5)       C
C                                                                    C
C Note that as this is a matrix operation (unlike in the RHS op.s),  C
C the harmonic sets must be equivalent and so only one array,        C
C INARR, must correspond to both VI and VO.                          C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to vectors.     C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NR      See INDFUN for details       C
C                 INARRI( 3 ) = NH                                   C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHPI      : Array length ( * ) - atleast length NHI            C
C                  Pointer array to finite difference coefficients.  C
C                  MHPI( ih ) = is, which is the 4th index of        C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C     ICMPI     : The type of harmonic we wish to take curl of.      C
C                                                 see above.         C
C                                                                    C
C     Note that MHTO, MHLO, MHMO and ICMPO correspond to             C
C    exactly the above variables but for the output and not input    C
C    vectors. ICMPI cannot be 3. NRI must equal NRO and must both    C
C    equal NR.                                                       C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C                (Not needed if we are doing tor --> pol but         C
C                 must be atleast 2 if doing pol --> tor )           C
C                                                                    C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C     IMF       : Matrix format flag. (See MATIND)                   C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMCL( NR, INARR, MHTI, MHLI, MHMI, MHPI, ICMPI, MHTO,
     1                 MHLO, MHMO, ICMPO, FAC, NBN, NDRVS, NDRVM,
     2                 ILNR, IRNR, XARR, NFDCM, SVFDC, A, N1, N2,
     3                 IMF, KL, KU, KLE, NDCS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        MHPI( * ), ICMPI, MHTO( * ), MHLO( * ), MHMO( * ),
     2        ICMPO, NBN, NDRVS, NDRVM, ILNR, IRNR, NFDCM, N1, N2,
     3        IMF, KL, KU, KLE, NDCS
      DOUBLE PRECISION FAC, XARR( NR ), A( N1, N2 ),
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMF, NRR, NH, IHI, IHO, IS,
     1        IHD, IPARS( 2 )
      DOUBLE PRECISION LOW, F2, JUNK( 1 ), WORK( 3 )
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL AMDLT
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Don't bother checking ILNR, IRNR, NDRVS or NBN
C as these errors will all be trapped by AMLICA
C
C     .
C     . However do check ICMPI
C     .
C
      IF ( ICMPI.NE.1 .AND. ICMPI.NE.2 .AND. ICMPI.NE.4
     1                .AND. ICMPI.NE.5           )    THEN
         PRINT *,' Subroutine AMCL.'
         PRINT *,' ICMPI = ', ICMPI
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
         PRINT *,' Subroutine AMCL.'
         PRINT *,' IFORMF = ', IFORMF
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMCL.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRR  = ', NRR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( DABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NH
        IF ( MHTI( IHI ).NE.ICMPI ) GOTO 50
C
C ok - so our harmonic is of the correct type
C so let's look for its corresponding harmonic
C in VO
C
        IS = MHPI( IHI )
C
        DO IHO = 1, NH
          IF (   MHTO( IHO ).EQ.ICMPO          .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C Set INARR and F2 variables ready to call AMLICA
C           .
            IF ( MHTI( IHI ).EQ.1 .OR. MHTI( IHI ).EQ.4 ) THEN
C             .
C             . We are curling a poloidal harmonic
C             .
              IHD        = 2
              IPARS( 1 ) = 2
              IPARS( 2 ) = MHLI( IHI )
              F2         = (-1.0d0)*FAC
            ELSE
C             .
C             . We are curling a toroidal harmonic
C             .
              IHD        = 0
              IPARS( 1 ) = 1
              F2         = FAC
C             .
            ENDIF
C           .
            CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMDLT, A, F2, XARR,
     3                   WORK, JUNK, SVFDC )
C           .
          ENDIF 
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Matrix Heat Source Terms ************************
C            -       -      -    -      -     ************************
C Steve Gibbons Fri Oct 15 13:33:10 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Adds FAC to all the elements of the matrix A which, when           C
C multiplied by the vector VI adds the heat source terms in          C
C solution vector VI to the corresponding harmonics IHO in vector VO C
C                                                                    C
C Multiplying VI by A after running AMHST should be equivalent to    C
C calling ASVCL with VI.                                             C
C                                                                    C
C Now MHTI defines what each scalar function in a solution vector    C
C represents.                                                        C
C                                                                    C
C         MHTI( IH ) = 1 --> harmonic is poloidal velocity           C
C         MHTI( IH ) = 2 --> harmonic is toroidal velocity           C
C         MHTI( IH ) = 3 --> harmonic is temperature.                C
C         MHTI( IH ) = 4 --> harmonic is poloidal magnetic field     C
C         MHTI( IH ) = 5 --> harmonic is toroidal magnetic field     C
C                                                                    C
C and similarly MHTO for the resulting vector.                       C
C                                                                    C
C See AMHSAR for the details of the addition.                        C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     INARR     : Int. parameter array corresponding to vectors.     C
C                 Dim ( * ) but the following must be true.          C
C                                                                    C
C                 INARRI( 1 ) = IFORMF                               C
C                 INARRI( 2 ) = NR      See INDFUN for details       C
C                 INARRI( 3 ) = NH                                   C
C                                                                    C
C     MHTI      : Array length ( * ) - atleast length NHI            C
C                  See above for key. (corresponds to input vec.)    C
C     MHLI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. degree, l.                             C
C     MHMI      : Array length ( * ) - atleast length NHI            C
C                  Sph. harm. order, m, for cos m phi dep.           C
C                 -Sph. harm. order, m, for sin m phi dep.           C
C                                                                    C
C     MHPI      : Array length ( * ) - atleast length NHI            C
C                  Pointer array to finite difference coefficients.  C
C                  MHPI( ih ) = is, which is the 4th index of        C
C                  array SVFDC - indicates f.d. scheme used.         C
C                                                                    C
C                                                                    C
C     Note that MHTO, MHLO and MHMO correspond to                    C
C    exactly the above variables but for the output and not input    C
C    vectors. NRI must equal NRO and must both equal NR.             C
C                                                                    C
C     NBN       : Number of nodes on each side of point for          C
C                  central differences.                              C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C                (Not needed if we are doing tor --> pol but         C
C                 must be atleast 2 if doing pol --> tor )           C
C                                                                    C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     ILNR      : First radial node to act on.                       C
C     IRNR      : Last radial node to act on.                        C
C                                                                    C
C     N1        : First dimension of matrix, A.                      C
C     N2        : Second dimension of matrix, A.                     C
C     IMF       : Matrix format flag. (See MATIND)                   C
C     KL        : Number of lower diagonals in matrix                C
C     KU        : Number of upper diagonals in matrix                C
C     KLE       : Number of additional lower diagonals in matrix     C
C                                                                    C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     A         : Matrix. Dim ( N1, N2 )                             C
C     FAC       : Multiplier of curl to be added.                    C
C     XARR      : Dim ( NR ). i^{th} element gives x_i.              C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMHST( NR, INARR, MHTI, MHLI, MHMI, MHPI, MHTO,
     1                 MHLO, MHMO, FAC, NBN, NDRVS, NDRVM, ILNR, IRNR,
     2                 XARR, NFDCM, SVFDC, A, N1, N2, CB1, CB2, 
     3                 IMF, KL, KU, KLE, NDCS )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NR, INARR( * ), MHTI( * ), MHLI( * ), MHMI( * ),
     1        MHPI( * ), MHTO( * ), MHLO( * ), MHMO( * ),
     2        NBN, NDRVS, NDRVM, ILNR, IRNR, NFDCM, N1, N2,
     3        IMF, KL, KU, KLE, NDCS
      DOUBLE PRECISION FAC, XARR( NR ), A( N1, N2 ),
     1                 SVFDC( NFDCM, NR, NDRVM+1, NDCS ), CB1, CB2
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IFORMF, NRR, NH, IHI, IHO, IS,
     1        IHD, IPARS( 1 )
      DOUBLE PRECISION LOW, DPARS( 2 ), WORK( 3 )
      PARAMETER ( LOW = 1.0d-9 )
      EXTERNAL AMHSAR
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Don't bother checking ILNR, IRNR, NDRVS or NBN
C as these errors will all be trapped by AMLICA
C
      DPARS( 1 ) = CB1
      DPARS( 2 ) = CB2
C     .
C     . However do check ICMPI
C     .
C
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.2 ) THEN
         PRINT *,' Subroutine AMHST.'
         PRINT *,' IFORMF = ', IFORMF
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMHST.'
         PRINT *,' NR   = ', NR
         PRINT *,' NRR  = ', NRR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C     . early exit?
C
      IF ( ABS(FAC).LT.LOW ) RETURN
C     .
C     . Loop around in harmonics
C     .
      DO IHI = 1, NH
        IF ( MHTI( IHI ).NE.1 ) GOTO 50
C
C ok - so our harmonic is a poloidal velocity term
C so let's look for its corresponding temperature
C harmonic in VO
C
        IS = MHPI( IHI )
C
        DO IHO = 1, NH
          IF (   MHTO( IHO ).EQ.3              .AND.
     1           MHLO( IHO ).EQ.MHLI( IHI )    .AND.
     2           MHMO( IHO ).EQ.MHMI( IHI )         ) THEN
C
C o.k. we've found the corresponding harmonic
C Set IPARS and IHD variables ready to call AMLICA
C           .
            IHD        = 0
            IPARS( 1 ) = MHLI( IHI )
C           .
            CALL AMLICA( N1, N2, KL, KU, KLE, IMF, IHI, IHO, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, AMHSAR, A, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
C           .
          ENDIF 
        ENDDO
C
 50   CONTINUE
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Identical Node Velocity cross Curl of Velocity Terms ****
C            -         -    -              -       -        -     ****
C Steve Gibbons Mon Nov 22 11:17:27 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Provides, via INNLCA, the matrix terms for the                     C
C -  curl ( v x ( curl v )                                           C
C terms in the momentum equation.                                    C
C                                                                    C
C All variables other than those listed are dealt with by            C
C INNLCA.                                                            C
C                                                                    C
C In each of the following,                                          C
C                                                                    C
C - curl ( V_{A} x ( curl V_{B} ) = sum_G v_{G}                      C
C                                                                    C
C  q_A x q_B = 0                                                     C
C  q_A x s_B = sum_G ( C_{qss}^{abg} s_G + C_{qst}^{abg} t_G )       C
C  q_A x t_B = sum_G ( C_{qts}^{abg} s_G + C_{qtt}^{abg} t_G )       C
C  s_A x s_B = sum_G ( C_{ssq}^{abg} q_G )                           C
C  s_A x t_B = sum_G ( C_{stq}^{abg} q_G )                           C
C  t_A x t_B = sum_G ( C_{ttq}^{abg} q_G )                           C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     IPARS      : Array containing details of source harmonics.     C
C                                                                    C
C                  IPARS( 1 ) = IQSTA                                C
C                  IPARS( 2 ) = IQSTB                                C
C                  IPARS( 2 ) = IQSTG                                C
C                                                                    C
C This selects the interaction C_{xyz}^{abg} (c.f. equations         C
C (B.45), to (B.50) - and (B.62) to (B.72) in my thesis.             C
C                                                                    C
C                  IPARS( 4 ) = IOLDF                                C
C                                                                    C
C IOLDF = 1 means we are adding the derivative of a velocity A       C
C         function to the matrix terms for a curl of vel. B term.    C
C                                                                    C
C IOLDF = 2 means we are adding the derivative of a curl of vel. B   C
C         function to the matrix terms for a velocity A term.        C
C                                                                    C
C                  IPARS( 5 ) = LA (Spherical harm. degree of A )    C
C                  IPARS( 6 ) = LB (Spherical harm. degree of B )    C
C                  IPARS( 7 ) = LG (Spherical harm. degree of G )    C
C                                                                    C
C     IHD        : Highest derivative required of 'new' harmonic     C
C     IHD0       : Highest derivative required of 'old' harmonic     C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     DPARS      : DPARS( 1 ) contains coefficient C_{xyz}^{abg}     C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE INVCVT( CVEC, RAD, IPARS, DPARS, IHD, IRAD, IH0,
     1                   IHD0, NR, NDCS0, IS0, NBN0, INARR0, NDRVS0,
     2                   NDRVM0, NFDCM0, SVFDC0, VEC0 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IPARS( * ), IHD, IRAD, IH0, IHD0, NR, NDCS0, IS0, NBN0,
     1        INARR0( * ), NDRVS0, NDRVM0, NFDCM0
      DOUBLE PRECISION CVEC( * ), RAD, DPARS( * ), VEC0( * ),
     1                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IQSTA, IQSTB, IQSTG, IOLDF, LA, LB, LG, I
      DOUBLE PRECISION FAC, DERV( 4 ), RAD2, RAD3, RAD4, FUNL,
     1                 LOW, FLA, FLB, FLG, SQRLL1, TEMP, TEMP2, DL
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IQSTA  = IPARS( 1 )
      IQSTB  = IPARS( 2 )
      IQSTG  = IPARS( 3 )
      IOLDF  = IPARS( 4 )
      LA     = IPARS( 5 )
      LB     = IPARS( 6 )
      LG     = IPARS( 7 )
C
      FLA    = SQRLL1( LA )
      FLB    = SQRLL1( LB )
      FLG    = SQRLL1( LG )
C
      FAC    = DPARS( 1 )
C
      DO I = 1, IHD+1
        CVEC( I ) = 0.0d0
      ENDDO
C
C Check for zero value of RAD
C
      IF ( RAD.LT.LOW ) THEN
        PRINT *,' Subroutine INVCVT.'
        PRINT *,' RAD = ', RAD
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      RAD2 = RAD*RAD
      RAD3 = RAD*RAD*RAD
      RAD4 = RAD*RAD*RAD*RAD
C
C Take derivative of harmonic IH0 at IRAD
C
      CALL ASVDR( VEC0, IRAD, IS0, IH0, NBN0, IHD0, NFDCM0, NR,
     1            NDRVS0, NDRVM0, DERV, INARR0, SVFDC0, NDCS0 )
C
C DERV( 1 ) now contains zero^{th} derivative
C DERV( 2 ) now contains 1^{st} derivative (if requested)
C DERV( 3 ) now contains 2^{rd} derivative (if requested)
C DERV( 4 ) now contains 3^{rd} derivative (if requested)
C
C Do C_{qtt}^{abg} term for old pol. A and new pol. B
C G is poloidal. (Equation (B.63) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.2 .AND. IHD0.EQ.0 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        TEMP  = FUNL*DERV( 1 )
        CVEC( 1 ) = TEMP*(-1.0d0)*FLB*FLB/RAD3
        CVEC( 2 ) = TEMP*2.0d0/RAD2
        CVEC( 3 ) = TEMP/RAD
        RETURN
      ENDIF
C
C Do C_{qtt}^{abg} term for new pol. A and old pol. B
C G is poloidal. (Equation (B.63) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.0 .AND. IHD0.EQ.2 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        TEMP2 = DL( LB, RAD, DERV( 1 ), DERV( 2 ), DERV( 3 ) )
        TEMP  = FUNL*TEMP2
        CVEC( 1 ) = TEMP/RAD
        RETURN
      ENDIF
C
C Do C_{qts}^{abg} term for old pol. A and new pol. B
C G is toroidal.  (Equation (B.64) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.3 .AND. IHD0.EQ.1 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        TEMP  = 2.0d0*DERV( 1 )/RAD4 - DERV( 2 )/RAD3
        CVEC( 1 ) = FUNL*TEMP*FLB*FLB
        TEMP  = 2.0d0*DERV( 2 )/RAD2 - 2.0d0*DERV( 1 )/RAD3 -
     1                  FLB*FLB*DERV( 1 )/RAD3
        CVEC( 2 ) = FUNL*TEMP
        TEMP  = 2.0d0*DERV( 1 )/RAD2 + DERV( 2 )/RAD
        CVEC( 3 ) = FUNL*TEMP
        CVEC( 4 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{qts}^{abg} term for new pol. A and old pol. B
C G is toroidal.  (Equation (B.64) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.1 .AND. IHD0.EQ.3 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        TEMP  = 2.0d0*FLB*FLB*DERV( 1 )/RAD4 -
     1          FLB*FLB*DERV( 2 )/RAD3 - 2.0d0*DERV( 1 )/RAD3 +
     2          2.0d0*DERV( 3 )/RAD2 + DERV( 4 )/RAD
        CVEC( 1 ) = FUNL*TEMP
        TEMP2 = DL( LB, RAD, DERV( 1 ), DERV( 2 ), DERV( 3 ) )
        CVEC( 2 ) = FUNL*TEMP2/RAD
        RETURN
      ENDIF
C
C Do C_{stq}^{abg} term for old pol. A and new pol. B
C G is toroidal.   (Equation (B.64) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.2 .AND. IHD0.EQ.1 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FAC
        TEMP  = (-1.0d0)*FLB*FLB*( DERV( 1 )/RAD + DERV( 2 ) )
        CVEC( 1 ) = FUNL*TEMP/RAD3
        TEMP  = 2.0d0*( DERV( 1 )/RAD3 + DERV( 2 )/RAD2 )
        CVEC( 2 ) = FUNL*TEMP
        TEMP  = DERV( 1 )/RAD2 + DERV( 2 )/RAD
        CVEC( 3 ) = FUNL*TEMP
        RETURN
      ENDIF
C
C Do C_{stq}^{abg} term for new pol. A and old pol. B
C G is toroidal.   (Equation (B.64) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.1 .AND. IHD0.EQ.2 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FAC
        TEMP  = DL( LB, RAD, DERV( 1 ), DERV( 2 ), DERV( 3 ) )
        CVEC( 1 ) = FUNL*TEMP/RAD2
        CVEC( 2 ) = FUNL*TEMP/RAD
        RETURN
      ENDIF
C
C Do C_{qst}^{abg} term for old pol. A and new tor. B
C G is poloidal. (Equation (B.66) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*DERV( 1 )/RAD2
        CVEC( 2 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{qst}^{abg} term for new pol. A and old tor. B
C G is poloidal. (Equation (B.66) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*( DERV( 1 )/RAD2 + DERV( 2 )/RAD )
        RETURN
      ENDIF
C
C Do C_{sqt}^{abg} term for old pol. A and new tor. B
C G is poloidal. (Equation (B.66) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        FUNL  = FLB*FLB*FLA*FAC/FLG
        CVEC( 1 ) = FUNL*( DERV( 1 )/RAD2 + DERV( 2 )/RAD )
        RETURN
      ENDIF
C
C Do C_{sqt}^{abg} term for new pol. A and old tor. B
C G is poloidal. (Equation (B.66) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        FUNL  = FLB*FLB*FLA*FAC/FLG
        CVEC( 1 ) = FUNL*DERV( 1 )/RAD2
        CVEC( 2 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{ssq}^{abg} term for old pol. A and new tor. B
C G is toroidal. (Equation (B.67) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.1 .AND. IHD0.EQ.1 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FAC
        CVEC( 1 ) = FUNL*( DERV( 1 )/RAD3 + DERV( 2 )/RAD2 )
        CVEC( 2 ) = FUNL*( DERV( 1 )/RAD2 + DERV( 2 )/RAD )
        RETURN
      ENDIF
C
C Do C_{ssq}^{abg} term for new pol. A and old tor. B
C G is toroidal. (Equation (B.67) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.1 .AND. IHD0.EQ.1 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FAC
        CVEC( 1 ) = FUNL*( DERV( 1 )/RAD3 + DERV( 2 )/RAD2 )
        CVEC( 2 ) = FUNL*( DERV( 1 )/RAD2 + DERV( 2 )/RAD )
        RETURN
      ENDIF
C
C Do C_{qss}^{abg} term for old pol. A and new tor. B
C G is toroidal. (Equation (B.67) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.2 .AND. IHD0.EQ.1 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*( DERV( 2 )/RAD2 - DERV( 1 )/RAD3 )
        CVEC( 2 ) = FUNL*( DERV( 2 )/RAD + DERV( 1 )/RAD2 )
        CVEC( 3 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{qss}^{abg} term for new pol. A and old tor. B
C G is toroidal. (Equation (B.67) in my thesis)
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.1 .AND. IHD0.EQ.2 ) THEN
        FUNL  = FLA*FLA*FLB*FAC/FLG
        TEMP  = DERV( 3 )/RAD + DERV( 2 )/RAD2 - DERV( 1 )/RAD3
        CVEC( 1 ) = FUNL*TEMP
        CVEC( 2 ) = FUNL*( DERV( 2 )/RAD + DERV( 1 )/RAD2 )
        RETURN
      ENDIF
C
C Do C_{sqs}^{abg} term for old pol. A and new tor. B
C G is toroidal. (Equation (B.67) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.1 .AND. IHD0.EQ.2 ) THEN
        FUNL  = FLB*FLB*FLA*FAC/FLG
        TEMP  = DERV( 3 )/RAD + DERV( 2 )/RAD2 - DERV( 1 )/RAD3
        CVEC( 1 ) = FUNL*TEMP
        CVEC( 2 ) = FUNL*( DERV( 2 )/RAD + DERV( 1 )/RAD2 )
        RETURN
      ENDIF
C
C Do C_{sqs}^{abg} term for new pol. A and old tor. B
C G is toroidal. (Equation (B.67) in my thesis)
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.2 .AND. IHD0.EQ.1 ) THEN
        FUNL  = FLB*FLB*FLA*FAC/FLG
        CVEC( 1 ) = FUNL*( DERV( 2 )/RAD2 - DERV( 1 )/RAD3 )
        CVEC( 2 ) = FUNL*( DERV( 2 )/RAD + DERV( 1 )/RAD2 )
        CVEC( 3 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{ttq}^{abg} term for old tor. A and new pol. B
C G is toroidal. (Equation (B.69) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.2 .AND. IHD0.EQ.0 ) THEN
        FUNL  = FLA*FLB*FAC
        CVEC( 1 ) = FUNL*(-1.0d0)*FLB*FLB*DERV( 1 )/RAD3
        CVEC( 2 ) = FUNL*(2.0d0)*DERV( 1 )/RAD2
        CVEC( 3 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{ttq}^{abg} term for new tor. A and old pol. B
C G is toroidal. (Equation (B.69) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.3 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.0 .AND. IHD0.EQ.2 ) THEN
        FUNL  = FLA*FLB*FAC
        TEMP  = DL( LB, RAD, DERV( 1 ), DERV( 2 ), DERV( 3 ) )
        CVEC( 1 ) = FUNL*TEMP/RAD
        RETURN
      ENDIF
C
C Do C_{tqt}^{abg} term for old tor. A and new tor. B
C G is poloidal. (Equation (B.71) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.0 .AND. IHD0.EQ.0 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{tqt}^{abg} term for new tor. A and old tor. B
C G is poloidal. (Equation (B.71) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.3 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.0 .AND. IHD0.EQ.0 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{tqs}^{abg} term for old tor. A and new tor. B
C G is toroidal.  (Equation (B.72) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.1 .AND. IHD0.EQ.1 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*DERV( 2 )/RAD
        CVEC( 2 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{tqs}^{abg} term for new tor. A and old tor. B
C G is toroidal.  (Equation (B.72) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.1 .AND. IQSTG.EQ.2 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.1 .AND. IHD0.EQ.1 ) THEN
        FUNL  = (-1.0d0)*FLA*FLB*FLB*FAC/FLG
        CVEC( 1 ) = FUNL*DERV( 2 )/RAD
        CVEC( 2 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{tsq}^{abg} term for old tor. A and new tor. B
C G is toroidal.  (Equation (B.72) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.1 .AND. IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        FUNL  = FLA*FLB*FAC
        CVEC( 1 ) = FUNL*DERV( 1 )/RAD2
        CVEC( 2 ) = FUNL*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do C_{tsq}^{abg} term for new tor. A and old tor. B
C G is toroidal.  (Equation (B.72) in my thesis)
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.2 .AND. IQSTG.EQ.1 .AND.
     1     IOLDF.EQ.2 .AND. IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        FUNL  = FLA*FLB*FAC
        CVEC( 1 ) = FUNL*( DERV( 1 )/RAD2 + DERV( 2 )/RAD )
        RETURN
      ENDIF
C
      PRINT *,' Subroutine INVCVT.'
      PRINT *,' Your parameter choice is illegal.'
      PRINT *,' IQSTA = ', IQSTA,' LA = ', LA
      PRINT *,' IQSTB = ', IQSTB,' LB = ', LB
      PRINT *,' IQSTG = ', IQSTG,' LG = ', LG
      PRINT *,' IOLDF = ', IOLDF,' IHD = ', IHD
      PRINT *,' IHD0  = ', IHD0
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Vector Interaction Coefficient EXtraction Routine *******
C            -      -           -           --         -       *******
C Steve Gibbons Mon Jan 17 10:19:39 GMT 2000                         C
C____________________________________________________________________C
C                                                                    C
C For a given 4 character code string REQVIT, index numbers          C
C IRAHN, IRBHN and IRGHN; VICEXR will search through the arrays      C
C IHNALP, IHNBET, IHNGAM and TVHI to look for a non-zero interaction C
C                                                                    C
C If for a given 'in' (interaction number),                          C
C                                                                    C
C   TVHI( in ) .EQ. REQVIT,                                          C
C   IHNALP( in ) .EQ. IRAHN,                                         C
C   IHNBET( in ) .EQ. IRBHN,                                         C
C   IHNGAM( in ) .EQ. IRGHN  then                                    C
C                                                                    C
C COEF is returned with CVI( in ) and ONZIC is returned .TRUE.       C
C                                                                    C
C Otherwise, it is assumed that there is no such non-zero interact.  C
C and ONZIC is returned .FALSE.                                      C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     NVI      : Number of vector interactions.                      C
C     IHNALP   : Number of alpha harmonics. Dim ( * )                C
C     IHNBET   : Number of beta harmonics. Dim ( * )                 C
C     IHNGAM   : Number of gamma harmonics. Dim ( * )                C
C                                                                    C
C     IRAHN    : Number of requested alpha harmonic                  C
C     IRBHN    : Number of requested beta harmonic                   C
C     IRGHN    : Number of requested gamma harmonic                  C
C                                                                    C
C  Character                                                         C
C  ---------                                                         C
C                                                                    C
C     TVHI      : *(4) Type of vector interaction. Dim. ( * )        C
C     REQVIT    : Requested type of vector interaction.              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     CVI       : Coefficients of vector interaction. Dim ( * )      C 
C     COEF      : Returned coeffcient.                               C
C                                                                    C
C  Logical                                                           C
C  -------                                                           C
C                                                                    C
C     ONZIC     : Returned .TRUE. if COEF contains the coefficient   C
C                 Returned .FALSE. if interaction was not found.     C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE VICEXR( NVI, IHNALP, IHNBET, IHNGAM, IRAHN, IRBHN, 
     1                   IRGHN, TVHI, REQVIT, CVI, COEF, ONZIC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NVI, IHNALP( * ), IHNBET( * ), IHNGAM( * ), IRAHN,
     1        IRBHN, IRGHN
      CHARACTER *(4) TVHI( * ), REQVIT
      DOUBLE PRECISION CVI( * ), COEF
      LOGICAL ONZIC
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IN
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      ONZIC = .FALSE.
      IN    = 0
      COEF  = 0.0d0
C
 50   CONTINUE
      IN = IN + 1
      IF (    IN.GT.NVI    ) RETURN
      IF (    IRAHN.NE.IHNALP( IN )    ) GOTO 50
      IF (    IRBHN.NE.IHNBET( IN )    ) GOTO 50
      IF (    IRGHN.NE.IHNGAM( IN )    ) GOTO 50
      IF (    REQVIT.NE.TVHI( IN )     ) GOTO 50
C
C OK it seems we have our desired interaction
C
      COEF  = CVI( IN )
      ONZIC = .TRUE.
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Identical Node Non-Linear Contribution Add **************
C            -         -    -   -      -            -   **************
C Steve Gibbons Sun Nov 21 14:54:41 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C  Adds to the double precision matrix, A, the terms which a single  C
C harmonic IHC contributes to a single harmonic IHR as a result of   C
C interaction with a harmonic IH0.                                   C
C                                                                    C
C  The radial functions to harmonics IHC and IHR, which are          C
C represented in the solution vector are represented at NR grid      C
C nodes whose spacing is dictated by the array XARR.                 C
C                                                                    C
C  The harmonic IH0 need not necessarily appear in this solution     C
C vector and it is stored in the vector VEC0 which is indexed by     C
C the array INARR0 (NR0 = NR) and the spacings are also given by     C
C XARR.                                                              C
C                                                                    C
C Let the radial function of the IHR harmonic be denoted f_{IHR)(r)  C
C Let the radial function of the IHC harmonic be denoted f_{IHC)(r)  C
C                                                                    C
C If the contribution for a given radial node, $r_j$, is of the form C
C                                                                    C
C f_{IHR)(r_j) = \sum_{nd=0,IHD} f_{IHC}^{nd}(r_j) c_{IHC}^{nd}(r_j) C
C                                                                    C
C  (where f^{nd} denotes the (nd)^{th} derivative of f with respect  C
C  to r, evaluated at r_j)                                           C
C                                                                    C
C then the coefficient c_{IHC}^{nd}(r_j) must be supplied by the     C
C subroutine SUB1 (declared EXTERNAL in the calling (sub)program )   C
C which returns c_{IHC}^{nd}(r_j) in the array element CVEC(nd + 1). C
C                                                                    C
C Unlike in AMLICA, where c_{IHC}^{nd} depends only upon r and       C
C some constants (which are passed in through the arrays IPARS and   C
C DPARS), c_{IHC}^{nd} will be a function of VEC0.                   C
C                                                                    C
C IHD0 is the highest derivative which is required of VEC0.          C
C NDCS0 is the number of finite difference schemes available.        C
C IS0 is the number of the finite difference scheme which must be    C
C     used to obtain the derivative from VEC0.                       C
C                                                                    C
C NDRVS0, NDRVM0 and NBN0 are analogous to NDRVS, NDRVM and NBN but  C
C correspond to SVFDC0 which may be entirely different for SVFDC -   C
C the finite difference coefficients used to build the matrix.       C
C                                                                    C
C This can allow for a far greater accuracy in taking the deriv.s    C
C of the functions of VEC0 than may be possible in the matrix where  C
C the equations are to be solved.                                    C
C                                                                    C
C The resolution may ofcourse be identical.                          C
C                                                                    C
C The subroutine SUB1 *MUST* have the calling sequence               C
C                                                                    C
C SUB1( CVEC, RAD, IPARS, DPARS, IHD, IRAD, IH0, IHD0, NR, NDCS0,    C
C       IS0, NBN0, INARR0, NDRVS0, NDRVM0, NFDCM0, SVFDC0, VEC0 )    C
C                                                                    C
C where  RAD is the double precision value of the radius,            C
C        IPARS is an integer array to provide SUB1 with parameters.  C
C          IPARS is not referred to by INNLCA other than to pass     C
C          this information.                                         C
C        DPARS is like IPARS but contains double precision elements. C
C        IHD is the highest derivative which will be refered to by   C
C        INNLCA. So all CVEC( i ) must be zero with 1.le.i.le.ihd+1  C
C        if it is not assigned another value.                        C
C        IRAD is the number of the grid node where the derivative    C
C        must be taken.                                              C
C                                                                    C
C        Other variables are described above.                        C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ).               C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     IHC       : Number of the input (column) harmonic              C
C     IHR       : Number of the output (row) harmonic                C
C                                                                    C
C     INARR     : Array of integers. Dimension ( * )                 C
C                 At present the elements of INARR are as follows.   C
C                                                                    C
C                 INARR( 1 ) = IFORMF. Format flag.                  C
C                  This flag decides how the elements are arranged   C
C                  in the solution vector.                           C
C                                                                    C
C                  The current options are:-                         C
C                                                                    C
C                   IFORMF = 1. INDFUN = ( IR - 1 )*NH + IH          C
C                   IFORMF = 2. INDFUN = ( IH - 1 )*NR + IR          C
C                                                                    C
C  where IR and IH are the current grid node and harmonic resp.      C
C  and NR and NH are the total numbers of nodes and harmonics        C
C  in the solution vector.                                           C
C                                                                    C
C                 INARR( 2 ) = NR. Number of radial grid nodes.      C
C                 INARR( 3 ) = NH. Number of harmonics in sol. vect. C
C                                                                    C
C     IHD       : Highest derivative involved.                       C
C     NBN       : Number of diagonal elements in radius.             C
C     ILNR      : Left-most node at which to start adding rows to    C
C                   matrix.                                          C
C     IRNR      : Right-most node at which to start adding rows to   C
C                   matrix.                                          C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     IS        : Number of required finite difference scheme.       C
C                  (This points to the fourth dim. element in        C
C                   the coefficient array SVFDC.)                    C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C                 (Must be atleast 1).                               C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     IPARS     : Information array for SUB1. Dimension ( * )        C
C                                                                    C
C     IH0       : Harmonic with which IHC interacts to produce IHR.  C
C     IHD0      : Highest deriv. required from VEC0.                 C
C     NDCS0     : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC0.                       C
C     IS0       : Number of required finite difference scheme.       C
C                  (This points to the fourth dim. element in        C
C                   the coefficient array SVFDC0.)                   C
C     NBN0      : Number of diagonal elements in radius for VEC0.    C
C                                                                    C
C     INARR0    : See INDFUN. Format of VEC0.                        C
C     NDRVS0    : Highest derivative stored in SVFDC0.               C
C                 (Must be atleast 1).                               C
C     NDRVM0    : Limit on NDRVS0. Array bound for SVFDC0.           C
C                                                                    C
C     NFDCM0    : Leading dim of SVFDC0. See SVFDCF.                 C
C                  (Must be atleast 2*NBN0 + 1 )                     C
C                                                                    C
C  Subroutines                                                       C
C  -----------                                                       C
C     SUB1      : Determines what multiplies each derivative in      C
C                  the matrix. Must have calling sequence ...        C
C                                                                    C
C     CALL SUB1 ( CVEC, RAD, IPARS, DPARS, IHD, IRAD, IH0, IHD0,     C
C                 NR, NDCS0, IS0, NBN0, INARR0, NDRVS0, NDRVM0,      C
C                 NFDCM0, SVFDC0, VEC0 )                             C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     AMAT      : Matrix. Dimensions ( N1, N2 )                      C
C              Will generally be banded due to the nature of the     C
C              numerical scheme. KL, KU and KLE parameterise this.   C
C                                                                    C
C     FAC       : Multiplication factor.                             C
C                                                                    C
C     XARR      : Array of dimension ( NR )                          C
C                 XARR( j ) = element x_j                            C
C                                                                    C
C     WORK      : Working array of dimension ( NDRVS + 1 )           C
C                                                                    C
C     DPARS     : Information array for SUB1. Dimension ( * )        C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C     VEC0      : Vector containing 'old function'                   C
C                                                                    C
C     SVFDC0    : Finite difference coefficient matrix for VEC0.     C
C                  Dimension ( NFDCM0, NR, NDRVM0+1, NDCS0 ).        C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE INNLCA( N1, N2, KL, KU, KLE, IMF, IHC, IHR, INARR,
     1      IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2      IPARS, SUB1, AMAT, FAC, XARR, WORK, DPARS, SVFDC, IH0,
     3      IHD0, NDCS0, IS0, NBN0, INARR0, NDRVS0, NDRVM0, VEC0,
     4      NFDCM0, SVFDC0 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER N1, N2, KL, KU, KLE, IMF, IHC, IHR, INARR( * ), IHD,
     1        NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2        IPARS( * ), IH0, IHD0, NDCS0, IS0, NBN0, INARR0( * ),
     3        NDRVS0, NDRVM0, NFDCM0
      EXTERNAL SUB1
      DOUBLE PRECISION AMAT( N1, N2 ), FAC, XARR( NR ),
     1                 WORK( NDRVS + 1 ), DPARS( * ),
     2                 SVFDC( NFDCM, NR, NDRVM+1, NDCS ), VEC0( * ),
     3                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IRAD, INODE, NLN, NRN, INDFUN, INDR, INDC,
     1        IROW, ICOL, NH, IFORMF, NLCS, NRCS, I,
     2        NDER, ICOROW, ICOCOL, NRR
      DOUBLE PRECISION RAD, LOW
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First we check for an easy exit - 
C if FAC = 0.0d0 there is no point in doing this  ...
C
C     .
      IF ( ABS( FAC ).LT.LOW ) RETURN
C     .
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C     .
C     . Check validity of NRR. Because it is an array
C     . dimension, NR has to be passed in the parameter
C     . list and so we must ensure we are consistent
C     .
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine INNLCA.'
         PRINT *,' INARR( 2 ) = ', NRR
         PRINT *,' NR = ', NR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Check that we really are dealing with
C     . a non-uniform grid.
C     .
      IF ( IFORMF.NE.3 .AND. IFORMF.NE.4 ) THEN
        PRINT *,' Subroutine INNLCA. IFORMF = ',IFORMF
        PRINT *,' This is not the uniform grid code.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Check size of IHD
C     .
      IF ( IHD.GT.NDRVS ) THEN
        PRINT *,' Subroutine INNLCA. '
        PRINT *,' IHD   = ', IHD
        PRINT *,' NDRVS = ', NDRVS
        STOP
      ENDIF
C     .
C     . Check N2 for case of IFORMF = 3 and 4
C     .
      IF ( IFORMF.EQ.3 .OR. IFORMF.EQ.4 ) THEN
        IF ( N2.NE.NH*NR ) THEN
          PRINT *,' Subroutine INNLCA. N2 = ', N2
          PRINT *,' NH = ', NH,' NR = ', NR
          PRINT *,' Program aborted.'
          STOP
        ENDIF
      ENDIF
C     .
C     . Check N1 for IMF.EQ.1 and IMF.EQ.3
C     .
      IF ( ( IMF.EQ.1 .AND. N1.NE.(KLE+KL+KU+1) ) .OR.
     1     ( IMF.EQ.3 .AND. N1.NE.N2           )      ) THEN
         PRINT *,' Subroutine INNLCA. IMF = ',IMF
         PRINT *,' N1 = ', N1,' N2 = ',N2
         PRINT *,' KL = ', KL,' KU = ',KU
         PRINT *,' KLE = ', KLE
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Now we will check that we have sufficient
C     . band width to be able to calculate the
C     . IHD^{th} derivative of a function.
C     . IHD must be less than or equal to the
C     . minimum value of (NLN + NRN)
C     . 
C     . To do this, we calculate NLCS and NRCS
C     . which are respectively the minimum number
C     . of points you will ever find on the left
C     . and the right of your node, IRAD.
C     .
      NLCS = ILNR - 1
      NRCS = NR   - IRNR
C
C Just check that we have sufficiently many grid nodes
C to be able to enforce all equations.
C
      IF ( NLCS.LT.0 ) THEN
        PRINT *,' Subroutine INNLCA.'
        PRINT *,' ILNR = ', ILNR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( NRCS.LT.0 ) THEN
        PRINT *,' Subroutine INNLCA.'
        PRINT *,' IRNR = ', IRNR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      I = MIN( NLCS, NRCS) + NBN
      IF ( IHD.GT.I ) THEN
        PRINT *,' Subroutine INNLCA.'
        PRINT *,' You want a derivative of order ', IHD
        PRINT *,' However, there is a node at which you '
        PRINT *,' only have ',I,' points for a derivative.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Ok - we now loop around the radial nodes for the
C     . rows ... 
C     .
      DO IRAD = ILNR, IRNR
C       .
C       . Calculate the corresponding index and radius
C       .
        INDR = INDFUN( IRAD, IHR, INARR )
        RAD = XARR( IRAD )
C       .
C       . Calculate NLN and NRN
C       .
        NLN = MIN( NBN, IRAD - 1 )
        NRN = MIN( NBN, NR - IRAD )
C       .
        CALL SUB1( WORK, RAD, IPARS, DPARS, IHD, IRAD, IH0, IHD0,
     1             NR, NDCS0, IS0, NBN0, INARR0, NDRVS0, NDRVM0,
     2             NFDCM0, SVFDC0, VEC0 )
C       .
C       . So now loop around the nodes from (IRAD - NLN)
C       . to (IRAD + NRN)
C       .
        DO INODE = IRAD - NLN, IRAD + NRN
C          .
C          . This is the row of the finite
C          . difference coefficients matrix
C          . which will contain the correct values.
C          .
           ICOCOL = INODE - IRAD + NBN + 1
C          .
C          . find the corresponding matrix column
C          .
           INDC = INDFUN( INODE, IHC, INARR )
C          .
C          . Find the actual location in the AMAT array
C          .
           CALL MATIND (INDR,INDC,IMF,KL,KU,KLE,N1,N2,IROW,ICOL)
C          .
           DO NDER = 0, IHD
             ICOROW = NDER + 1
             AMAT( IROW, ICOL ) = AMAT( IROW, ICOL ) + 
     1         FAC*WORK( ICOROW )*SVFDC( ICOCOL, IRAD, ICOROW, IS )
           ENDDO
C          .
        ENDDO
C       .
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Identical Node Velocity dot Gradient of Theta Terms *****
C            -         -    -            -           -     -     *****
C Steve Gibbons Mon Nov 22 08:00:19 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Provides, via INNLCA, the matrix terms for the v.Grad(theta)       C
C terms in the heat equation.                                        C
C                                                                    C
C All variables other than those listed are dealt with by            C
C INNLCA.                                                            C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     IPARS      : Array containing details of source harmonics.     C
C                                                                    C
C                  IPARS( 1 ) = IQSTA                                C
C                  IPARS( 2 ) = IQSTB                                C
C                                                                    C
C 'A' is the velocity harmonic and 'B' is the temperature harmonic.  C
C                                                                    C
C  IQSTA = 1 for x = 'q', = 2 for x = 's' and 3 for x = 't'.         C
C  IQSTB = 1 for y = 'q', and 2 for y = 's'. (IQSTB is never 3).     C
C                                                                    C
C This selects the interaction S_{xy}^{abg} (c.f. equations          C
C (B.39), (B.40) and (B.41) - and (B.52) to (B.53) in my thesis.     C
C                                                                    C
C                  IPARS( 3 ) = IOLDF                                C
C                                                                    C
C IOLDF = 1 means we are adding the derivative of a velocity         C
C         function to the matrix element for a temperature term.     C
C                                                                    C
C IOLDF = 2 means we are adding the derivative of a temperature      C
C         function to the matrix element for a velocity term.        C
C                                                                    C
C                  IPARS( 4 ) = LA (Spherical harm. degree of A )    C
C                  IPARS( 5 ) = LB (Spherical harm. degree of B )    C
C                                                                    C
C     IHD        : Highest derivative required of 'new' harmonic     C
C     IHD0       : Highest derivative required of 'old' harmonic     C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     DPARS      : DPARS( 1 ) contains coefficient S_{xy}^{abg}      C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE INVGTT( CVEC, RAD, IPARS, DPARS, IHD, IRAD, IH0,
     1                   IHD0, NR, NDCS0, IS0, NBN0, INARR0, NDRVS0,
     2                   NDRVM0, NFDCM0, SVFDC0, VEC0 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IPARS( * ), IHD, IRAD, IH0, IHD0, NR, NDCS0, IS0, NBN0,
     1        INARR0( * ), NDRVS0, NDRVM0, NFDCM0
      DOUBLE PRECISION CVEC( * ), RAD, DPARS( * ), VEC0( * ),
     1                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IQSTA, IQSTB, IOLDF, LA, LB, I
      DOUBLE PRECISION FAC, DERV( 2 ), RAD2, LOW, FLA, FLB,
     1                 SQRLL1
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IQSTA  = IPARS( 1 )
      IQSTB  = IPARS( 2 )
      IOLDF  = IPARS( 3 )
      LA     = IPARS( 4 )
      LB     = IPARS( 5 )
C
      FLA    = SQRLL1( LA )
      FLB    = SQRLL1( LB )
C
      FAC    = DPARS( 1 )
C
      DO I = 1, IHD+1
        CVEC( I ) = 0.0d0
      ENDDO
C
C Check for zero value of RAD
C
      IF ( RAD.LT.LOW ) THEN
        PRINT *,' Subroutine INVGTT.'
        PRINT *,' RAD = ', RAD
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      RAD2 = RAD*RAD
C
C Take derivative of harmonic IH0 at IRAD
C
      CALL ASVDR( VEC0, IRAD, IS0, IH0, NBN0, IHD0, NFDCM0, NR,
     1            NDRVS0, NDRVM0, DERV, INARR0, SVFDC0, NDCS0 )
C
C DERV( 1 ) now contains zero^{th} derivative
C DERV( 2 ) now contains 1^{st} derivative (if requested)
C
C Do S_{qq}^{abg} term for new theta_b and old p_a
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.1 .AND. IOLDF.EQ.1 .AND.
     1     IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        CVEC( 2 ) = FLA*FLA*FAC*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do S_{qq}^{abg} term for old theta_b and new p_a
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.1 .AND. IOLDF.EQ.2 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        CVEC( 1 ) = FLA*FLA*FAC*DERV( 2 )/RAD
        RETURN
      ENDIF
C
C Do S_{ss}^{abg} term for new theta_b and old p_a
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.1 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        CVEC( 1 ) = FLA*FLB*FAC*( DERV(2)/RAD + DERV(1)/RAD2 )
        RETURN
      ENDIF
C
C Do S_{ss}^{abg} term for old theta_b and new p_a
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.2 .AND.
     1     IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        CVEC( 1 ) = FLA*FLB*FAC*DERV(1)/RAD2
        CVEC( 2 ) = FLA*FLB*FAC*DERV(1)/RAD
        RETURN
      ENDIF
C
C Do S_{ts}^{abg} term for new theta_b and old p_a
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.1 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.0 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FLB*FAC*DERV(1)/RAD
        RETURN
      ENDIF
C
C Do S_{ts}^{abg} term for old theta_b and new p_a
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.2 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.0 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FLB*FAC*DERV(1)/RAD
        RETURN
      ENDIF
C
      PRINT *,' Subroutine INVGTT.'
      PRINT *,' Your parameter choice is illegal.'
      PRINT *,' IQSTA = ', IQSTA,' LA = ', LA
      PRINT *,' IQSTB = ', IQSTB,' LB = ', LB
      PRINT *,' IOLDF = ', IOLDF,' IHD = ', IHD
      PRINT *,' IHD0  = ', IHD0
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Identical Node Velocity dot Gradient of Inhomogeneous  **
C            -         -    -            -           -              **
C                                                 Temperature terms **
C                                                 -                 **
C Steve Gibbons Mon Nov 22 08:00:19 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Provides, via INNLCA, the matrix terms for the v.Grad( T )         C
C terms in the heat equation.                                        C
C                                                                    C
C T is the temperature given by theta + f( r ) where                 C
C                                                                    C
C f( r ) =            CA sin[ pi/2 (r-ri)/(ro-ri) ]                  C
C            + CB 2 ( ri-ro )/pi cos[ pi/2 (r-ri)/(ro-ri) ]  +  CC   C
C (see ITFA)                                                         C
C                                                                    C
C All variables other than those listed are dealt with by            C
C INNLCA.                                                            C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C                                                                    C
C     IPARS      : Array containing details of source harmonics.     C
C                                                                    C
C                  IPARS( 1 ) = IQSTA                                C
C                  IPARS( 2 ) = IQSTB                                C
C                                                                    C
C 'A' is the velocity harmonic and 'B' is the temperature harmonic.  C
C                                                                    C
C  IQSTA = 1 for x = 'q', = 2 for x = 's' and 3 for x = 't'.         C
C  IQSTB = 1 for y = 'q', and 2 for y = 's'. (IQSTB is never 3).     C
C                                                                    C
C This selects the interaction S_{xy}^{abg} (c.f. equations          C
C (B.39), (B.40) and (B.41) - and (B.52) to (B.53) in my thesis.     C
C                                                                    C
C                  IPARS( 3 ) = IOLDF                                C
C                                                                    C
C IOLDF = 1 means we are adding the derivative of a velocity         C
C         function to the matrix element for a temperature term.     C
C                                                                    C
C IOLDF = 2 means we are adding the derivative of a temperature      C
C         function to the matrix element for a velocity term.        C
C                                                                    C
C                  IPARS( 4 ) = LA (Spherical harm. degree of A )    C
C                  IPARS( 5 ) = LB (Spherical harm. degree of B )    C
C                                                                    C
C     IHD        : Highest derivative required of 'new' harmonic     C
C     IHD0       : Highest derivative required of 'old' harmonic     C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     DPARS      : DPARS( 1 ) contains coefficient S_{xy}^{abg}      C
C                  DPARS( 2 ) contains RI (inner boundary radius)    C
C                  DPARS( 3 ) contains RO (inner boundary radius)    C
C                  DPARS( 4 ) contains CA (see above)                C
C                  DPARS( 5 ) contains CB (see above)                C
C                  DPARS( 6 ) contains CC (see above)                C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE INVGIT( CVEC, RAD, IPARS, DPARS, IHD, IRAD, IH0,
     1                   IHD0, NR, NDCS0, IS0, NBN0, INARR0, NDRVS0,
     2                   NDRVM0, NFDCM0, SVFDC0, VEC0 )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IPARS( * ), IHD, IRAD, IH0, IHD0, NR, NDCS0, IS0, NBN0,
     1        INARR0( * ), NDRVS0, NDRVM0, NFDCM0
      DOUBLE PRECISION CVEC( * ), RAD, DPARS( * ), VEC0( * ),
     1                 SVFDC0( NFDCM0, NR, NDRVM0+1, NDCS0 )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IQSTA, IQSTB, IOLDF, LA, LB, I
      DOUBLE PRECISION FAC, DERV( 2 ), RAD2, LOW, FLA, FLB,
     1                 SQRLL1, RI, RO, CA, CB, CC
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IQSTA  = IPARS( 1 )
      IQSTB  = IPARS( 2 )
      IOLDF  = IPARS( 3 )
      LA     = IPARS( 4 )
      LB     = IPARS( 5 )
C
      FLA    = SQRLL1( LA )
      FLB    = SQRLL1( LB )
C
      FAC    = DPARS( 1 )
      RI     = DPARS( 2 )
      RO     = DPARS( 3 )
      CA     = DPARS( 4 )
      CB     = DPARS( 5 )
      CC     = DPARS( 6 )
C
      DO I = 1, IHD+1
        CVEC( I ) = 0.0d0
      ENDDO
C
C Check for zero value of RAD
C
      IF ( RAD.LT.LOW ) THEN
        PRINT *,' Subroutine INVGIT.'
        PRINT *,' RAD = ', RAD
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      RAD2 = RAD*RAD
C
C Take derivative of harmonic IH0 at IRAD
C
      CALL ASVDR( VEC0, IRAD, IS0, IH0, NBN0, IHD0, NFDCM0, NR,
     1            NDRVS0, NDRVM0, DERV, INARR0, SVFDC0, NDCS0 )
C
C DERV( 1 ) now contains zero^{th} derivative of theta
C DERV( 2 ) now contains 1^{st} derivative (if requested) of theta
C Now add on terms from f(r) if so required
C
      IF ( IOLDF.EQ.2 ) THEN
        CALL ITFA( RAD, RI, RO, CA, CB, CC, DERV, IHD0 )
      ENDIF
C
C Do S_{qq}^{abg} term for new theta_b and old p_a
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.1 .AND. IOLDF.EQ.1 .AND.
     1     IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        CVEC( 2 ) = FLA*FLA*FAC*DERV( 1 )/RAD
        RETURN
      ENDIF
C
C Do S_{qq}^{abg} term for old theta_b and new p_a
C
      IF ( IQSTA.EQ.1 .AND. IQSTB.EQ.1 .AND. IOLDF.EQ.2 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        CVEC( 1 ) = FLA*FLA*FAC*DERV( 2 )/RAD
        RETURN
      ENDIF
C
C Do S_{ss}^{abg} term for new theta_b and old p_a
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.1 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.1 ) THEN
        CVEC( 1 ) = FLA*FLB*FAC*( DERV(2)/RAD + DERV(1)/RAD2 )
        RETURN
      ENDIF
C
C Do S_{ss}^{abg} term for old theta_b and new p_a
C
      IF ( IQSTA.EQ.2 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.2 .AND.
     1     IHD.EQ.1 .AND. IHD0.EQ.0 ) THEN
        CVEC( 1 ) = FLA*FLB*FAC*DERV(1)/RAD2
        CVEC( 2 ) = FLA*FLB*FAC*DERV(1)/RAD
        RETURN
      ENDIF
C
C Do S_{ts}^{abg} term for new theta_b and old p_a
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.1 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.0 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FLB*FAC*DERV(1)/RAD
        RETURN
      ENDIF
C
C Do S_{ts}^{abg} term for old theta_b and new p_a
C
      IF ( IQSTA.EQ.3 .AND. IQSTB.EQ.2 .AND. IOLDF.EQ.2 .AND.
     1     IHD.EQ.0 .AND. IHD0.EQ.0 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FLB*FAC*DERV(1)/RAD
        RETURN
      ENDIF
C
      PRINT *,' Subroutine INVGIT.'
      PRINT *,' Your parameter choice is illegal.'
      PRINT *,' IQSTA = ', IQSTA,' LA = ', LA
      PRINT *,' IQSTB = ', IQSTB,' LB = ', LB
      PRINT *,' IOLDF = ', IOLDF,' IHD = ', IHD
      PRINT *,' IHD0  = ', IHD0
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Banded Matrix Row or Column OPeration *******************
C            -      -      -      -      --        *******************
C Steve Gibbons 3.12.97                                              C
C____________________________________________________________________C
C                                                                    C
C If a double precision matrix ABAND is stored in LAPACK format      C
C i.e. with the element a(i,j) being stored in                       C
C  ABAND( KLE + KU + 1 + i - j, j ),                                 C
C then BMRCOP will take either a row or a column of A and            C
C multiply it by ALPHA and add BETA.                                 C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C     NDIM	: Dimension of matrix.                               C
C     IRC	: = 1 to act on ROW                                  C
C                 = 2 to act on COLUMN                               C
C     NRC	: Number of row or column.                           C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     ABAND     : Banded matrix. Dimensions ( NDIM1, NDIM2 ) with    C
C                  NDIM1 = KL + KU + KLE + 1                         C
C                  NDIM2 = Dimension of problem (NDIM ).             C
C     ALPHA	: First multiplies current matrix entry by ALPHA     C
C     BETA 	: Then adds on BETA.                                 C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE BMRCOP( KL, KU, KLE, NDIM, IRC, NRC, ABAND, 
     1                   ALPHA, BETA )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER KL, KU, KLE, NDIM, IRC, NRC
      DOUBLE PRECISION ABAND( KLE + KU + KL + 1, NDIM ) , ALPHA, BETA
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IC, IR, IROW, IND1, IND2
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
c
C     .                    First deal with the case acting on ROWS ...
      IF ( IRC.EQ.1 ) THEN
         IR = NRC
         IND1 = MAX( 1, IR - KL )
         IND2 = MIN( IR + KU, NDIM )
         DO IC = IND1, IND2
            IROW = KLE + KU + 1 + IR - IC
            ABAND( IROW, IC ) = ABAND( IROW, IC )*ALPHA + BETA
         ENDDO
         RETURN
      ENDIF
c
C     .                    First deal with the case acting on COLUMNS.
      IF ( IRC.EQ.2 ) THEN
         IC = NRC
         IND1 = MAX( 1, IC - KU )
         IND2 = MIN( IC + KL, NDIM )
         DO IR = IND1, IND2
            IROW = KLE + KU + 1 + IR - IC
            ABAND( IROW, IC ) = ABAND( IROW, IC )*ALPHA + BETA
         ENDDO
         RETURN
      ENDIF
C
      PRINT *,' Subroutine BMRCOP '
      PRINT *,' IRC must be set to either 1 or 2.'
      PRINT *,' Program aborted.'
      STOP
C
      END
C*********************************************************************
C*********************************************************************
C subroutine CUBic matrix OPeration **********************************
C Steve Gibbons 23.4.97 Does operation on a three-dimensional array. C
C                                                Can set equal to a  C
C                       constant; multiply by a constant or have a   C
C                       constant added to it.                        C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IOP	: Type of operation to be done.                      C
C                  IOP=0  -->  Each element of the matrix = CONST    C
C                  IOP=1  -->  Each el. is multiplied by CONST       C
C                  IOP=2  -->  Each el. is added to CONST            C
C     NDIM1     : First dimension of the matrix.	             C
C     NDIM2     : Second dimension of the matrix.	             C
C     NDIM3     : Third dimension of the matrix.	             C
C  Double Precision                                                  C
C  ----------------                                                  C
C     CUBE	: Matrix with dimension ( NDIM1, NDIM2 , NDIM3)      C
C     CONST     : Double precision constant.                         C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE CUBEOP ( CUBE, CONST, NDIM1, NDIM2, NDIM3, IOP)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NDIM1, NDIM2, NDIM3, IOP
      DOUBLE PRECISION CUBE ( NDIM1, NDIM2, NDIM3 ), CONST
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I, J, K
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First do case IOP=0 
      IF ( IOP.EQ.0 ) THEN
         DO K = 1, NDIM3
           DO J = 1, NDIM2
              DO I = 1, NDIM1
                 CUBE ( I, J, K) = CONST
              ENDDO
           ENDDO
         ENDDO
         RETURN
      ENDIF
C Now do case IOP=1
      IF ( IOP.EQ.1 ) THEN
         DO K = 1, NDIM3
           DO J = 1, NDIM2
              DO I = 1, NDIM1
                 CUBE ( I, J, K) = CUBE ( I, J, K)*CONST
              ENDDO
           ENDDO
         ENDDO
         RETURN
      ENDIF
C Now do case IOP=2
      IF ( IOP.EQ.2 ) THEN
         DO K = 1, NDIM3
           DO J = 1, NDIM2
              DO I = 1, NDIM1
                 CUBE ( I, J, K) = CUBE ( I, J, K) + CONST
              ENDDO
           ENDDO
         ENDDO
         RETURN
      ENDIF
      PRINT *,' Subroutine CUBEOP. IOP must be 0,1 or 2.'
      STOP
      END
C*********************************************************************

C*********************************************************************
C subroutine Fast Fourier Transform ReaL Version *********************
C            -    -       -         -  - -       *********************
C Steve Gibbons 22.4.97 (Based on FOUR1 from Numerical Recipes       C
C      I've made slight alterations for double precision, error      C
C      checking at the start and rescaling the coefficients after    C
C      the forward transform.)                                       C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     NN	: Number of data to be transformed.		     C
C                  NN MUST be a power of two. This is checked for by C
C                  the subroutine POWTWO.                            C
C                                                                    C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       C
C                                                                    C
C    The real function f( PHI ) must be periodic, satisfying         C
C    f( PHI ) = f( PHI + 2*PI )                                      C
C                                                                    C
C    f( PHI ) has the formulation                                    C
C                                                                    C
C    f( PHI ) = sum_{m=0}^M [ c_m cos(m PHI) + s_m sin( m PHI) ]     C
C                                                                    C
C    FFTRLV will transform between the coefficients {c_m, s_m}       C
C    and discretised values of f at NN equally spaced points PHI_i   C
C    with                                                            C
C                                                                    C
C    PHI_i = (i-1)*DELTA_phi          and                            C
C                                                                    C
C    DELTA_phi = 2*PI/dble( NN )                                     C
C                                                                    C
C  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -       C
C                                                                    C
C     ISIGN	:                                                    C
C                                                                    C
C    If ISIGN = 1, on entry DATA( 2*I - 1 ) must contain the value   C
C    of f at the point PHI = PHI_i as defined above.                 C
C                                                                    C
C    On exit, DATA( 2*m + 1 ) will contain the coeff. c_m and        C
C             DATA( 2*m + 2 ) will contain the coeff. s_m and        C
C                                                                    C
C    for m = 0, M.                                                   C
C      For accuracy, M **MUST** be less than NN/2                    C
C    (This is the Nyquist criterion - see Numerical Recipes ).       C
C                                                                    C
C    If ISIGN = -1, DATA must be zero except for the values          C
C    c_m contained in DATA( 2*m + 1 )  and                           C
C    s_m contained in DATA( 2*m + 2 ) on input.                      C
C                                                                    C
C    On output, f( PHI_i ) will be contained in DATA( 2*I - 1 ).     C
C                                                                    C
C    Note that this routine SCALES the coefficients after            C
C    transforming, which the Numerical Recipes version doesn't.      C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     DATA	: Array of dimension (2*NN). See above ...           C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE FFTRLV ( DATA, NN, ISIGN )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER NN, ISIGN
      DOUBLE PRECISION DATA( 2 * NN )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION TEMPR,TEMPI,THETA,WPR,WPI,WR,WI,WTEMP,FAC
      INTEGER I,J,N,M,MMAX,ISTEP
c     LOGICAL POWT
      DOUBLE PRECISION PI, HTHETA
      PARAMETER (PI=3.14159265358979312D0)
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C 
C  SJG Mon Feb  5 18:18:33 WET 2001
C  I have commented out the power of two checking
C  for speed: reinstate if necessary:
C 
C First check that the number NN supplied is infact a power of 2.
c     CALL POWTWO ( NN, POWT)
c     IF ( .NOT. POWT) THEN
c        PRINT *,' Subroutine FFTRLV. NN is not a power of 2.'
c        PRINT *,'Program aborted.'
c        STOP
c     ENDIF
C Now check that ISIGN = 1 or -1.
      IF ( ISIGN*ISIGN .NE. 1) THEN
         PRINT *,' Subroutine FFTRLV. ISIGN must be 1 or -1.'
         PRINT *,'Program aborted.'
         STOP
      ENDIF
C____________________________________________________________________C
C Here we will zero the imaginary part of the function
C just incase it contains non-zero data which may harm the
C outcome.
C
      IF ( ISIGN.EQ.1 ) THEN
        DO I = 1, NN
          DATA( 2*I ) = 0.0d0
        ENDDO
      ENDIF
C
C____________________________________________________________________C
C
      N = 2 * NN
      J = 1
      DO I = 1, N, 2
         IF ( J.GT.I ) THEN
            TEMPR = DATA( J )
            TEMPI = DATA( J+1 )
            DATA( J ) = DATA( I )
            DATA( J+1 ) = DATA( I+1 )
            DATA( I ) = TEMPR
            DATA( I+1 ) = TEMPI
         ENDIF
C ... now calculate inverse bit map for next value of I.
         M = N/2
 500     IF ( M.GE.2 .AND. J.GT.M ) THEN
            J = J-M
            M = M/2
            GOTO 500
         ENDIF
         J = J + M
      ENDDO
C ............. now do the real part of transform.
      MMAX = 2
 502  IF ( N.GT.MMAX ) THEN
         ISTEP = 2*MMAX
         HTHETA = PI/DBLE(ISIGN*MMAX)
c        THETA = 2.0d0*PI/DBLE(ISIGN*MMAX)
C set THETA temporarily
         THETA = DSIN(HTHETA)
         WPR = -2.0d0*THETA*THETA
c        WPR = -2.0d0*DSIN(HTHETA)**2
         THETA = 2.0d0*HTHETA
         WPI = DSIN(THETA)
         WR = 1.0d0
         WI = 0.0d0
         DO M = 1, MMAX, 2
            DO I = M, N, ISTEP
               J = I + MMAX
               TEMPR = WR*DATA( J ) - WI*DATA( J + 1 )
               TEMPI = WR*DATA( J + 1 ) + WI*DATA( J )
               DATA( J ) = DATA( I ) - TEMPR
               DATA( J + 1 ) = DATA( I + 1 ) - TEMPI
               DATA( I ) = DATA( I ) + TEMPR
               DATA( I + 1 ) = DATA( I + 1 ) + TEMPI
            ENDDO
            WTEMP = WR
            WR = WR*WPR - WI*WPI + WR
            WI = WI*WPR + WTEMP*WPI + WI
         ENDDO
         MMAX = ISTEP
         GOTO 502
      ENDIF
C
      IF ( ISIGN.EQ.1 ) THEN
        FAC = 2.0d0/DBLE( NN )
        DO I = 1, NN
          DATA( I ) = FAC*DATA( I )
        ENDDO
        DO I = NN+1, 2*NN
          DATA( I ) = 0.0d0
        ENDDO
      ENDIF
C
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine Double precision VECtor Zero ****************************
C Steve Gibbons Wed Feb 14 09:01:11 WET 2001                         C
C____________________________________________________________________C
C                                                                    C
C Sets to zero a double precision vector, VEC, of length N.          C
C                                                                    C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C     N		: Length of the vector.                              C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     VEC	: Vector - dimension ( N )                           C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE DVECZ( VEC, N )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER          N
      DOUBLE PRECISION VEC( N )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER          I
      DOUBLE PRECISION DZERO
      PARAMETER      ( DZERO = 0.0d0 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      DO I = 1, N
        VEC( I ) = DZERO
      ENDDO
      RETURN
      END
C*********************************************************************


C*********************************************************************
C subroutine Adapted Matrix DL Terms *********************************
C            -       -      -- -     *********************************
C Steve Gibbons Tue Oct 26 15:24:17 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Supplies coefficients to the routine AMLICA for terms with the     C
C function D_l to the power 0, 1 or 2. Must be declared EXTERNAL     C
C in the (sub)program which calls AMLICA and must replave SUB1 in    C
C the calling sequence.                                              C
C                                                                    C
C Set IPARS( 1 ) to IFLAG                                            C
C                                                                    C
C Now if IFLAG = 1, D_l^0 is added to the matrix - i.e. the identity C
C                   IHD can be zero.                                 C
C                                                                    C
C        IFLAG = 2, D_l is added to the matrix.                      C
C                   This returns                                     C
C                                                                    C
C                     CVEC( 1 ) = (-1.0d0)*DBLE( L*L+L )/(RAD*RAD)   C
C                     CVEC( 2 ) =   2.0d0/RAD                        C
C                     CVEC( 3 ) =   1.0d0                            C
C                                                                    C
C                   IHD must be atleast 2.                           C
C                                                                    C
C        IFLAG = 3, D_l^2 is added to the matrix                     C
C                                                                    C
C                     CVEC( 1 ) = (L+2)(L+1)L(L-1)/RAD**4            C
C                     CVEC( 2 ) =  0.0d0                             C
C                     CVEC( 3 ) = -2L(L+1)/RAD**2                    C
C                     CVEC( 4 ) = 4/RAD                              C
C                     CVEC( 5 ) =  1.0d0                             C
C                                                                    C
C  The integer L is passed in as IPARS( 2 ).                         C
C                                                                    C
C  All other parameters are looked after by AMLICA and most are      C
C  dummy parameters.                                                 C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMDLT( CVEC, RAD, IPARS, DPARS, IHD )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IPARS( * ), IHD
      DOUBLE PRECISION CVEC( * ), RAD, DPARS( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IHDMIN( 3 ), IFLAG, L, ND
      DOUBLE PRECISION TOL
      PARAMETER ( TOL = 1.0d-8 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C Check on value of RAD
C     .
      IF ( ABS( RAD ).LT.TOL ) THEN
         PRINT *,' Subroutine AMDLT.'
         PRINT *,' RAD = ', RAD
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C
C Just apply the minimum values of IHD to the IHDMIN array.
C
C     .
      IHDMIN( 1 ) = 0
      IHDMIN( 2 ) = 2
      IHDMIN( 3 ) = 4
C     .
      IFLAG = IPARS( 1 )
      L     = IPARS( 2 )
C     .
C     . Check for valid value of IFLAG
C     .
      IF ( IFLAG.LT.1 .OR. IFLAG.GT.3 ) THEN
         PRINT *,' Subroutine AMDLT.'
         PRINT *,' IFLAG = ', IFLAG
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . ok - so our chosen boundary condition is valid
C     . now check that IHD is large enough
C     .
      IF (     IHD.NE.IHDMIN( IFLAG )    ) THEN
         PRINT *,' Subroutine AMDLT.'
         PRINT *,' IHD = ',IHD,' and must be atleast'
         PRINT *,  IHDMIN( IFLAG ),' for option ',IFLAG
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Zero all coefficients up to IHD
C     .
      DO ND = 1, IHD + 1
        CVEC( ND ) = 0.0d0
      ENDDO
C     .
C     . Option 1:
C     . D_l^0
C     .
      IF ( IFLAG.EQ.1 ) THEN
         CVEC( 1 ) = 1.0d0
         RETURN
      ENDIF
C     .
C     . Option 2:
C     . D_l
C     .
      IF ( IFLAG.EQ.2 ) THEN
         CVEC( 1 ) = (-1.0d0)*DBLE( L*L+L )/(RAD*RAD)
         CVEC( 2 ) = 2.0d0/RAD
         CVEC( 3 ) = 1.0d0
         RETURN
      ENDIF
C     .
C     . Option 3:
C     . D_l^2
C     .
      IF ( IFLAG.EQ.3 ) THEN
         CVEC( 1 ) = DBLE( (L+2)*(L+1)*L*(L-1) )/RAD**4
         CVEC( 3 ) = (-2.0d0)*DBLE( L*L + L )/RAD**2
         CVEC( 4 ) = 4.0d0/RAD
         CVEC( 5 ) = 1.0d0
         RETURN
      ENDIF
C     .
      END
C*********************************************************************

C*********************************************************************
C subroutine Adapted Matrix Linear Interaction Contribution Add ******
C            -       -      -      -           -            -   ******
C Steve Gibbons Tue Oct 26 15:58:14 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C  Adds to the double precision matrix, A, the terms which a single  C
C harmonic IHC contributes to a single harmonic IHR in a single term C
C of a coupled o.d.e. when the grid in radius is not necessarily     C
C uniform and the j^[th} abscissa has a radial value of XARR( j )    C
C                                                                    C
C A Linear contribution indicates one which is merely the function   C
C of radius and a finite number of integer and double precision      C
C constants.                                                         C
C                                                                    C
C See below for the form of the subroutine which gives this          C
C function.                                                          C
C                                                                    C
C Let the radial function of the IHR harmonic be denoted f_{IHR)(r)  C
C Let the radial function of the IHC harmonic be denoted f_{IHC)(r)  C
C                                                                    C
C If the contribution for a given radial node, $r_j$, is of the form C
C                                                                    C
C f_{IHR)(r_j) = \sum_{nd=0,IHD} f_{IHC}^{nd}(r_j) c_{IHC}^{nd}(r_j) C
C                                                                    C
C  (where f^{nd} denotes the (nd)^{th} derivative of f with respect  C
C  to r, evaluated at r_j)                                           C
C                                                                    C
C then the coefficient c_{IHC}^{nd}(r_j) must be supplied by the     C
C subroutine SUB1 (declared EXTERNAL in the calling (sub)program )   C
C which returns c_{IHC}^{nd}(r_j) in the array element CVEC(nd + 1). C
C                                                                    C
C The subroutine SUB1 *MUST* have the calling sequence               C
C                                                                    C
C SUB1( CVEC, RAD, IPARS, DPARS, IHD )                               C
C                                                                    C
C where  RAD is the double precision value of the radius,            C
C        IPARS is an integer array to provide SUB1 with parameters.  C
C          IPARS is not referred to by AMLICA other than to pass     C
C          this information.                                         C
C        DPARS is like IPARS but contains double precision elements. C
C        IHD is the highest derivative which will be refered to by   C
C        AMLICA. So all CVEC( i ) must be zero with 1.le.i.le.ihd+1  C
C        if it is not assigned another value.                        C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     N1        : Leading dimension of the matrix.                   C
C     N2        : Second dimension of the matrix.                    C
C     KL        : Number of lower diagonals in banded matrix.        C
C     KU        : Number of upper diagonals in banded matrix.        C
C     KLE       : Number of extra lower diagonals in banded          C
C                  matrix. This is to make the matrix solvable by    C
C                   LAPACK routines.                                 C
C                                                                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ).               C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     IHC       : Number of the input (column) harmonic              C
C     IHR       : Number of the output (row) harmonic                C
C                                                                    C
C     INARR     : Array of integers. Dimension ( * )                 C
C                 At present the elements of INARR are as follows.   C
C                                                                    C
C                 INARR( 1 ) = IFORMF. Format flag.                  C
C                  This flag decides how the elements are arranged   C
C                  in the solution vector.                           C
C                                                                    C
C                  The current options are:-                         C
C                                                                    C
C                   IFORMF = 1. INDFUN = ( IR - 1 )*NH + IH          C
C                   IFORMF = 2. INDFUN = ( IH - 1 )*NR + IR          C
C                                                                    C
C  where IR and IH are the current grid node and harmonic resp.      C
C  and NR and NH are the total numbers of nodes and harmonics        C
C  in the solution vector.                                           C
C                                                                    C
C                 INARR( 2 ) = NR. Number of radial grid nodes.      C
C                 INARR( 3 ) = NH. Number of harmonics in sol. vect. C
C                                                                    C
C     IHD       : Highest derivative involved.                       C
C     NBN       : Number of diagonal elements in radius.             C
C     ILNR      : Left-most node at which to start adding rows to    C
C                   matrix.                                          C
C     IRNR      : Right-most node at which to start adding rows to   C
C                   matrix.                                          C
C                                                                    C
C     NFDCM     : Leading dim of SVFDC. See SVFDCF.                  C
C                  (Must be atleast 2*NBN + 1 )                      C
C                                                                    C
C     NR        : Number of radial grid nodes.                       C
C     NDCS      : Maximum distinct finite difference schemes         C
C                  stored by the array SVFDC.                        C
C     IS        : Number of required finite difference scheme.       C
C                  (This points to the fourth dim. element in        C
C                   the coefficient array SVFDC.)                    C
C                                                                    C
C     NDRVS     : Highest derivative stored in SVFDC.                C
C                 (Must be atleast 1).                               C
C     NDRVM     : Limit on NDRVS. Array bound for SVFDC.             C
C                                                                    C
C     IPARS     : Information array for SUB1. Dimension ( * )        C
C                                                                    C
C  Subroutines                                                       C
C  -----------                                                       C
C     SUB1      : Determines what multiplies each derivative in      C
C                  the matrix. Must have calling sequence ...        C
C                                                                    C
C     CALL SUB1 ( CVEC, RAD, IPARS, DPARS, IHD )                     C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     AMAT      : Matrix. Dimensions ( N1, N2 )                      C
C              Will generally be banded due to the nature of the     C
C              numerical scheme. KL, KU and KLE parameterise this.   C
C                                                                    C
C     FAC       : Multiplication factor.                             C
C                                                                    C
C     XARR      : Array of dimension ( NR )                          C
C                 XARR( j ) = element x_j                            C
C                                                                    C
C     WORK      : Working array of dimension ( NDRVS + 1 )           C
C                                                                    C
C     DPARS     : Information array for SUB1. Dimension ( * )        C
C                                                                    C
C     SVFDC     : Finite difference coefficient matrix.              C
C                  Dimension ( NFDCM, NR, NDRVM+1, NDCS ).           C
C                   Array is generated by the routine svfdcf         C
C                 See documentation for SVFDCF for details.          C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMLICA( N1, N2, KL, KU, KLE, IMF, IHC, IHR, INARR,
     1                   IHD, NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS,
     2                   NDRVS, NDRVM, IPARS, SUB1, AMAT, FAC, XARR,
     3                   WORK, DPARS, SVFDC )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER N1, N2, KL, KU, KLE, IMF, IHC, IHR, INARR( * ), IHD,
     1        NBN, ILNR, IRNR, NFDCM, NR, NDCS, IS, NDRVS, NDRVM,
     2        IPARS( * )
      EXTERNAL SUB1
      DOUBLE PRECISION AMAT( N1, N2 ), FAC, XARR( NR ),
     1                 WORK( NDRVS + 1 ), DPARS( * ),
     2                 SVFDC( NFDCM, NR, NDRVM+1, NDCS )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
C
      INTEGER IRAD, INODE, NLN, NRN, INDFUN, INDR, INDC,
     1        IROW, ICOL, NH, IFORMF, NLCS, NRCS, I,
     2        NDER, ICOROW, ICOCOL, NRR
      DOUBLE PRECISION RAD, LOW
      PARAMETER ( LOW = 1.0d-9 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First we check for an easy exit - 
C if FAC = 0.0d0 there is no point in doing this  ...
C
C     .
      IF ( ABS( FAC ).LT.LOW ) RETURN
C     .
      IFORMF = INARR( 1 )
      NRR    = INARR( 2 )
      NH     = INARR( 3 )
C     .
C     . Check validity of NRR. Because it is an array
C     . dimension, NR has to be passed in the parameter
C     . list and so we must ensure we are consistent
C     .
      IF ( NRR.NE.NR ) THEN
         PRINT *,' Subroutine AMLICA.'
         PRINT *,' INARR( 2 ) = ', NRR
         PRINT *,' NR = ', NR
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Check that we really are dealing with
C     . a non-uniform grid.
C     .
      IF ( IFORMF.NE.3 .AND. IFORMF.NE.4 ) THEN
        PRINT *,' Subroutine AMLICA. IFORMF = ',IFORMF
        PRINT *,' This is not the uniform grid code.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Check size of IHD
C     .
      IF ( IHD.GT.NDRVS ) THEN
        PRINT *,' Subroutine AMLICA. '
        PRINT *,' IHD   = ', IHD
        PRINT *,' NDRVS = ', NDRVS
        STOP
      ENDIF
C     .
C     . Check N2 for case of IFORMF = 3 and 4
C     .
      IF ( IFORMF.EQ.3 .OR. IFORMF.EQ.4 ) THEN
        IF ( N2.NE.NH*NR ) THEN
          PRINT *,' Subroutine AMLICA. N2 = ', N2
          PRINT *,' NH = ', NH,' NR = ', NR
          PRINT *,' Program aborted.'
          STOP
        ENDIF
      ENDIF
C     .
C     . Check N1 for IMF.EQ.1 and IMF.EQ.3
C     .
      IF ( ( IMF.EQ.1 .AND. N1.NE.(KLE+KL+KU+1) ) .OR.
     1     ( IMF.EQ.3 .AND. N1.NE.N2           )      ) THEN
         PRINT *,' Subroutine AMLICA. IMF = ',IMF
         PRINT *,' N1 = ', N1,' N2 = ',N2
         PRINT *,' KL = ', KL,' KU = ',KU
         PRINT *,' KLE = ', KLE
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Now we will check that we have sufficient
C     . band width to be able to calculate the
C     . IHD^{th} derivative of a function.
C     . IHD must be less than or equal to the
C     . minimum value of (NLN + NRN)
C     . 
C     . To do this, we calculate NLCS and NRCS
C     . which are respectively the minimum number
C     . of points you will ever find on the left
C     . and the right of your node, IRAD.
C     .
      NLCS = ILNR - 1
      NRCS = NR   - IRNR
C
C Just check that we have sufficiently many grid nodes
C to be able to enforce all equations.
C
      IF ( NLCS.LT.0 ) THEN
        PRINT *,' Subroutine AMLICA.'
        PRINT *,' ILNR = ', ILNR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      IF ( NRCS.LT.0 ) THEN
        PRINT *,' Subroutine AMLICA.'
        PRINT *,' IRNR = ', IRNR
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C
      I = MIN( NLCS, NRCS) + NBN
      IF ( IHD.GT.I ) THEN
        PRINT *,' Subroutine AMLICA.'
        PRINT *,' You want a derivative of order ', IHD
        PRINT *,' However, there is a node at which you '
        PRINT *,' only have ',I,' points for a derivative.'
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
C     . Ok - we now loop around the radial nodes for the
C     . rows ... 
C     .
      DO IRAD = ILNR, IRNR
C       .
C       . Calculate the corresponding index and radius
C       .
        INDR = INDFUN( IRAD, IHR, INARR )
        RAD = XARR( IRAD )
C       .
C       . Calculate NLN and NRN
C       .
        NLN = MIN( NBN, IRAD - 1 )
        NRN = MIN( NBN, NR - IRAD )
C       .
        CALL SUB1( WORK, RAD, IPARS, DPARS, IHD )
C       .
C       . So now loop around the nodes from (IRAD - NLN)
C       . to (IRAD + NRN)
C       .
        DO INODE = IRAD - NLN, IRAD + NRN
C          .
C          . This is the row of the finite
C          . difference coefficients matrix
C          . which will contain the correct values.
C          .
           ICOCOL = INODE - IRAD + NBN + 1
C          .
C          . find the corresponding matrix column
C          .
           INDC = INDFUN( INODE, IHC, INARR )
C          .
C          . Find the actual location in the AMAT array
C          .
           CALL MATIND (INDR,INDC,IMF,KL,KU,KLE,N1,N2,IROW,ICOL)
C          .
           DO NDER = 0, IHD
             ICOROW = NDER + 1
             AMAT( IROW, ICOL ) = AMAT( IROW, ICOL ) + 
     1         FAC*WORK( ICOROW )*SVFDC( ICOCOL, IRAD, ICOROW, IS )
           ENDDO
C          .
        ENDDO
C       .
      ENDDO
C     .
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Matrix Curl of Coriolis Force Terms *************
C            -       -      -       -        -     -     *************
C Steve Gibbons Sun Nov 14 17:50:22 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C Supplies coefficients to the routine AMLICA for the terms          C
C involving curl ( k x v ) in the vorticity equation.                C
C                                                                    C
C I have derived the forms of the terms in the LATEX user guide      C
C although as an alternative, all these terms are found in eqn.s     C
C (B.55), (B.56), (B.58) and (B.59) of my Ph.D. thesis               C
C                                                                    C
C 'Dynamo Models of the Earth's Magnetic Field'                      C
C     (University of Leeds 1998)                                     C
C                                                                    C
C Set IPARS( 1 ) to  IQSTA  i.e. 1, 2 or 3 depending on whether      C
C the harmonic in the velocity is scaloidal, spheroidal or toroidal. C
C                                                                    C
C Set IPARS( 2 ) to  LA - the spherical harmonic degree of the       C
C input velocity harmonic.                                           C
C                                                                    C
C Set IPARS( 3 ) to  IQSTG  i.e. 1, 2 or 3 depending on whether      C
C the harmonic in the output is scaloidal, spheroidal or toroidal.   C
C                                                                    C
C Set IPARS( 4 ) to  LG - the spherical harmonic degree of the       C
C output function harmonic.                                          C
C                                                                    C
C Set DPARS( 1 ) = K^{\alpha \beta}_{xy} as defined in eqn.s         C
C (B.42), (B.43) and (B.44) of my thesis.                            C
C                                                                    C
C  x is 'q' when IQSTA = 1                                           C
C  x is 's' when IQSTA = 2                                           C
C  x is 't' when IQSTA = 3                                           C
C                                                                    C
C  y is 'q' when IQSTG = 1                                           C
C  y is 's' when IQSTG = 2                                           C
C  y is 't' when IQSTG = 3                                           C
C                                                                    C
C                                                                    C
C                                                                    C
C  All other parameters are looked after by AMLICA.                  C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMCCFT( CVEC, RAD, IPARS, DPARS, IHD )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IPARS( * ), IHD
      DOUBLE PRECISION CVEC( * ), RAD, DPARS( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IHDMIN( 3, 3 ), ND, IQSTA, LA, IQSTG, LG
      DOUBLE PRECISION TOL, FAC, FLA, FLG, SQRLL1
      PARAMETER ( TOL = 1.0d-8 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C     .
      IQSTA = IPARS( 1 )
      LA    = IPARS( 2 )
      IQSTG = IPARS( 3 )
      LG    = IPARS( 4 )
C     .
      FAC   = DPARS( 1 )
C     .
      FLA = SQRLL1( LA )
      FLG = SQRLL1( LG )
C     .
C Check on value of RAD
C     .
      IF ( ABS( RAD ).LT.TOL ) THEN
         PRINT *,' Subroutine AMCCFT.'
         PRINT *,' RAD = ', RAD
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . check value of IHD
C     .
      IHDMIN( 1, 1 ) = 100
C (this routine should not be called with 1 and 1 )
C     .
      IHDMIN( 1, 3 ) = 0
      IHDMIN( 2, 3 ) = 1
      IHDMIN( 2, 1 ) = 1
      IHDMIN( 2, 2 ) = 2
      IHDMIN( 1, 2 ) = 1
      IHDMIN( 3, 3 ) = 0
      IHDMIN( 3, 2 ) = 1
      IHDMIN( 3, 1 ) = 0
C     .
      IF ( IHD.LT.IHDMIN( IQSTA, IQSTG) ) THEN
         PRINT *,' Subroutine AMCCFT.'
         PRINT *,' IHD       = ', IHD
         PRINT *,' IQSTA     = ', IQSTA
         PRINT *,' IQSTG     = ', IQSTG
         PRINT *,' IHDMIN    = ', IHDMIN( IQSTA, IQSTG)
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Zero all coefficients up to IHD
C     .
      DO ND = 1, IHD + 1
        CVEC( ND ) = 0.0d0
      ENDDO
C     .
C     . First K_{qt} term (eq. B.55 in thesis)
C     . 
      IF ( IQSTA.EQ.1 .AND. IQSTG.EQ.3 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FLA*FAC/(RAD*FLG)
        RETURN
      ENDIF
C     .
C     . Now K_{st} term (eq. B.55 in thesis)
C     .
      IF ( IQSTA.EQ.2 .AND. IQSTG.EQ.3 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FAC/(FLG*RAD)
        CVEC( 2 ) = (-1.0d0)*FLA*FAC/FLG
        RETURN
      ENDIF
C     .
C     . Now K_{sq} term (eq. B.56 in thesis)
C     .
      IF ( IQSTA.EQ.2 .AND. IQSTG.EQ.1 ) THEN
        CVEC( 1 ) = FLA*FAC/(RAD*RAD)
        CVEC( 2 ) = FLA*FAC/RAD
        RETURN
      ENDIF
C     .
C     . Now K_{ss} term (eq. B.56 in thesis)
C     .
      IF ( IQSTA.EQ.2 .AND. IQSTG.EQ.2 ) THEN
        CVEC( 2 ) = (-2.0d0)*FLA*FAC/(RAD*FLG)
        CVEC( 3 ) = (-1.0d0)*FLA*FAC/FLG
        RETURN
      ENDIF
C     .
C     . Now K_{qs} term (eq. B.56 in thesis)
C     .
      IF ( IQSTA.EQ.1 .AND. IQSTG.EQ.2 ) THEN
        CVEC( 2 ) = (-1.0d0)*FLA*FLA*FAC/(RAD*FLG)
        RETURN
      ENDIF
C     .
C     . Now K_{tt} term (eq. B.58 in thesis)
C     .
      IF ( IQSTA.EQ.3 .AND. IQSTG.EQ.3 ) THEN
        CVEC( 1 ) = FLA*FAC/FLG
        RETURN
      ENDIF
C     .
C     . Now K_{ts} term (eq. B.59 in thesis)
C     .
      IF ( IQSTA.EQ.3 .AND. IQSTG.EQ.2 ) THEN
        CVEC( 1 ) = FLA*FAC/(FLG*RAD)
        CVEC( 2 ) = FLA*FAC/FLG
        RETURN
      ENDIF
C     .
C     . Now K_{tq} term (eq. B.59 in thesis)
C     .
      IF ( IQSTA.EQ.3 .AND. IQSTG.EQ.1 ) THEN
        CVEC( 1 ) = (-1.0d0)*FLA*FAC/RAD
        RETURN
      ENDIF
C     .
      PRINT *,' Subroutine AMCCFT.'
      PRINT *,' Your options are invalid.'
      PRINT *,' IQSTA = ', IQSTA,' LA = ', LA
      PRINT *,' IQSTG = ', IQSTG,' LG = ', LG
      PRINT *,' Program aborted.'
      STOP
      END
C*********************************************************************
C*********************************************************************
C subroutine CORiolis force COefficient Find *************************
C            ---            --          -    *************************
C Steve Gibbons 19.6.97                                              C
C____________________________________________________________________C
C Takes an input of a single Q, S or T harmonic and returns the      C
C array QST with the appropriate coefficients for the coriolis force C
C of the single starting vector harmonic.                            C
C____________________________________________________________________C
C                                                                    C
C PRE-REQUISITES                                                     C
C --------------                                                     C
C     The Gaussian Weights and Legendre Polynomials must be found    C
C using routines GAUWTS and SCHNLA. Use the calling sequence ...     C
C                                                                    C
C >      X1 = -1.0d0                                                 C
C >      X2 =  1.0d0                                                 C
C >                                                                  C
C >      CALL GAUWTS ( X1, X2, GAUX, GAUW, NTHPTS, NTHMAX )          C
C >                                                                  C
C >      CALL SCHNLA ( PA, DPA, GAUX, LH, LHMAX, NTHPTS, NTHMAX)     C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IQST      : IQST = 1 for starting with a Q harmonic.           C
C                 IQST = 2 for starting with an S harmonic.          C
C                 IQST = 3 for starting with a T harmonic.           C
C     L    	: Spherical harmonic degree, l.                      C
C     M    	: Spherical harmonic order, m.                       C
C     ICS  	: 1 for cos m phi, 2 for sin m phi ...               C
C     LH   	: Maximum spherical harmonic degree, l.              C
C     NPHPTS	: The number of phi points.                          C
C     NTHPTS	: The number of theta points.                        C
C     MMAX 	: Maximum spherical harmonic order, m.               C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C     GAUX      : Cosines of the NTHPTS evaluated by the routine     C
C                  gauwts. Dimension ( NTHPTS ).                     C
C     GAUW      : Corresponding weights. As above.                   C
C     PA        : Schmidt Normalised Legendre Functions              C
C                  Dim { ( LH + 1 )*( LH + 2 )/2 , NTHPTS }          C
C                  P_l^m(X_j) = PA( L*(L+1)/2 + M + 1 , j )          C
C     DPA       : Derivatives of the above.                          C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     QST       : Output array containing scaloidal/spheroidal       C
C                  toroidal decomposition of vector.                 C
C                  Has dimensions ( LH*(LH+2), 3).                   C
C               QST (l*l+2m,1) = q_l^ms(r_i)                         C
C    QST (l*l+2m-1+delta_m0,1) = q_l^mc(r_i)                         C
C               QST (l*l+2m,2) = s_l^ms(r_i)                         C
C    QST (l*l+2m-1+delta_m0,2) = s_l^mc(r_i)                         C
C               QST (l*l+2m,3) = t_l^ms(r_i)                         C
C    QST (l*l+2m-1+delta_m0,3) = t_l^mc(r_i)                         C
C____________________________________________________________________C
C Working Arrays   :-                                                C
C ================                                                   C
C  Double Precision                                                  C
C  ----------------                                                  C
C     FTF1	: Array for Fourier transforming dim. (2*NPHPTS)     C
C     FTF2	: Array for Fourier transforming dim. (2*NPHPTS)     C
C     FTF3	: Array for Fourier transforming dim. (2*NPHPTS)     C
C     VF	: Vector function. dimensions ( NPHPTS, NTHPTS, 3)   C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE CORCOF( IQST, L, M, ICS, QST, LH, NPHPTS, NTHPTS,
     1             FTF1, FTF2, FTF3, VF, GAUX, GAUW, PA, DPA, MMAX )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IQST, L, M, ICS, LH, NPHPTS, NTHPTS, MMAX
      DOUBLE PRECISION 
     1                 QST( LH*(LH+2), 3),
     2                 VF( NPHPTS, NTHPTS, 3), FTF1( 2*NPHPTS ),
     3                 FTF2( 2*NPHPTS ), FTF3( 2*NPHPTS )
      DOUBLE PRECISION
     1                 GAUX( NTHPTS ), GAUW( NTHPTS ),
     2                 PA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS),
     3                 DPA ( ( LH + 1 )*( LH + 2 )/2 , NTHPTS)
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION ZCOEF
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C Let's evaluate this harmonic in space, stored in array VF
C
      CALL SHVECT ( L, M, ICS, IQST, VF, GAUX, PA, DPA,
     1              NTHPTS, NPHPTS, LH )
C
C Now let's take the coriolis vector on it ..............
      CALL VFCOR ( NTHPTS, NPHPTS, VF, GAUX )
C
C Let's convert back to QST values ........................
C
      CALL VF2QST ( QST, VF, GAUX, GAUW, PA, DPA, FTF1, FTF2, FTF3,
     1              ZCOEF, LH, NTHPTS, NPHPTS, MMAX )
C 
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine Adapted Matrix Heat Source Auxilliary Routine ***********
C            -       -      -    -      -          -       ***********
C Steve Gibbons Thu Nov 18 17:54:58 GMT 1999                         C
C____________________________________________________________________C
C                                                                    C
C If \nabla^2 T_0( r ) = C (C is a constant), then T_0 has the       C
C general solution                                                   C
C                                                                    C
C            CB1 r^2                                                 C
C T_0( r ) = ------- - CB2 r^{-1}      (cb1 and cb2 are constants)   C
C               2                                                    C
C                                                                    C
C                                                                    C
C and so                                                             C
C                                                                    C
C              [                                     ]               C
C \nabla T_0 = [  CB1 r  +  CB2 r^{-2}     0     0   ]               C
C              [                       ,      ,      ]               C
C                                                                    C
C                                                                    C
C                                          [         CB2  ]          C
C and so v . \nabla T_0 = l(l+1)P(r) Y_l^m [ CB1 +  ----- ]          C
C                                          [         r^3  ]          C
C                                                                    C
C AMHSAR is an auxilliary routine to AMLICA for adding these terms.  C
C CB1 must be stored in DPARS( 1 )                                   C
C CB2 must be stored in DPARS( 2 )                                   C
C IPARS( 1 ) must contain L (degree of velocity harmonic).           C
C All other terms are looked after by AMLICA.                        C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE AMHSAR( CVEC, RAD, IPARS, DPARS, IHD )
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IPARS( * ), IHD
      DOUBLE PRECISION CVEC( * ), RAD, DPARS( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER L, ND
      DOUBLE PRECISION TOL, CB1, CB2, R3
      PARAMETER ( TOL = 1.0d-8 )
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C Check on value of RAD
C     .
      IF ( ABS( RAD ).LT.TOL ) THEN
         PRINT *,' Subroutine AMHSAR.'
         PRINT *,' RAD = ', RAD
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
      R3 = RAD*RAD*RAD
C     .
      L     = IPARS( 1 )
C     .
      CB1   = DPARS( 1 )
      CB2   = DPARS( 2 )
C     .
C     . ok - so our chosen boundary condition is valid
C     . now check that IHD is large enough
C     .
      IF (     IHD.LT.0    ) THEN
         PRINT *,' Subroutine AMHSAR.'
         PRINT *,' IHD = ',IHD,' and must be atleast 0.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C     .
C     . Zero all coefficients up to IHD
C     .
      DO ND = 1, IHD + 1
        CVEC( ND ) = 0.0d0
      ENDDO
C     .
      CVEC( 1 ) = DBLE( L*L + L )*( CB1 + CB2/R3 )
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C subroutine MATrix INDices ******************************************
C            ---    ---     ******************************************
C Steve Gibbons                                                      C
C____________________________________________________________________C
C                                                                    C
C  Tues. Nov 3rd. 1998                                               C
C  -------------------                                               C
C In order that subroutines which write matrices can be adapted to   C
C write in different storage formats, this routine takes IR and IC   C
C (the ACTUAL coordinates of the 'physical' matrix) and calculates   C
C IROW and ICOL (the row and column number in which the number is    C
C to be placed). Hence, the same code will be able to write to a     C
C matrix of any format.                                              C
C  The code also checks that the bounds of the matrix have not       C
C been exceeded.                                                     C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IR        : Row from theoretical matrix.                       C
C     IC        : Column from theoretical matrix.                    C
C     IMF       : Matrix format flag.                                C
C                                                                    C
C          imf = 1; Matrix is in LAPACK banded format                C
C                   ie element a_{i,j} is stored in                  C
C                   A( kle + ku + 1 + i - j , j )                    C
C                                                                    C
C          imf = 2; Matrix is banded but with element a_{i,j}        C
C                   stored in A( kl + 1 + j - i , i ). The matrices  C
C                   in Dave Gubbins' dynamo codes are in this        C
C                   format.                                          C
C                                                                    C
C          imf = 3; Matrix is square - ie a_{i,j} is stored          C
C                   in A( i, j ).                                    C
C                                                                    C
C     KL        : Number of lower diagonals in band matrix.          C
C     KU        : Number of upper diagonals in band matrix.          C
C     KLE       : Number of additional lower diagonals               C
C                  in band matrix. This should be set to zero for    C
C                  most applications but should be equal to KL if    C
C                  the matrix is to be LU decomposed by a LAPACK or  C
C                  NAG subroutine.                                   C
C                                                                    C
C  ( Note - KL, KU and KLE are not referenced if IMF is set to 3.)   C
C                                                                    C
C     N1        : Leading dimension of matrix A.                     C
C     N2        : Second dimension of matrix A.                      C
C                                                                    C
C       ( Note - i.e. A is dimensioned A( N1, N2 ) ... )             C
C____________________________________________________________________C
C Output variables :-                                                C
C ================                                                   C
C  Integer                                                           C
C  -------                                                           C
C     IROW      : 'i' coordinate in the final matrix.                C
C     ICOL      : 'j' coordinate in the final matrix.                C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      SUBROUTINE MATIND (IR,IC,IMF,KL,KU,KLE,N1,N2,IROW,ICOL)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER IR,IC,IMF,KL,KU,KLE,N1,N2,IROW,ICOL
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER NJ
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C  First check for errors on the definition of IMF
C
      IF ( IMF.NE.1 .AND. IMF.NE.2 .AND. IMF.NE.3 ) THEN
         PRINT *,' Subroutine MATIND '
         PRINT *,' IMF = ', IMF
         PRINT *,' Illegal value. Program aborted.'
         STOP
      ENDIF
C
C  Check that N1 is equal to (KLE + KL + KU + 1) for
C  the banded matrices.
C
      IF ( IMF.EQ.1 .OR. IMF.EQ.2 ) THEN
         NJ = KLE + KL + KU + 1
         IF ( N1.NE.NJ ) THEN
           PRINT *,' Subroutine MATIND '
           PRINT *,' KL  = ', KL 
           PRINT *,' KU  = ', KU 
           PRINT *,' KLE = ', KLE
           PRINT *,' N1  = ', N1 
           PRINT *,' Illegal value. Program aborted.'
           STOP
         ENDIF
      ENDIF
C
C  Do case IMF = 1. So this is a LAPACK format band matrix.
C
      IF ( IMF.EQ.1 ) THEN
         ICOL = IC
         IROW = KLE + KU + 1 + IR - IC
      ENDIF
C
C  Do case IMF = 2. So this is a DG format band matrix.
C
      IF ( IMF.EQ.2 ) THEN
         ICOL = IR
         IROW = KL + 1 + IC - IR
      ENDIF
C
C  Do case IMF = 3. So this is a square matrix.
C
      IF ( IMF.EQ.3 ) THEN
         ICOL = IC
         IROW = IR
      ENDIF
C
C  Final error check on IROW and ICOL
C
      IF ( IROW.LT.1 .OR. IROW.GT.N1 ) THEN
         PRINT *,' Subroutine MATIND '
         PRINT *,' IMF  = ',IMF
         PRINT *,' IROW = ', IROW
         PRINT *,' 1st. dimension = ', N1
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
      IF ( ICOL.LT.1 .OR. ICOL.GT.N2 ) THEN
         PRINT *,' Subroutine MATIND '
         PRINT *,' IMF  = ',IMF
         PRINT *,' ICOL = ', ICOL
         PRINT *,' 2nd. dimension = ', N2
         PRINT *,' Program aborted.'
         STOP
      ENDIF
C
C
      RETURN
      END
C*********************************************************************
C*********************************************************************
C subroutine POWer of TWO checker ************************************
C            ---      ---         ************************************
C Steve Gibbons 11.4.97        					     C
C____________________________________________________________________C
C Checks an integer INPUT and returns a .TRUE. logical variable POT  C
C if and only if INPUT is a power of 2.				     C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     INPUT	: Integer to be tested				     C
C____________________________________________________________________C
C Output :-                                                          C
C ======                                                             C
C  Logical 							     C
C  ------- 							     C
C     POT	: Power Of Two ? 				     C
C____________________________________________________________________C
C*********************************************************************
      SUBROUTINE POWTWO(INPUT,POT)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER INPUT
      LOGICAL POT
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER ITWO,N,IREM
      PARAMETER (ITWO=2)
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C First of all put N = INPUT so that INPUT won't be altered
      N=INPUT
C Then check that N is atleast equal to 2 - otherwise
C it is obviously not a power of 2.
      IF ( N.LT.2 ) THEN
         POT=.FALSE.
         RETURN
      ENDIF
C Begin our iteration ....
 500  CONTINUE
      IREM = MOD ( N , ITWO )
      IF ( IREM.NE.0 ) THEN
         POT=.FALSE.
         RETURN
      ENDIF
      IF ( N.EQ.2 ) THEN
         POT=.TRUE.
         RETURN
      ELSE
         N=N/2
         GOTO 500
      ENDIF
      END
C*********************************************************************
C*********************************************************************
C function PMM *******************************************************
C Steve Gibbons 16.4.97                                              C
C____________________________________________________________________C
C Gives the Schmidt Normalised Legendre Function P_m^m ( X )         C
C from eqn. 175 in my notes ie                                       C
C                                                                    C
C                   ( 2m - 1)!! (1- XX)^(m/2) * SQRT (2.0d0 )        C
C   P_m^m( X ) =  ---------------------------------------------      C
C                        SQRT ( (2m)! )                              C
C                                                                    C
C       for m non-zero and                                           C
C                                                                    C
C   P_0^0( X ) = 1.0d0                                               C
C                                                                    C
C N.B. The double factorial sign means the product of all ODD        C
C integers between 1 and ( 2m - 1 ).                                 C
C Best to use the form in eq 184 to calculate PMM.                   C
C____________________________________________________________________C
C Input Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     M         : Well it's M isn't it!                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     SINE      : Sin (theta)                                        C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION PMM ( M, S )
      IMPLICIT NONE
      DOUBLE PRECISION PMM
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER M
      DOUBLE PRECISION S
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I
      DOUBLE PRECISION TWOI
C____________________________________________________________________C
C START OF FUNCTION *************************************************C
C____________________________________________________________________C
C
      IF ( M.LT.0 ) THEN
         PRINT *,' Function PMM. M < 0 error. Stopped.'
         STOP
      ENDIF
      IF ( M.EQ.0 ) THEN
         PMM = 1.0d0
         RETURN
      ENDIF
C ................................. so M is greater than 0
      PMM = DSQRT ( 2.0d0 )
      DO I = 1, M
         TWOI = 2.0d0*DBLE(I)
         PMM = PMM * S * DSQRT ( (TWOI - 1.0d0 )/TWOI )
      ENDDO
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function PMM1 ******************************************************
C Steve Gibbons 16.4.97                                              C
C____________________________________________________________________C
C Evaluates the Schmidt Normalised Legendre Function P_(m+1)^m (X)   C
C according to equation 179 in my notes ; i.e.                       C
C                                                                    C
C    P_(m+1)^m (X) = SQRT( 2m+1 ).X.P^m_m(X)                         C
C                                                                    C
C____________________________________________________________________C
C Input Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     M         : Well it's M isn't it!                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     X         : Cos(theta)                                         C
C     PMM0      : P_m^m(X) as evaluated by Function PMM.             C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION PMM1 ( M, X, PMM0 )
      IMPLICIT NONE
      DOUBLE PRECISION PMM1
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER M
      DOUBLE PRECISION X, PMM0
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION RM
C____________________________________________________________________C
C START OF FUNCTION *************************************************C
C____________________________________________________________________C
C
      IF ( M.LT.0 ) THEN
         PRINT *,' Function PMM1. M < 0 error. Stopped.'
         STOP
      ENDIF
      RM = DBLE( M )
      PMM1 = X*PMM0*DSQRT( 2.0d0*RM+1.0d0 )
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function PLM *******************************************************
C Steve Gibbons 16.4.97                                              C
C____________________________________________________________________C
C Calculates the Schmidt Normalised Legendre Function P_l^m (x)      C
C given P_(l-1)^m and P_(l-2)^m according to equation 183 in my notesC
C i.e.                                                               C
C   P_l^m( X ) = { A * P_(l-1)^m - B * P_(l-2)^m }/C                 C
C                                                                    C
C where A = (2*l - 1)*X ,                                            C
C                                                                    C
C B = SQRT( (L+M-1)*(L-M-1) ) and C = SQRT( (L+M)*(L-M) )            C
C                                                                    C
C____________________________________________________________________C
C Input Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     M         : Well it's M isn't it!                              C
C     L         : Well it's L isn't it!                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     X         : Cos(theta)                                         C
C     PLMIN1    : P_(l-1)^m ( X )                                    C
C     PLMIN2    : P_(l-2)^m ( X )                                    C
C____________________________________________________________________C
C Local Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     RL        : DBLE  ( L )                                        C
C     RM        : DBLE  ( M )                                        C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION PLM ( L, M, X, PLMIN1, PLMIN2 )
      IMPLICIT NONE
      DOUBLE PRECISION PLM
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER M,L
      DOUBLE PRECISION X, PLMIN1, PLMIN2
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION RM,RL
C____________________________________________________________________C
C START OF FUNCTION *************************************************C
C____________________________________________________________________C
C
      IF ( L.LT.2 ) THEN
         PRINT *,' You are trying to run function PLM with L < 2.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
      IF ( M.LT.0 .OR. M.GT.L ) THEN
         PRINT *,' M is out of range in function PLM.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
      IF ( L.EQ.M ) THEN
         PRINT *,' PLM function called with L = M .'
         PRINT *,' Division by zero would follow.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
      RM = DBLE( M )
      RL = DBLE( L )
      PLM = ( 2.0d0*RL - 1.0d0 )*X*PLMIN1
      PLM = PLM - PLMIN2*DSQRT( ( RL+RM-1.0d0 )*( RL-RM-1.0d0 ) )
      PLM = PLM/DSQRT( (RL+RM)*(RL-RM) )
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function DPMM ******************************************************
C Steve Gibbons 16.4.97                                              C
C____________________________________________________________________C
C Calculates the derivative of P_m^m(theta) according to equation    C
C 185 in my notes i.e.                                               C
C                                                                    C
C d P_m^m(theta)/ d(theta) = sqrt(2.0)*M*cos(theta)/sin(theta) * A   C
C  with A = product_(i=1)^m ( SQRT( (2i-1)/2i ) * sin(theta) )       C
C____________________________________________________________________C
C Input Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     M         : Well it's M isn't it!                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     SINE      : Sin (theta)                                        C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION DPMM ( M , C , S )
      IMPLICIT NONE
      DOUBLE PRECISION DPMM
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER M
      DOUBLE PRECISION C, S
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER I
      DOUBLE PRECISION TWOI
C____________________________________________________________________C
C START OF FUNCTION *************************************************C
C____________________________________________________________________C
C
      IF ( M.LT.0 ) THEN
         PRINT *,' Function DPMM. M < 0 error. Stopped.'
         STOP
      ENDIF
      IF ( M.EQ.0 ) THEN
         DPMM = 0.0d0
         RETURN
      ENDIF
C ................................. so M is greater than 0
      DPMM = DSQRT ( 2.0d0 )*DBLE(M)*C/S
      DO I = 1, M
         TWOI = 2.0d0*DBLE(I)
         DPMM = DPMM * S * DSQRT ( (TWOI - 1.0d0 )/TWOI )
      ENDDO
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function DPMM1 *****************************************************
C Steve Gibbons 18.4.97                                              C
C____________________________________________________________________C
C Calculates d(P_(m+1)^m/d(theta) by equation 185 in my notes        C
C____________________________________________________________________C
C Input Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     M         : Well it's M isn't it!                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     X         : Cos(theta)                                         C
C     S         : Sin(theta)                                         C
C     PMM0      : P_m^m(X) as evaluated by Function PMM.             C
C     DPMM0     : d(P_m^m(X))/d(theta) as evaluated by Function DPMM C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION DPMM1 ( M, X, S, PMM0, DPMM0)
      IMPLICIT NONE
      DOUBLE PRECISION DPMM1
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER M
      DOUBLE PRECISION X, S, PMM0, DPMM0
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION RM
C____________________________________________________________________C
C START OF FUNCTION *************************************************C
C____________________________________________________________________C
C
      IF ( M.LT.0 ) THEN
         PRINT *,' Function DPMM1. M < 0 error. Stopped.'
         STOP
      ENDIF
      RM = DBLE( M )
      DPMM1 = DSQRT( 2.0d0*RM+1.0d0 )*( X*DPMM0 - S*PMM0 )
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function DPLM *******************************************************
C Steve Gibbons 18.4.97                                              C
C____________________________________________________________________C
C                                                                    C
C Calculates general P_l^m derivative from eqn 187 in my notes       C
C____________________________________________________________________C
C Input Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     M         : Well it's M isn't it!                              C
C     L         : Well it's L isn't it!                              C
C  Double Precision                                                  C
C  ----------------                                                  C
C     X         : Cos(theta)                                         C
C     S         : Sin(theta)                                         C
C     PLMIN1    : P_(l-1)^m ( X )                                    C
C     DPLMN1   : P_(l-1)^m ( X ) derivative                         C
C     DPLMN2   : P_(l-2)^m ( X ) derivative                         C
C____________________________________________________________________C
C Local Variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     RL        : DBLE  ( L )                                        C
C     RM        : DBLE  ( M )                                        C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION DPLM ( L, M, X, S, PLMIN1, DPLMN1, DPLMN2 )
      IMPLICIT NONE
      DOUBLE PRECISION DPLM
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER M,L
      DOUBLE PRECISION X, S, PLMIN1, DPLMN1, DPLMN2
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION RM,RL
C____________________________________________________________________C
C START OF FUNCTION *************************************************C
C____________________________________________________________________C
C
      IF ( L.LT.2 ) THEN
         PRINT *,' You are trying to run function DPLM with L < 2.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
      IF ( M.LT.0 .OR. M.GT.L ) THEN
         PRINT *,' M is out of range in function DPLM.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
      IF ( L.EQ.M ) THEN
         PRINT *,' DPLM function called with L = M .'
         PRINT *,' Division by zero would follow.'
         PRINT *,' Program aborted.'
         STOP
      ENDIF
      RM = DBLE( M )
      RL = DBLE( L )
      DPLM = ( 2.0d0*RL - 1.0d0 )*(X*DPLMN1-S*PLMIN1)
      DPLM = DPLM - DPLMN2*DSQRT( ( RL+RM-1.0d0 )*( RL-RM-1.0d0 ) )
      DPLM = DPLM/DSQRT( (RL+RM)*(RL-RM) )
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function Element of Matrix MULTiplication evaluate *****************
C          -          -      ----                    *****************
C Steve Gibbons Fri Oct 22 17:23:46 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Let the matrices B and C be respectively 'm by k' and 'k by n'     C
C double precision matrices. Then A = B C is an 'm by n' matrix      C
C with a_{ij} = \sum_{l=1,k} b_{il} c_{lj}                           C
C                                                                    C
C EMMULT returns the value of A( I, J)                               C
C____________________________________________________________________C
C                                                                    C
C Input variables :-                                                 C
C ===============                                                    C
C                                                                    C
C  Integer                                                           C
C  -------                                                           C
C     I         : Row containing desired element of A.               C
C     J         : Column containing desired element of A.            C
C     LDB       : Leading dimension of matrix B.                     C
C     LDC       : Leading dimension of matrix C.                     C
C     K         : Number of columns of matrix B and                  C
C                 Number of rows of matrix C.                        C
C                                                                    C
C  Double Precision                                                  C
C  ----------------                                                  C
C                                                                    C
C     B         : First matrix. Dim ( LDB, * )                       C
C     C         : First matrix. Dim ( LDC, * )                       C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION EMMULT( I, J, LDB, LDC, K, B, C )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER I, J, LDB, LDC, K
      DOUBLE PRECISION EMMULT, B( LDB, * ), C( LDB, * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER L
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
C First check the validity of the integer inputs.
C K must not exceed LDC
C I must not exceed LDB
C     .
      IF ( K.GT.LDC .OR. I.GT.LDB ) THEN
        PRINT *,' Function EMMULT.'
        PRINT *,' K    = ', K,' I    = ', I
        PRINT *,' LDB  = ', LDB,' LDC  = ', LDC
        PRINT *,' Program aborted.'
        STOP
      ENDIF
C     .
      EMMULT = 0.0d0
C     . 
      DO L = 1, K
        EMMULT = EMMULT + B( I, L )*C( L, J )
      ENDDO
C     .
      RETURN
      END
C*********************************************************************

C*********************************************************************
C function DL ********************************************************
C          -- ********************************************************
C Steve Gibbons 8.4.97						     C
C____________________________________________________________________C
C Spherical Harmonic Differential Operator Dl			     C
C 								     C
C Dl f = f'' + 2/r f' - l(l+1)/(rr).f				     C
C____________________________________________________________________C
C Input variables :-						     C
C ===============						     C
C  Double Precision						     C
C  ----------------						     C
C     R		: Radius					     C
C     F		: Value of function at r(i)			     C
C     DF	: Value of first derivative at r(i)		     C
C     DDF	: Value of second derivative at r(i)		     C
C  Integer						             C
C  -------						             C
C     L		: Spherical harmonic degree			     C
C____________________________________________________________________C
C Output :-						    	     C
C ======						  	     C
C  Double Precision						     C
C  ----------------						     C
C     DL	: as above					     C
C____________________________________________________________________C
C*********************************************************************
      FUNCTION DL(L,R,F,DF,DDF)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      DOUBLE PRECISION DL,R,F,DF,DDF
      INTEGER L
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION FACT,TOL
      PARAMETER (TOL=1.0d-10)
C Note that both of these working variables are confirmed to
C be explicitly set sjg 15.3.97 .
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C Avoid division by zero ....
      IF (ABS(R).LT.TOL) THEN
         WRITE (6,987)
         WRITE (6,988)
         WRITE (6,989)
 987     FORMAT ('Function DL has received too small a ')
 988     FORMAT ('value of R. This would result in a ')
 989     FORMAT ('division by zero error. Program aborted. ')
         STOP
      ENDIF
C
      FACT=DBLE(L*L+L)
      DL=DDF+2.0d0*DF/R-FACT*F/(R*R)
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function DLDL ******************************************************
C          ---- ******************************************************
C Steve Gibbons 10.4.97						     C
C____________________________________________________________________C
C Spherical Harmonic Differential Operator Dl^2			     C
C 								     C
C Dl f = f'' + 2/r f' - l(l+1)/(rr).f				     C
C  and so from eqn (74) we see					     C
C          d^4 f    4 d^3 f    2l(l+1) d^2 f    (l+2)(l+1)l(l-1) f   C
C Dl^2 f = -----  + - ----- -  ------- ----- +  ----------------     C
C           dr^4    r dr^3       r^2   dr^2          r^4             C
C____________________________________________________________________C
C Input variables :-						     C
C ===============						     C
C  Double Precision						     C
C  ----------------						     C
C     R		: Radius					     C
C     F		: Value of function at r(i)			     C
C     DDF	: Value of second derivative at r(i)		     C
C     DDDF	: Value of third derivative at r(i)		     C
C     DDDDF	: Value of fourth derivative at r(i)		     C
C  Integer						             C
C  -------						             C
C     L		: Spherical harmonic degree			     C
C____________________________________________________________________C
C Output :-						    	     C
C ======						  	     C
C  Double Precision						     C
C  ----------------						     C
C     DLDL	: as above					     C
C____________________________________________________________________C
C*********************************************************************
      FUNCTION DLDL(L,R,F,DDF,DDDF,DDDDF)
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      DOUBLE PRECISION DLDL,R,F,DDF,DDDF,DDDDF
      INTEGER L
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      DOUBLE PRECISION LFACT0,LFACT2,LFACT3,TOL,Q
      PARAMETER (TOL=1.0d-10)
C All local variables confirmed as being explicity set
C by program.
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C Avoid division by zero ....
      IF (ABS(R).LT.TOL) THEN
         WRITE (6,987)
         WRITE (6,988)
         WRITE (6,989)
 987     FORMAT ('Function DLDL has received too small a ')
 988     FORMAT ('value of R. This would result in a ')
 989     FORMAT ('division by zero error. Program aborted. ')
         STOP
      ENDIF
C
      Q = DBLE(L)
      LFACT0 = (Q+2.0d0)*(Q+1.0d0)*Q*(Q-1.0d0)/(R*R*R*R)
      LFACT2 = -2.0d0*Q*(Q+1.0d0)/(R*R)
      LFACT3 = 4.0d0/R
      DLDL = DDDDF+LFACT3*DDDF+LFACT2*DDF+LFACT0*F
      RETURN
      END
C*********************************************************************
C*********************************************************************
C function SQuare Root of L*(L+1) ************************************
C          --     -       -  - -  ************************************
C Steve Gibbons 25.4.97                                              C
C____________________________________________________________________C
C
      FUNCTION SQRLL1 ( L )
      IMPLICIT NONE
      DOUBLE PRECISION SQRLL1,Q
      INTEGER L
   
      IF ( L.LT.0 ) THEN
         PRINT *,' Function SQRLL1. L less than 0. Program aborted.'
         STOP
      ENDIF
      Q = DBLE( L )
      SQRLL1 = DSQRT( Q*Q + Q )
      RETURN
      END
C*********************************************************************
C*********************************************************************
C integer function INDex FUNction ************************************
C                  ---   ---      ************************************
C Steve Gibbons Thu Sep 16 11:13:38 BST 1999                         C
C____________________________________________________________________C
C                                                                    C
C Returns the location in the solution vector of the value of the    C
C IR^{th} grid node of the IH^{th} harmonic.                         C
C                                                                    C
C                                                                    C
C                                                                    C
C____________________________________________________________________C
C Input variables :-                                                 C
C ===============                                                    C
C  Integer                                                           C
C  -------                                                           C
C     IR        : Number of radial grid node.                        C
C     IH        : Number of harmonic.                                C
C     INARR     : Array of integers. Dimension ( * )                 C
C                 At present the elements of INARR are as follows.   C
C                                                                    C
C                 INARR( 1 ) = IFORMF. Format flag.                  C
C                  This flag decides how the elements are arranged   C
C                  in the solution vector.                           C
C                                                                    C
C                  The current options are:-                         C
C                                                                    C
C                   IFORMF = 1/3. INDFUN = ( IR - 1 )*NH + IH        C
C                   IFORMF = 2/4. INDFUN = ( IH - 1 )*NR + IR        C
C                                                                    C
C  Here, NH is the TOTAL number of harmonics in the solution         C
C  vector - or atleast the part of which is visible to that part     C
C  of the program. NR is the number of radial grid nodes             C
C  corresponding to that harmonic (which for cases IFORMF = 1 and    C
C  IFORMF = 2 is identical for all harmonics - more complicated      C
C  options (for example magnetic fields which have to be resolved    C
C  beyond the region of fluid flow) may be added later and this      C
C  routine should be flexible to all possibilities with extra        C
C  constraints being added in other elements of INARR.               C
C                                                                    C
C  IFORMF = 1/3 is the option likely to be used for the purpose of   C
C  solution as it allows the banded formation of a matrix.           C
C                                                                    C
C  IFORMF = 2/4 is the option likely to be used for the purpose of   C
C  displaying solutions as it stores adjacent nodes for each         C
C  harmonic together.                                                C
C                                                                    C
C                 INARR( 2 ) = NR. See above.                        C
C                 INARR( 3 ) = NH. See above.                        C
C                                                                    C
C____________________________________________________________________C
C
C*********************************************************************
      FUNCTION INDFUN ( IR, IH, INARR )
      IMPLICIT NONE
C____________________________________________________________________C
C Variable declarations - Parameters ................................C
      INTEGER INDFUN, IR, IH, INARR( * )
C____________________________________________________________________C
C Variable declarations - Working variables .........................C
      INTEGER IFORMF, NR, NH
C____________________________________________________________________C
C START OF PROGRAM **************************************************C
C____________________________________________________________________C
C
      IFORMF = INARR( 1 )
      NR     = INARR( 2 )
      NH     = INARR( 3 )
C
      IF ( IR.LT.1 .OR. IR.GT.NR ) THEN
        PRINT *,' Function INDFUN. IR = ', IR
        PRINT *,' NR = ', NR,'. Program aborted.'
        STOP
      ENDIF
C
      IF ( IH.LT.1 .OR. IH.GT.NH ) THEN
        PRINT *,' Function INDFUN. IH = ', IH
        PRINT *,' NH = ', NH,'. Program aborted.'
        STOP
      ENDIF
C
      IF ( IFORMF.EQ.1 .OR. IFORMF.EQ.3 ) THEN
        INDFUN = ( IR - 1 )*NH + IH
        RETURN
      ENDIF
C
      IF ( IFORMF.EQ.2 .OR. IFORMF.EQ.4 ) THEN
        INDFUN = ( IH - 1 )*NR + IR
        RETURN
      ENDIF
C
      PRINT *,' Function INDFUN. IFORMF = ', IFORMF
      PRINT *,' Not current option. Program aborted.'
      STOP
      END
C*********************************************************************
C*********************************************************************
C function INDex for Spherical Harmonic Coefficient ******************
C          ---       -         -        -           ******************
C Steve Gibbons 25.4.97                                              C
C____________________________________________________________________C
C Inputs are integers, L and M are obvious ICS = 1 for a cosine harm C
C and ICS = 2 for a sine harmonic.                                   C
C____________________________________________________________________C
      FUNCTION INDSHC ( L, M, ICS )
      IMPLICIT NONE
      INTEGER INDSHC, L, M, ICS
C 
      IF ( L.EQ.0 .AND. M.EQ.0 .AND. ICS.EQ.1 ) THEN
         INDSHC = 0
         RETURN
      ENDIF
C 
      IF ( L.LT.1 ) THEN
        PRINT *,' Function INDSHC. L = ', L
        STOP
      ENDIF
C 
      IF ( M.LT.0 .OR. M.GT.L ) THEN
         PRINT *,' Function INDSHC. M invalid. Program Aborted.'
         PRINT *,' L = ', L
         PRINT *,' M = ', M
         STOP
      ENDIF
      IF ( ICS.NE.1 .AND. ICS.NE.2 ) THEN
         PRINT *,' Function INDSHC. ICS = ', ICS
         PRINT *,' ICS must be 1 or 2.'
         PRINT *,' Program Aborted.'
         STOP
      ENDIF
      IF ( M.EQ.0 .AND. ICS.EQ.1 ) THEN
         INDSHC = L*L
         RETURN
      ENDIF
      IF ( M.EQ.0 .AND. ICS.NE.1 ) THEN
         PRINT *,' Function INDSHC. M = ', M
         PRINT *,' ICS = ', ICS,' Program aborted.'
         STOP
      ENDIF
      INDSHC = L*L + 2*M - 2 + ICS
C
      RETURN
      END
C*********************************************************************

      DOUBLE PRECISION FUNCTION DNRM2 ( N, X, INCX )
*     .. Scalar Arguments ..
      INTEGER                           INCX, N
*     .. Array Arguments ..
      DOUBLE PRECISION                  X( * )
*     ..
*
*  DNRM2 returns the euclidean norm of a vector via the function
*  name, so that
*
*     DNRM2 := sqrt( x'*x )
*
*
*
*  -- This version written on 25-October-1982.
*     Modified on 14-October-1993 to inline the call to DLASSQ.
*     Sven Hammarling, Nag Ltd.
*
*
*     .. Parameters ..
      DOUBLE PRECISION      ONE         , ZERO
      PARAMETER           ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
      INTEGER               IX
      DOUBLE PRECISION      ABSXI, NORM, SCALE, SSQ
*     .. Intrinsic Functions ..
      INTRINSIC             ABS, SQRT
*     ..
*     .. Executable Statements ..
      IF( N.LT.1 .OR. INCX.LT.1 )THEN
         NORM  = ZERO
      ELSE IF( N.EQ.1 )THEN
         NORM  = ABS( X( 1 ) )
      ELSE
         SCALE = ZERO
         SSQ   = ONE
*        The following loop is equivalent to this call to the LAPACK
*        auxiliary routine:
*        CALL DLASSQ( N, X, INCX, SCALE, SSQ )
*
         DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX
            IF( X( IX ).NE.ZERO )THEN
               ABSXI = ABS( X( IX ) )
               IF( SCALE.LT.ABSXI )THEN
                  SSQ   = ONE   + SSQ*( SCALE/ABSXI )**2
                  SCALE = ABSXI
               ELSE
                  SSQ   = SSQ   +     ( ABSXI/SCALE )**2
               END IF
            END IF
   10    CONTINUE
         NORM  = SCALE * SQRT( SSQ )
      END IF
*
      DNRM2 = NORM
      RETURN
*
*     End of DNRM2.
*
      END
      integer function idamax(n,dx,incx)
c
c     finds the index of element having max. absolute value.
c     jack dongarra, linpack, 3/11/78.
c     modified 3/93 to return if incx .le. 0.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dmax
      integer i,incx,ix,n
c
      idamax = 0
      if( n.lt.1 .or. incx.le.0 ) return
      idamax = 1
      if(n.eq.1)return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      ix = 1
      dmax = dabs(dx(1))
      ix = ix + incx
      do 10 i = 2,n
         if(dabs(dx(ix)).le.dmax) go to 5
         idamax = i
         dmax = dabs(dx(ix))
    5    ix = ix + incx
   10 continue
      return
c
c        code for increment equal to 1
c
   20 dmax = dabs(dx(1))
      do 30 i = 2,n
         if(dabs(dx(i)).le.dmax) go to 30
         idamax = i
         dmax = dabs(dx(i))
   30 continue
      return
      end
      SUBROUTINE DGEMM ( TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB,
     $                   BETA, C, LDC )
*     .. Scalar Arguments ..
      CHARACTER*1        TRANSA, TRANSB
      INTEGER            M, N, K, LDA, LDB, LDC
      DOUBLE PRECISION   ALPHA, BETA
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), C( LDC, * )
*     ..
*
*  Purpose
*  =======
*
*  DGEMM  performs one of the matrix-matrix operations
*
*     C := alpha*op( A )*op( B ) + beta*C,
*
*  where  op( X ) is one of
*
*     op( X ) = X   or   op( X ) = X',
*
*  alpha and beta are scalars, and A, B and C are matrices, with op( A )
*  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANSA - CHARACTER*1.
*           On entry, TRANSA specifies the form of op( A ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSA = 'N' or 'n',  op( A ) = A.
*
*              TRANSA = 'T' or 't',  op( A ) = A'.
*
*              TRANSA = 'C' or 'c',  op( A ) = A'.
*
*           Unchanged on exit.
*
*  TRANSB - CHARACTER*1.
*           On entry, TRANSB specifies the form of op( B ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSB = 'N' or 'n',  op( B ) = B.
*
*              TRANSB = 'T' or 't',  op( B ) = B'.
*
*              TRANSB = 'C' or 'c',  op( B ) = B'.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry,  M  specifies  the number  of rows  of the  matrix
*           op( A )  and of the  matrix  C.  M  must  be at least  zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry,  N  specifies the number  of columns of the matrix
*           op( B ) and the number of columns of the matrix C. N must be
*           at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry,  K  specifies  the number of columns of the matrix
*           op( A ) and the number of rows of the matrix op( B ). K must
*           be at least  zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
*           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
*           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
*           part of the array  A  must contain the matrix  A,  otherwise
*           the leading  k by m  part of the array  A  must contain  the
*           matrix A.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
*           LDA must be at least  max( 1, m ), otherwise  LDA must be at
*           least  max( 1, k ).
*           Unchanged on exit.
*
*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
*           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
*           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
*           part of the array  B  must contain the matrix  B,  otherwise
*           the leading  n by k  part of the array  B  must contain  the
*           matrix B.
*           Unchanged on exit.
*
*  LDB    - INTEGER.
*           On entry, LDB specifies the first dimension of B as declared
*           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
*           LDB must be at least  max( 1, k ), otherwise  LDB must be at
*           least  max( 1, n ).
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
*           supplied as zero then C need not be set on input.
*           Unchanged on exit.
*
*  C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
*           Before entry, the leading  m by n  part of the array  C must
*           contain the matrix  C,  except when  beta  is zero, in which
*           case C need not be set on entry.
*           On exit, the array  C  is overwritten by the  m by n  matrix
*           ( alpha*op( A )*op( B ) + beta*C ).
*
*  LDC    - INTEGER.
*           On entry, LDC specifies the first dimension of C as declared
*           in  the  calling  (sub)  program.   LDC  must  be  at  least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     .. Local Scalars ..
      LOGICAL            NOTA, NOTB
      INTEGER            I, INFO, J, L, NCOLA, NROWA, NROWB
      DOUBLE PRECISION   TEMP
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Executable Statements ..
*
*     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
*     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
*     and  columns of  A  and the  number of  rows  of  B  respectively.
*
      NOTA  = LSAME( TRANSA, 'N' )
      NOTB  = LSAME( TRANSB, 'N' )
      IF( NOTA )THEN
         NROWA = M
         NCOLA = K
      ELSE
         NROWA = K
         NCOLA = M
      END IF
      IF( NOTB )THEN
         NROWB = K
      ELSE
         NROWB = N
      END IF
*
*     Test the input parameters.
*
      INFO = 0
      IF(      ( .NOT.NOTA                 ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.NOTB                 ).AND.
     $         ( .NOT.LSAME( TRANSB, 'C' ) ).AND.
     $         ( .NOT.LSAME( TRANSB, 'T' ) )      )THEN
         INFO = 2
      ELSE IF( M  .LT.0               )THEN
         INFO = 3
      ELSE IF( N  .LT.0               )THEN
         INFO = 4
      ELSE IF( K  .LT.0               )THEN
         INFO = 5
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 8
      ELSE IF( LDB.LT.MAX( 1, NROWB ) )THEN
         INFO = 10
      ELSE IF( LDC.LT.MAX( 1, M     ) )THEN
         INFO = 13
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGEMM ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
     $    ( ( ( ALPHA.EQ.ZERO ).OR.( K.EQ.0 ) ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN
*
*     And if  alpha.eq.zero.
*
      IF( ALPHA.EQ.ZERO )THEN
         IF( BETA.EQ.ZERO )THEN
            DO 20, J = 1, N
               DO 10, I = 1, M
                  C( I, J ) = ZERO
   10          CONTINUE
   20       CONTINUE
         ELSE
            DO 40, J = 1, N
               DO 30, I = 1, M
                  C( I, J ) = BETA*C( I, J )
   30          CONTINUE
   40       CONTINUE
         END IF
         RETURN
      END IF
*
*     Start the operations.
*
      IF( NOTB )THEN
         IF( NOTA )THEN
*
*           Form  C := alpha*A*B + beta*C.
*
            DO 90, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 50, I = 1, M
                     C( I, J ) = ZERO
   50             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 60, I = 1, M
                     C( I, J ) = BETA*C( I, J )
   60             CONTINUE
               END IF
               DO 80, L = 1, K
                  IF( B( L, J ).NE.ZERO )THEN
                     TEMP = ALPHA*B( L, J )
                     DO 70, I = 1, M
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
   70                CONTINUE
                  END IF
   80          CONTINUE
   90       CONTINUE
         ELSE
*
*           Form  C := alpha*A'*B + beta*C
*
            DO 120, J = 1, N
               DO 110, I = 1, M
                  TEMP = ZERO
                  DO 100, L = 1, K
                     TEMP = TEMP + A( L, I )*B( L, J )
  100             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  110          CONTINUE
  120       CONTINUE
         END IF
      ELSE
         IF( NOTA )THEN
*
*           Form  C := alpha*A*B' + beta*C
*
            DO 170, J = 1, N
               IF( BETA.EQ.ZERO )THEN
                  DO 130, I = 1, M
                     C( I, J ) = ZERO
  130             CONTINUE
               ELSE IF( BETA.NE.ONE )THEN
                  DO 140, I = 1, M
                     C( I, J ) = BETA*C( I, J )
  140             CONTINUE
               END IF
               DO 160, L = 1, K
                  IF( B( J, L ).NE.ZERO )THEN
                     TEMP = ALPHA*B( J, L )
                     DO 150, I = 1, M
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )
  150                CONTINUE
                  END IF
  160          CONTINUE
  170       CONTINUE
         ELSE
*
*           Form  C := alpha*A'*B' + beta*C
*
            DO 200, J = 1, N
               DO 190, I = 1, M
                  TEMP = ZERO
                  DO 180, L = 1, K
                     TEMP = TEMP + A( L, I )*B( J, L )
  180             CONTINUE
                  IF( BETA.EQ.ZERO )THEN
                     C( I, J ) = ALPHA*TEMP
                  ELSE
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )
                  END IF
  190          CONTINUE
  200       CONTINUE
         END IF
      END IF
*
      RETURN
*
*     End of DGEMM .
*
      END
      SUBROUTINE DTRSM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA,
     $                   B, LDB )
*     .. Scalar Arguments ..
      CHARACTER*1        SIDE, UPLO, TRANSA, DIAG
      INTEGER            M, N, LDA, LDB
      DOUBLE PRECISION   ALPHA
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRSM  solves one of the matrix equations
*
*     op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
*
*  where alpha is a scalar, X and B are m by n matrices, A is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
*
*     op( A ) = A   or   op( A ) = A'.
*
*  The matrix X is overwritten on B.
*
*  Parameters
*  ==========
*
*  SIDE   - CHARACTER*1.
*           On entry, SIDE specifies whether op( A ) appears on the left
*           or right of X as follows:
*
*              SIDE = 'L' or 'l'   op( A )*X = alpha*B.
*
*              SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
*
*           Unchanged on exit.
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix A is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANSA - CHARACTER*1.
*           On entry, TRANSA specifies the form of op( A ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSA = 'N' or 'n'   op( A ) = A.
*
*              TRANSA = 'T' or 't'   op( A ) = A'.
*
*              TRANSA = 'C' or 'c'   op( A ) = A'.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit triangular
*           as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of B. M must be at
*           least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of B.  N must be
*           at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
*           zero then  A is not referenced and  B need not be set before
*           entry.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*           upper triangular part of the array  A must contain the upper
*           triangular matrix  and the strictly lower triangular part of
*           A is not referenced.
*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
*           lower triangular part of the array  A must contain the lower
*           triangular matrix  and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
*           A  are not referenced either,  but are assumed to be  unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*           then LDA must be at least max( 1, n ).
*           Unchanged on exit.
*
*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
*           Before entry,  the leading  m by n part of the array  B must
*           contain  the  right-hand  side  matrix  B,  and  on exit  is
*           overwritten by the solution matrix  X.
*
*  LDB    - INTEGER.
*           On entry, LDB specifies the first dimension of B as declared
*           in  the  calling  (sub)  program.   LDB  must  be  at  least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     .. Local Scalars ..
      LOGICAL            LSIDE, NOUNIT, UPPER
      INTEGER            I, INFO, J, K, NROWA
      DOUBLE PRECISION   TEMP
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      LSIDE  = LSAME( SIDE  , 'L' )
      IF( LSIDE )THEN
         NROWA = M
      ELSE
         NROWA = N
      END IF
      NOUNIT = LSAME( DIAG  , 'N' )
      UPPER  = LSAME( UPLO  , 'U' )
*
      INFO   = 0
      IF(      ( .NOT.LSIDE                ).AND.
     $         ( .NOT.LSAME( SIDE  , 'R' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.UPPER                ).AND.
     $         ( .NOT.LSAME( UPLO  , 'L' ) )      )THEN
         INFO = 2
      ELSE IF( ( .NOT.LSAME( TRANSA, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) )      )THEN
         INFO = 3
      ELSE IF( ( .NOT.LSAME( DIAG  , 'U' ) ).AND.
     $         ( .NOT.LSAME( DIAG  , 'N' ) )      )THEN
         INFO = 4
      ELSE IF( M  .LT.0               )THEN
         INFO = 5
      ELSE IF( N  .LT.0               )THEN
         INFO = 6
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 9
      ELSE IF( LDB.LT.MAX( 1, M     ) )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTRSM ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( N.EQ.0 )
     $   RETURN
*
*     And when  alpha.eq.zero.
*
      IF( ALPHA.EQ.ZERO )THEN
         DO 20, J = 1, N
            DO 10, I = 1, M
               B( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
         RETURN
      END IF
*
*     Start the operations.
*
      IF( LSIDE )THEN
         IF( LSAME( TRANSA, 'N' ) )THEN
*
*           Form  B := alpha*inv( A )*B.
*
            IF( UPPER )THEN
               DO 60, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 30, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
   30                CONTINUE
                  END IF
                  DO 50, K = M, 1, -1
                     IF( B( K, J ).NE.ZERO )THEN
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )/A( K, K )
                        DO 40, I = 1, K - 1
                           B( I, J ) = B( I, J ) - B( K, J )*A( I, K )
   40                   CONTINUE
                     END IF
   50             CONTINUE
   60          CONTINUE
            ELSE
               DO 100, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 70, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
   70                CONTINUE
                  END IF
                  DO 90 K = 1, M
                     IF( B( K, J ).NE.ZERO )THEN
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )/A( K, K )
                        DO 80, I = K + 1, M
                           B( I, J ) = B( I, J ) - B( K, J )*A( I, K )
   80                   CONTINUE
                     END IF
   90             CONTINUE
  100          CONTINUE
            END IF
         ELSE
*
*           Form  B := alpha*inv( A' )*B.
*
            IF( UPPER )THEN
               DO 130, J = 1, N
                  DO 120, I = 1, M
                     TEMP = ALPHA*B( I, J )
                     DO 110, K = 1, I - 1
                        TEMP = TEMP - A( K, I )*B( K, J )
  110                CONTINUE
                     IF( NOUNIT )
     $                  TEMP = TEMP/A( I, I )
                     B( I, J ) = TEMP
  120             CONTINUE
  130          CONTINUE
            ELSE
               DO 160, J = 1, N
                  DO 150, I = M, 1, -1
                     TEMP = ALPHA*B( I, J )
                     DO 140, K = I + 1, M
                        TEMP = TEMP - A( K, I )*B( K, J )
  140                CONTINUE
                     IF( NOUNIT )
     $                  TEMP = TEMP/A( I, I )
                     B( I, J ) = TEMP
  150             CONTINUE
  160          CONTINUE
            END IF
         END IF
      ELSE
         IF( LSAME( TRANSA, 'N' ) )THEN
*
*           Form  B := alpha*B*inv( A ).
*
            IF( UPPER )THEN
               DO 210, J = 1, N
                  IF( ALPHA.NE.ONE )THEN
                     DO 170, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
  170                CONTINUE
                  END IF
                  DO 190, K = 1, J - 1
                     IF( A( K, J ).NE.ZERO )THEN
                        DO 180, I = 1, M
                           B( I, J ) = B( I, J ) - A( K, J )*B( I, K )
  180                   CONTINUE
                     END IF
  190             CONTINUE
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( J, J )
                     DO 200, I = 1, M
                        B( I, J ) = TEMP*B( I, J )
  200                CONTINUE
                  END IF
  210          CONTINUE
            ELSE
               DO 260, J = N, 1, -1
                  IF( ALPHA.NE.ONE )THEN
                     DO 220, I = 1, M
                        B( I, J ) = ALPHA*B( I, J )
  220                CONTINUE
                  END IF
                  DO 240, K = J + 1, N
                     IF( A( K, J ).NE.ZERO )THEN
                        DO 230, I = 1, M
                           B( I, J ) = B( I, J ) - A( K, J )*B( I, K )
  230                   CONTINUE
                     END IF
  240             CONTINUE
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( J, J )
                     DO 250, I = 1, M
                       B( I, J ) = TEMP*B( I, J )
  250                CONTINUE
                  END IF
  260          CONTINUE
            END IF
         ELSE
*
*           Form  B := alpha*B*inv( A' ).
*
            IF( UPPER )THEN
               DO 310, K = N, 1, -1
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( K, K )
                     DO 270, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  270                CONTINUE
                  END IF
                  DO 290, J = 1, K - 1
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = A( J, K )
                        DO 280, I = 1, M
                           B( I, J ) = B( I, J ) - TEMP*B( I, K )
  280                   CONTINUE
                     END IF
  290             CONTINUE
                  IF( ALPHA.NE.ONE )THEN
                     DO 300, I = 1, M
                        B( I, K ) = ALPHA*B( I, K )
  300                CONTINUE
                  END IF
  310          CONTINUE
            ELSE
               DO 360, K = 1, N
                  IF( NOUNIT )THEN
                     TEMP = ONE/A( K, K )
                     DO 320, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  320                CONTINUE
                  END IF
                  DO 340, J = K + 1, N
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = A( J, K )
                        DO 330, I = 1, M
                           B( I, J ) = B( I, J ) - TEMP*B( I, K )
  330                   CONTINUE
                     END IF
  340             CONTINUE
                  IF( ALPHA.NE.ONE )THEN
                     DO 350, I = 1, M
                        B( I, K ) = ALPHA*B( I, K )
  350                CONTINUE
                  END IF
  360          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DTRSM .
*
      END
      SUBROUTINE DGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,
     $                   BETA, Y, INCY )
*     .. Scalar Arguments ..
      DOUBLE PRECISION   ALPHA, BETA
      INTEGER            INCX, INCY, LDA, M, N
      CHARACTER*1        TRANS
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DGEMV  performs one of the matrix-vector operations
*
*     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,
*
*  where alpha and beta are scalars, x and y are vectors and A is an
*  m by n matrix.
*
*  Parameters
*  ==========
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
*
*              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.
*
*              TRANS = 'C' or 'c'   y := alpha*A'*x + beta*y.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
*           Before entry, the incremented array X must contain the
*           vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  BETA   - DOUBLE PRECISION.
*           On entry, BETA specifies the scalar beta. When BETA is
*           supplied as zero then Y need not be set on input.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of DIMENSION at least
*           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
*           and at least
*           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
*           Before entry with BETA non-zero, the incremented array Y
*           must contain the vector y. On exit, Y is overwritten by the
*           updated vector y.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF     ( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 1
      ELSE IF( M.LT.0 )THEN
         INFO = 2
      ELSE IF( N.LT.0 )THEN
         INFO = 3
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
         INFO = 6
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 8
      ELSE IF( INCY.EQ.0 )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGEMV ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.
     $    ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )
     $   RETURN
*
*     Set  LENX  and  LENY, the lengths of the vectors x and y, and set
*     up the start points in  X  and  Y.
*
      IF( LSAME( TRANS, 'N' ) )THEN
         LENX = N
         LENY = M
      ELSE
         LENX = M
         LENY = N
      END IF
      IF( INCX.GT.0 )THEN
         KX = 1
      ELSE
         KX = 1 - ( LENX - 1 )*INCX
      END IF
      IF( INCY.GT.0 )THEN
         KY = 1
      ELSE
         KY = 1 - ( LENY - 1 )*INCY
      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
*     First form  y := beta*y.
*
      IF( BETA.NE.ONE )THEN
         IF( INCY.EQ.1 )THEN
            IF( BETA.EQ.ZERO )THEN
               DO 10, I = 1, LENY
                  Y( I ) = ZERO
   10          CONTINUE
            ELSE
               DO 20, I = 1, LENY
                  Y( I ) = BETA*Y( I )
   20          CONTINUE
            END IF
         ELSE
            IY = KY
            IF( BETA.EQ.ZERO )THEN
               DO 30, I = 1, LENY
                  Y( IY ) = ZERO
                  IY      = IY   + INCY
   30          CONTINUE
            ELSE
               DO 40, I = 1, LENY
                  Y( IY ) = BETA*Y( IY )
                  IY      = IY           + INCY
   40          CONTINUE
            END IF
         END IF
      END IF
      IF( ALPHA.EQ.ZERO )
     $   RETURN
      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  y := alpha*A*x + y.
*
         JX = KX
         IF( INCY.EQ.1 )THEN
            DO 60, J = 1, N
               IF( X( JX ).NE.ZERO )THEN
                  TEMP = ALPHA*X( JX )
                  DO 50, I = 1, M
                     Y( I ) = Y( I ) + TEMP*A( I, J )
   50             CONTINUE
               END IF
               JX = JX + INCX
   60       CONTINUE
         ELSE
            DO 80, J = 1, N
               IF( X( JX ).NE.ZERO )THEN
                  TEMP = ALPHA*X( JX )
                  IY   = KY
                  DO 70, I = 1, M
                     Y( IY ) = Y( IY ) + TEMP*A( I, J )
                     IY      = IY      + INCY
   70             CONTINUE
               END IF
               JX = JX + INCX
   80       CONTINUE
         END IF
      ELSE
*
*        Form  y := alpha*A'*x + y.
*
         JY = KY
         IF( INCX.EQ.1 )THEN
            DO 100, J = 1, N
               TEMP = ZERO
               DO 90, I = 1, M
                  TEMP = TEMP + A( I, J )*X( I )
   90          CONTINUE
               Y( JY ) = Y( JY ) + ALPHA*TEMP
               JY      = JY      + INCY
  100       CONTINUE
         ELSE
            DO 120, J = 1, N
               TEMP = ZERO
               IX   = KX
               DO 110, I = 1, M
                  TEMP = TEMP + A( I, J )*X( IX )
                  IX   = IX   + INCX
  110          CONTINUE
               Y( JY ) = Y( JY ) + ALPHA*TEMP
               JY      = JY      + INCY
  120       CONTINUE
         END IF
      END IF
*
      RETURN
*
*     End of DGEMV .
*
      END
      subroutine  dswap (n,dx,incx,dy,incy)
c
c     interchanges two vectors.
c     uses unrolled loops for increments equal one.
c     jack dongarra, linpack, 3/11/78.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dy(*),dtemp
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c       code for unequal increments or equal increments not equal
c         to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dtemp = dx(ix)
        dx(ix) = dy(iy)
        dy(iy) = dtemp
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c       code for both increments equal to 1
c
c
c       clean-up loop
c
   20 m = mod(n,3)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
   30 continue
      if( n .lt. 3 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,3
        dtemp = dx(i)
        dx(i) = dy(i)
        dy(i) = dtemp
        dtemp = dx(i + 1)
        dx(i + 1) = dy(i + 1)
        dy(i + 1) = dtemp
        dtemp = dx(i + 2)
        dx(i + 2) = dy(i + 2)
        dy(i + 2) = dtemp
   50 continue
      return
      end
      subroutine  dcopy(n,dx,incx,dy,incy)
c
c     copies a vector, x, to a vector, y.
c     uses unrolled loops for increments equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision dx(*),dy(*)
      integer i,incx,incy,ix,iy,m,mp1,n
c
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
c        code for unequal increments or equal increments
c          not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        dy(iy) = dx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
c        code for both increments equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,7)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dy(i) = dx(i)
   30 continue
      if( n .lt. 7 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,7
        dy(i) = dx(i)
        dy(i + 1) = dx(i + 1)
        dy(i + 2) = dx(i + 2)
        dy(i + 3) = dx(i + 3)
        dy(i + 4) = dx(i + 4)
        dy(i + 5) = dx(i + 5)
        dy(i + 6) = dx(i + 6)
   50 continue
      return
      end
      SUBROUTINE DGER  ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )
*     .. Scalar Arguments ..
      DOUBLE PRECISION   ALPHA
      INTEGER            INCX, INCY, LDA, M, N
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * ), Y( * )
*     ..
*
*  Purpose
*  =======
*
*  DGER   performs the rank 1 operation
*
*     A := alpha*x*y' + A,
*
*  where alpha is a scalar, x is an m element vector, y is an n element
*  vector and A is an m by n matrix.
*
*  Parameters
*  ==========
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of the matrix A.
*           M must be at least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry, ALPHA specifies the scalar alpha.
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( m - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the m
*           element vector x.
*           Unchanged on exit.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*  Y      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCY ) ).
*           Before entry, the incremented array Y must contain the n
*           element vector y.
*           Unchanged on exit.
*
*  INCY   - INTEGER.
*           On entry, INCY specifies the increment for the elements of
*           Y. INCY must not be zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry, the leading m by n part of the array A must
*           contain the matrix of coefficients. On exit, A is
*           overwritten by the updated matrix.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JY, KX
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF     ( M.LT.0 )THEN
         INFO = 1
      ELSE IF( N.LT.0 )THEN
         INFO = 2
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 5
      ELSE IF( INCY.EQ.0 )THEN
         INFO = 7
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN
         INFO = 9
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DGER  ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )
     $   RETURN
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
      IF( INCY.GT.0 )THEN
         JY = 1
      ELSE
         JY = 1 - ( N - 1 )*INCY
      END IF
      IF( INCX.EQ.1 )THEN
         DO 20, J = 1, N
            IF( Y( JY ).NE.ZERO )THEN
               TEMP = ALPHA*Y( JY )
               DO 10, I = 1, M
                  A( I, J ) = A( I, J ) + X( I )*TEMP
   10          CONTINUE
            END IF
            JY = JY + INCY
   20    CONTINUE
      ELSE
         IF( INCX.GT.0 )THEN
            KX = 1
         ELSE
            KX = 1 - ( M - 1 )*INCX
         END IF
         DO 40, J = 1, N
            IF( Y( JY ).NE.ZERO )THEN
               TEMP = ALPHA*Y( JY )
               IX   = KX
               DO 30, I = 1, M
                  A( I, J ) = A( I, J ) + X( IX )*TEMP
                  IX        = IX        + INCX
   30          CONTINUE
            END IF
            JY = JY + INCY
   40    CONTINUE
      END IF
*
      RETURN
*
*     End of DGER  .
*
      END
      subroutine  dscal(n,da,dx,incx)
c
c     scales a vector by a constant.
c     uses unrolled loops for increment equal to one.
c     jack dongarra, linpack, 3/11/78.
c     modified 3/93 to return if incx .le. 0.
c     modified 12/3/93, array(1) declarations changed to array(*)
c
      double precision da,dx(*)
      integer i,incx,m,mp1,n,nincx
c
      if( n.le.0 .or. incx.le.0 )return
      if(incx.eq.1)go to 20
c
c        code for increment not equal to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        dx(i) = da*dx(i)
   10 continue
      return
c
c        code for increment equal to 1
c
c
c        clean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        dx(i) = da*dx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        dx(i) = da*dx(i)
        dx(i + 1) = da*dx(i + 1)
        dx(i + 2) = da*dx(i + 2)
        dx(i + 3) = da*dx(i + 3)
        dx(i + 4) = da*dx(i + 4)
   50 continue
      return
      end
      SUBROUTINE DTBSV ( UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX )
*     .. Scalar Arguments ..
      INTEGER            INCX, K, LDA, N
      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTBSV  solves one of the systems of equations
*
*     A*x = b,   or   A'*x = b,
*
*  where b and x are n element vectors and A is an n by n unit, or
*  non-unit, upper or lower triangular band matrix, with ( k + 1 )
*  diagonals.
*
*  No test for singularity or near-singularity is included in this
*  routine. Such tests must be performed before calling this routine.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the equations to be solved as
*           follows:
*
*              TRANS = 'N' or 'n'   A*x = b.
*
*              TRANS = 'T' or 't'   A'*x = b.
*
*              TRANS = 'C' or 'c'   A'*x = b.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  K      - INTEGER.
*           On entry with UPLO = 'U' or 'u', K specifies the number of
*           super-diagonals of the matrix A.
*           On entry with UPLO = 'L' or 'l', K specifies the number of
*           sub-diagonals of the matrix A.
*           K must satisfy  0 .le. K.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
*           by n part of the array A must contain the upper triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row
*           ( k + 1 ) of the array, the first super-diagonal starting at
*           position 2 in row k, and so on. The top left k by k triangle
*           of the array A is not referenced.
*           The following program segment will transfer an upper
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = K + 1 - J
*                    DO 10, I = MAX( 1, J - K ), J
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
*           by n part of the array A must contain the lower triangular
*           band part of the matrix of coefficients, supplied column by
*           column, with the leading diagonal of the matrix in row 1 of
*           the array, the first sub-diagonal starting at position 1 in
*           row 2, and so on. The bottom right k by k triangle of the
*           array A is not referenced.
*           The following program segment will transfer a lower
*           triangular band matrix from conventional full matrix storage
*           to band storage:
*
*                 DO 20, J = 1, N
*                    M = 1 - J
*                    DO 10, I = J, MIN( N, J + K )
*                       A( M + I, J ) = matrix( I, J )
*              10    CONTINUE
*              20 CONTINUE
*
*           Note that when DIAG = 'U' or 'u' the elements of the array A
*           corresponding to the diagonal elements of the matrix are not
*           referenced, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           ( k + 1 ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element right-hand side vector b. On exit, X is overwritten
*           with the solution vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JX, KPLUS1, KX, L
      LOGICAL            NOUNIT
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
     $         .NOT.LSAME( UPLO , 'L' )      )THEN
         INFO = 1
      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 2
      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
     $         .NOT.LSAME( DIAG , 'N' )      )THEN
         INFO = 3
      ELSE IF( N.LT.0 )THEN
         INFO = 4
      ELSE IF( K.LT.0 )THEN
         INFO = 5
      ELSE IF( LDA.LT.( K + 1 ) )THEN
         INFO = 7
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 9
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTBSV ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( N.EQ.0 )
     $   RETURN
*
      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
      IF( INCX.LE.0 )THEN
         KX = 1 - ( N - 1 )*INCX
      ELSE IF( INCX.NE.1 )THEN
         KX = 1
      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed by sequentially with one pass through A.
*
      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := inv( A )*x.
*
         IF( LSAME( UPLO, 'U' ) )THEN
            KPLUS1 = K + 1
            IF( INCX.EQ.1 )THEN
               DO 20, J = N, 1, -1
                  IF( X( J ).NE.ZERO )THEN
                     L = KPLUS1 - J
                     IF( NOUNIT )
     $                  X( J ) = X( J )/A( KPLUS1, J )
                     TEMP = X( J )
                     DO 10, I = J - 1, MAX( 1, J - K ), -1
                        X( I ) = X( I ) - TEMP*A( L + I, J )
   10                CONTINUE
                  END IF
   20          CONTINUE
            ELSE
               KX = KX + ( N - 1 )*INCX
               JX = KX
               DO 40, J = N, 1, -1
                  KX = KX - INCX
                  IF( X( JX ).NE.ZERO )THEN
                     IX = KX
                     L  = KPLUS1 - J
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )/A( KPLUS1, J )
                     TEMP = X( JX )
                     DO 30, I = J - 1, MAX( 1, J - K ), -1
                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
                        IX      = IX      - INCX
   30                CONTINUE
                  END IF
                  JX = JX - INCX
   40          CONTINUE
            END IF
         ELSE
            IF( INCX.EQ.1 )THEN
               DO 60, J = 1, N
                  IF( X( J ).NE.ZERO )THEN
                     L = 1 - J
                     IF( NOUNIT )
     $                  X( J ) = X( J )/A( 1, J )
                     TEMP = X( J )
                     DO 50, I = J + 1, MIN( N, J + K )
                        X( I ) = X( I ) - TEMP*A( L + I, J )
   50                CONTINUE
                  END IF
   60          CONTINUE
            ELSE
               JX = KX
               DO 80, J = 1, N
                  KX = KX + INCX
                  IF( X( JX ).NE.ZERO )THEN
                     IX = KX
                     L  = 1  - J
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )/A( 1, J )
                     TEMP = X( JX )
                     DO 70, I = J + 1, MIN( N, J + K )
                        X( IX ) = X( IX ) - TEMP*A( L + I, J )
                        IX      = IX      + INCX
   70                CONTINUE
                  END IF
                  JX = JX + INCX
   80          CONTINUE
            END IF
         END IF
      ELSE
*
*        Form  x := inv( A')*x.
*
         IF( LSAME( UPLO, 'U' ) )THEN
            KPLUS1 = K + 1
            IF( INCX.EQ.1 )THEN
               DO 100, J = 1, N
                  TEMP = X( J )
                  L    = KPLUS1 - J
                  DO 90, I = MAX( 1, J - K ), J - 1
                     TEMP = TEMP - A( L + I, J )*X( I )
   90             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( KPLUS1, J )
                  X( J ) = TEMP
  100          CONTINUE
            ELSE
               JX = KX
               DO 120, J = 1, N
                  TEMP = X( JX )
                  IX   = KX
                  L    = KPLUS1  - J
                  DO 110, I = MAX( 1, J - K ), J - 1
                     TEMP = TEMP - A( L + I, J )*X( IX )
                     IX   = IX   + INCX
  110             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( KPLUS1, J )
                  X( JX ) = TEMP
                  JX      = JX   + INCX
                  IF( J.GT.K )
     $               KX = KX + INCX
  120          CONTINUE
            END IF
         ELSE
            IF( INCX.EQ.1 )THEN
               DO 140, J = N, 1, -1
                  TEMP = X( J )
                  L    = 1      - J
                  DO 130, I = MIN( N, J + K ), J + 1, -1
                     TEMP = TEMP - A( L + I, J )*X( I )
  130             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( 1, J )
                  X( J ) = TEMP
  140          CONTINUE
            ELSE
               KX = KX + ( N - 1 )*INCX
               JX = KX
               DO 160, J = N, 1, -1
                  TEMP = X( JX )
                  IX   = KX
                  L    = 1       - J
                  DO 150, I = MIN( N, J + K ), J + 1, -1
                     TEMP = TEMP - A( L + I, J )*X( IX )
                     IX   = IX   - INCX
  150             CONTINUE
                  IF( NOUNIT )
     $               TEMP = TEMP/A( 1, J )
                  X( JX ) = TEMP
                  JX      = JX   - INCX
                  IF( ( N - J ).GE.K )
     $               KX = KX - INCX
  160          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DTBSV .
*
      END
      SUBROUTINE DTRMM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA,
     $                   B, LDB )
*     .. Scalar Arguments ..
      CHARACTER*1        SIDE, UPLO, TRANSA, DIAG
      INTEGER            M, N, LDA, LDB
      DOUBLE PRECISION   ALPHA
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRMM  performs one of the matrix-matrix operations
*
*     B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
*
*  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
*  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
*
*     op( A ) = A   or   op( A ) = A'.
*
*  Parameters
*  ==========
*
*  SIDE   - CHARACTER*1.
*           On entry,  SIDE specifies whether  op( A ) multiplies B from
*           the left or right as follows:
*
*              SIDE = 'L' or 'l'   B := alpha*op( A )*B.
*
*              SIDE = 'R' or 'r'   B := alpha*B*op( A ).
*
*           Unchanged on exit.
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix A is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANSA - CHARACTER*1.
*           On entry, TRANSA specifies the form of op( A ) to be used in
*           the matrix multiplication as follows:
*
*              TRANSA = 'N' or 'n'   op( A ) = A.
*
*              TRANSA = 'T' or 't'   op( A ) = A'.
*
*              TRANSA = 'C' or 'c'   op( A ) = A'.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit triangular
*           as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  M      - INTEGER.
*           On entry, M specifies the number of rows of B. M must be at
*           least zero.
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the number of columns of B.  N must be
*           at least zero.
*           Unchanged on exit.
*
*  ALPHA  - DOUBLE PRECISION.
*           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
*           zero then  A is not referenced and  B need not be set before
*           entry.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
*           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
*           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
*           upper triangular part of the array  A must contain the upper
*           triangular matrix  and the strictly lower triangular part of
*           A is not referenced.
*           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
*           lower triangular part of the array  A must contain the lower
*           triangular matrix  and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
*           A  are not referenced either,  but are assumed to be  unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
*           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
*           then LDA must be at least max( 1, n ).
*           Unchanged on exit.
*
*  B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
*           Before entry,  the leading  m by n part of the array  B must
*           contain the matrix  B,  and  on exit  is overwritten  by the
*           transformed matrix.
*
*  LDB    - INTEGER.
*           On entry, LDB specifies the first dimension of B as declared
*           in  the  calling  (sub)  program.   LDB  must  be  at  least
*           max( 1, m ).
*           Unchanged on exit.
*
*
*  Level 3 Blas routine.
*
*  -- Written on 8-February-1989.
*     Jack Dongarra, Argonne National Laboratory.
*     Iain Duff, AERE Harwell.
*     Jeremy Du Croz, Numerical Algorithms Group Ltd.
*     Sven Hammarling, Numerical Algorithms Group Ltd.
*
*
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     .. Local Scalars ..
      LOGICAL            LSIDE, NOUNIT, UPPER
      INTEGER            I, INFO, J, K, NROWA
      DOUBLE PRECISION   TEMP
*     .. Parameters ..
      DOUBLE PRECISION   ONE         , ZERO
      PARAMETER        ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      LSIDE  = LSAME( SIDE  , 'L' )
      IF( LSIDE )THEN
         NROWA = M
      ELSE
         NROWA = N
      END IF
      NOUNIT = LSAME( DIAG  , 'N' )
      UPPER  = LSAME( UPLO  , 'U' )
*
      INFO   = 0
      IF(      ( .NOT.LSIDE                ).AND.
     $         ( .NOT.LSAME( SIDE  , 'R' ) )      )THEN
         INFO = 1
      ELSE IF( ( .NOT.UPPER                ).AND.
     $         ( .NOT.LSAME( UPLO  , 'L' ) )      )THEN
         INFO = 2
      ELSE IF( ( .NOT.LSAME( TRANSA, 'N' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'T' ) ).AND.
     $         ( .NOT.LSAME( TRANSA, 'C' ) )      )THEN
         INFO = 3
      ELSE IF( ( .NOT.LSAME( DIAG  , 'U' ) ).AND.
     $         ( .NOT.LSAME( DIAG  , 'N' ) )      )THEN
         INFO = 4
      ELSE IF( M  .LT.0               )THEN
         INFO = 5
      ELSE IF( N  .LT.0               )THEN
         INFO = 6
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN
         INFO = 9
      ELSE IF( LDB.LT.MAX( 1, M     ) )THEN
         INFO = 11
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTRMM ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( N.EQ.0 )
     $   RETURN
*
*     And when  alpha.eq.zero.
*
      IF( ALPHA.EQ.ZERO )THEN
         DO 20, J = 1, N
            DO 10, I = 1, M
               B( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
         RETURN
      END IF
*
*     Start the operations.
*
      IF( LSIDE )THEN
         IF( LSAME( TRANSA, 'N' ) )THEN
*
*           Form  B := alpha*A*B.
*
            IF( UPPER )THEN
               DO 50, J = 1, N
                  DO 40, K = 1, M
                     IF( B( K, J ).NE.ZERO )THEN
                        TEMP = ALPHA*B( K, J )
                        DO 30, I = 1, K - 1
                           B( I, J ) = B( I, J ) + TEMP*A( I, K )
   30                   CONTINUE
                        IF( NOUNIT )
     $                     TEMP = TEMP*A( K, K )
                        B( K, J ) = TEMP
                     END IF
   40             CONTINUE
   50          CONTINUE
            ELSE
               DO 80, J = 1, N
                  DO 70 K = M, 1, -1
                     IF( B( K, J ).NE.ZERO )THEN
                        TEMP      = ALPHA*B( K, J )
                        B( K, J ) = TEMP
                        IF( NOUNIT )
     $                     B( K, J ) = B( K, J )*A( K, K )
                        DO 60, I = K + 1, M
                           B( I, J ) = B( I, J ) + TEMP*A( I, K )
   60                   CONTINUE
                     END IF
   70             CONTINUE
   80          CONTINUE
            END IF
         ELSE
*
*           Form  B := alpha*B*A'.
*
            IF( UPPER )THEN
               DO 110, J = 1, N
                  DO 100, I = M, 1, -1
                     TEMP = B( I, J )
                     IF( NOUNIT )
     $                  TEMP = TEMP*A( I, I )
                     DO 90, K = 1, I - 1
                        TEMP = TEMP + A( K, I )*B( K, J )
   90                CONTINUE
                     B( I, J ) = ALPHA*TEMP
  100             CONTINUE
  110          CONTINUE
            ELSE
               DO 140, J = 1, N
                  DO 130, I = 1, M
                     TEMP = B( I, J )
                     IF( NOUNIT )
     $                  TEMP = TEMP*A( I, I )
                     DO 120, K = I + 1, M
                        TEMP = TEMP + A( K, I )*B( K, J )
  120                CONTINUE
                     B( I, J ) = ALPHA*TEMP
  130             CONTINUE
  140          CONTINUE
            END IF
         END IF
      ELSE
         IF( LSAME( TRANSA, 'N' ) )THEN
*
*           Form  B := alpha*B*A.
*
            IF( UPPER )THEN
               DO 180, J = N, 1, -1
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 150, I = 1, M
                     B( I, J ) = TEMP*B( I, J )
  150             CONTINUE
                  DO 170, K = 1, J - 1
                     IF( A( K, J ).NE.ZERO )THEN
                        TEMP = ALPHA*A( K, J )
                        DO 160, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  160                   CONTINUE
                     END IF
  170             CONTINUE
  180          CONTINUE
            ELSE
               DO 220, J = 1, N
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 190, I = 1, M
                     B( I, J ) = TEMP*B( I, J )
  190             CONTINUE
                  DO 210, K = J + 1, N
                     IF( A( K, J ).NE.ZERO )THEN
                        TEMP = ALPHA*A( K, J )
                        DO 200, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  200                   CONTINUE
                     END IF
  210             CONTINUE
  220          CONTINUE
            END IF
         ELSE
*
*           Form  B := alpha*B*A'.
*
            IF( UPPER )THEN
               DO 260, K = 1, N
                  DO 240, J = 1, K - 1
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = ALPHA*A( J, K )
                        DO 230, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  230                   CONTINUE
                     END IF
  240             CONTINUE
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( K, K )
                  IF( TEMP.NE.ONE )THEN
                     DO 250, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  250                CONTINUE
                  END IF
  260          CONTINUE
            ELSE
               DO 300, K = N, 1, -1
                  DO 280, J = K + 1, N
                     IF( A( J, K ).NE.ZERO )THEN
                        TEMP = ALPHA*A( J, K )
                        DO 270, I = 1, M
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )
  270                   CONTINUE
                     END IF
  280             CONTINUE
                  TEMP = ALPHA
                  IF( NOUNIT )
     $               TEMP = TEMP*A( K, K )
                  IF( TEMP.NE.ONE )THEN
                     DO 290, I = 1, M
                        B( I, K ) = TEMP*B( I, K )
  290                CONTINUE
                  END IF
  300          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DTRMM .
*
      END
      SUBROUTINE DTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )
*     .. Scalar Arguments ..
      INTEGER            INCX, LDA, N
      CHARACTER*1        DIAG, TRANS, UPLO
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * ), X( * )
*     ..
*
*  Purpose
*  =======
*
*  DTRMV  performs one of the matrix-vector operations
*
*     x := A*x,   or   x := A'*x,
*
*  where x is an n element vector and  A is an n by n unit, or non-unit,
*  upper or lower triangular matrix.
*
*  Parameters
*  ==========
*
*  UPLO   - CHARACTER*1.
*           On entry, UPLO specifies whether the matrix is an upper or
*           lower triangular matrix as follows:
*
*              UPLO = 'U' or 'u'   A is an upper triangular matrix.
*
*              UPLO = 'L' or 'l'   A is a lower triangular matrix.
*
*           Unchanged on exit.
*
*  TRANS  - CHARACTER*1.
*           On entry, TRANS specifies the operation to be performed as
*           follows:
*
*              TRANS = 'N' or 'n'   x := A*x.
*
*              TRANS = 'T' or 't'   x := A'*x.
*
*              TRANS = 'C' or 'c'   x := A'*x.
*
*           Unchanged on exit.
*
*  DIAG   - CHARACTER*1.
*           On entry, DIAG specifies whether or not A is unit
*           triangular as follows:
*
*              DIAG = 'U' or 'u'   A is assumed to be unit triangular.
*
*              DIAG = 'N' or 'n'   A is not assumed to be unit
*                                  triangular.
*
*           Unchanged on exit.
*
*  N      - INTEGER.
*           On entry, N specifies the order of the matrix A.
*           N must be at least zero.
*           Unchanged on exit.
*
*  A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
*           Before entry with  UPLO = 'U' or 'u', the leading n by n
*           upper triangular part of the array A must contain the upper
*           triangular matrix and the strictly lower triangular part of
*           A is not referenced.
*           Before entry with UPLO = 'L' or 'l', the leading n by n
*           lower triangular part of the array A must contain the lower
*           triangular matrix and the strictly upper triangular part of
*           A is not referenced.
*           Note that when  DIAG = 'U' or 'u', the diagonal elements of
*           A are not referenced either, but are assumed to be unity.
*           Unchanged on exit.
*
*  LDA    - INTEGER.
*           On entry, LDA specifies the first dimension of A as declared
*           in the calling (sub) program. LDA must be at least
*           max( 1, n ).
*           Unchanged on exit.
*
*  X      - DOUBLE PRECISION array of dimension at least
*           ( 1 + ( n - 1 )*abs( INCX ) ).
*           Before entry, the incremented array X must contain the n
*           element vector x. On exit, X is overwritten with the
*           tranformed vector x.
*
*  INCX   - INTEGER.
*           On entry, INCX specifies the increment for the elements of
*           X. INCX must not be zero.
*           Unchanged on exit.
*
*
*  Level 2 Blas routine.
*
*  -- Written on 22-October-1986.
*     Jack Dongarra, Argonne National Lab.
*     Jeremy Du Croz, Nag Central Office.
*     Sven Hammarling, Nag Central Office.
*     Richard Hanson, Sandia National Labs.
*
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO
      PARAMETER        ( ZERO = 0.0D+0 )
*     .. Local Scalars ..
      DOUBLE PRECISION   TEMP
      INTEGER            I, INFO, IX, J, JX, KX
      LOGICAL            NOUNIT
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     .. External Subroutines ..
      EXTERNAL           XERBLA
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF     ( .NOT.LSAME( UPLO , 'U' ).AND.
     $         .NOT.LSAME( UPLO , 'L' )      )THEN
         INFO = 1
      ELSE IF( .NOT.LSAME( TRANS, 'N' ).AND.
     $         .NOT.LSAME( TRANS, 'T' ).AND.
     $         .NOT.LSAME( TRANS, 'C' )      )THEN
         INFO = 2
      ELSE IF( .NOT.LSAME( DIAG , 'U' ).AND.
     $         .NOT.LSAME( DIAG , 'N' )      )THEN
         INFO = 3
      ELSE IF( N.LT.0 )THEN
         INFO = 4
      ELSE IF( LDA.LT.MAX( 1, N ) )THEN
         INFO = 6
      ELSE IF( INCX.EQ.0 )THEN
         INFO = 8
      END IF
      IF( INFO.NE.0 )THEN
         CALL XERBLA( 'DTRMV ', INFO )
         RETURN
      END IF
*
*     Quick return if possible.
*
      IF( N.EQ.0 )
     $   RETURN
*
      NOUNIT = LSAME( DIAG, 'N' )
*
*     Set up the start point in X if the increment is not unity. This
*     will be  ( N - 1 )*INCX  too small for descending loops.
*
      IF( INCX.LE.0 )THEN
         KX = 1 - ( N - 1 )*INCX
      ELSE IF( INCX.NE.1 )THEN
         KX = 1
      END IF
*
*     Start the operations. In this version the elements of A are
*     accessed sequentially with one pass through A.
*
      IF( LSAME( TRANS, 'N' ) )THEN
*
*        Form  x := A*x.
*
         IF( LSAME( UPLO, 'U' ) )THEN
            IF( INCX.EQ.1 )THEN
               DO 20, J = 1, N
                  IF( X( J ).NE.ZERO )THEN
                     TEMP = X( J )
                     DO 10, I = 1, J - 1
                        X( I ) = X( I ) + TEMP*A( I, J )
   10                CONTINUE
                     IF( NOUNIT )
     $                  X( J ) = X( J )*A( J, J )
                  END IF
   20          CONTINUE
            ELSE
               JX = KX
               DO 40, J = 1, N
                  IF( X( JX ).NE.ZERO )THEN
                     TEMP = X( JX )
                     IX   = KX
                     DO 30, I = 1, J - 1
                        X( IX ) = X( IX ) + TEMP*A( I, J )
                        IX      = IX      + INCX
   30                CONTINUE
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )*A( J, J )
                  END IF
                  JX = JX + INCX
   40          CONTINUE
            END IF
         ELSE
            IF( INCX.EQ.1 )THEN
               DO 60, J = N, 1, -1
                  IF( X( J ).NE.ZERO )THEN
                     TEMP = X( J )
                     DO 50, I = N, J + 1, -1
                        X( I ) = X( I ) + TEMP*A( I, J )
   50                CONTINUE
                     IF( NOUNIT )
     $                  X( J ) = X( J )*A( J, J )
                  END IF
   60          CONTINUE
            ELSE
               KX = KX + ( N - 1 )*INCX
               JX = KX
               DO 80, J = N, 1, -1
                  IF( X( JX ).NE.ZERO )THEN
                     TEMP = X( JX )
                     IX   = KX
                     DO 70, I = N, J + 1, -1
                        X( IX ) = X( IX ) + TEMP*A( I, J )
                        IX      = IX      - INCX
   70                CONTINUE
                     IF( NOUNIT )
     $                  X( JX ) = X( JX )*A( J, J )
                  END IF
                  JX = JX - INCX
   80          CONTINUE
            END IF
         END IF
      ELSE
*
*        Form  x := A'*x.
*
         IF( LSAME( UPLO, 'U' ) )THEN
            IF( INCX.EQ.1 )THEN
               DO 100, J = N, 1, -1
                  TEMP = X( J )
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 90, I = J - 1, 1, -1
                     TEMP = TEMP + A( I, J )*X( I )
   90             CONTINUE
                  X( J ) = TEMP
  100          CONTINUE
            ELSE
               JX = KX + ( N - 1 )*INCX
               DO 120, J = N, 1, -1
                  TEMP = X( JX )
                  IX   = JX
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 110, I = J - 1, 1, -1
                     IX   = IX   - INCX
                     TEMP = TEMP + A( I, J )*X( IX )
  110             CONTINUE
                  X( JX ) = TEMP
                  JX      = JX   - INCX
  120          CONTINUE
            END IF
         ELSE
            IF( INCX.EQ.1 )THEN
               DO 140, J = 1, N
                  TEMP = X( J )
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 130, I = J + 1, N
                     TEMP = TEMP + A( I, J )*X( I )
  130             CONTINUE
                  X( J ) = TEMP
  140          CONTINUE
            ELSE
               JX = KX
               DO 160, J = 1, N
                  TEMP = X( JX )
                  IX   = JX
                  IF( NOUNIT )
     $               TEMP = TEMP*A( J, J )
                  DO 150, I = J + 1, N
                     IX   = IX   + INCX
                     TEMP = TEMP + A( I, J )*X( IX )
  150             CONTINUE
                  X( JX ) = TEMP
                  JX      = JX   + INCX
  160          CONTINUE
            END IF
         END IF
      END IF
*
      RETURN
*
*     End of DTRMV .
*
      END
      SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DGETRF computes an LU factorization of a general M-by-N matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  This is the right-looking Level 3 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the M-by-N matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
*                has been completed, but the factor U is exactly
*                singular, and division by zero will occur if it is used
*                to solve a system of equations.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, IINFO, J, JB, NB
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMM, DGETF2, DLASWP, DTRSM, XERBLA
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETRF', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DGETRF', ' ', M, N, -1, -1 )
      IF( NB.LE.1 .OR. NB.GE.MIN( M, N ) ) THEN
*
*        Use unblocked code.
*
         CALL DGETF2( M, N, A, LDA, IPIV, INFO )
      ELSE
*
*        Use blocked code.
*
         DO 20 J = 1, MIN( M, N ), NB
            JB = MIN( MIN( M, N )-J+1, NB )
*
*           Factor diagonal and subdiagonal blocks and test for exact
*           singularity.
*
            CALL DGETF2( M-J+1, JB, A( J, J ), LDA, IPIV( J ), IINFO )
*
*           Adjust INFO and the pivot indices.
*
            IF( INFO.EQ.0 .AND. IINFO.GT.0 )
     $         INFO = IINFO + J - 1
            DO 10 I = J, MIN( M, J+JB-1 )
               IPIV( I ) = J - 1 + IPIV( I )
   10       CONTINUE
*
*           Apply interchanges to columns 1:J-1.
*
            CALL DLASWP( J-1, A, LDA, J, J+JB-1, IPIV, 1 )
*
            IF( J+JB.LE.N ) THEN
*
*              Apply interchanges to columns J+JB:N.
*
               CALL DLASWP( N-J-JB+1, A( 1, J+JB ), LDA, J, J+JB-1,
     $                      IPIV, 1 )
*
*              Compute block row of U.
*
               CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit', JB,
     $                     N-J-JB+1, ONE, A( J, J ), LDA, A( J, J+JB ),
     $                     LDA )
               IF( J+JB.LE.M ) THEN
*
*                 Update trailing submatrix.
*
                  CALL DGEMM( 'No transpose', 'No transpose', M-J-JB+1,
     $                        N-J-JB+1, JB, -ONE, A( J+JB, J ), LDA,
     $                        A( J, J+JB ), LDA, ONE, A( J+JB, J+JB ),
     $                        LDA )
               END IF
            END IF
   20    CONTINUE
      END IF
      RETURN
*
*     End of DGETRF
*
      END
      SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, LWORK, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * ), WORK( LWORK )
*     ..
*
*  Purpose
*  =======
*
*  DGETRI computes the inverse of a matrix using the LU factorization
*  computed by DGETRF.
*
*  This method inverts U and then computes inv(A) by solving the system
*  inv(A)*L = inv(U) for inv(A).
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the factors L and U from the factorization
*          A = P*L*U as computed by DGETRF.
*          On exit, if INFO = 0, the inverse of the original matrix A.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  IPIV    (input) INTEGER array, dimension (N)
*          The pivot indices from DGETRF; for 1<=i<=N, row i of the
*          matrix was interchanged with row IPIV(i).
*
*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
*          On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
*
*  LWORK   (input) INTEGER
*          The dimension of the array WORK.  LWORK >= max(1,N).
*          For optimal performance LWORK >= N*NB, where NB is
*          the optimal blocksize returned by ILAENV.
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0:  if INFO = -i, the i-th argument had an illegal value
*          > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
*                singular and its inverse could not be computed.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, IWS, J, JB, JJ, JP, LDWORK, NB, NBMIN, NN
*     ..
*     .. External Functions ..
      INTEGER            ILAENV
      EXTERNAL           ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMM, DGEMV, DSWAP, DTRSM, DTRTRI, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      WORK( 1 ) = MAX( N, 1 )
      IF( N.LT.0 ) THEN
         INFO = -1
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -3
      ELSE IF( LWORK.LT.MAX( 1, N ) ) THEN
         INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETRI', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
*     Form inv(U).  If INFO > 0 from DTRTRI, then U is singular,
*     and the inverse is not computed.
*
      CALL DTRTRI( 'Upper', 'Non-unit', N, A, LDA, INFO )
      IF( INFO.GT.0 )
     $   RETURN
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DGETRI', ' ', N, -1, -1, -1 )
      NBMIN = 2
      LDWORK = N
      IF( NB.GT.1 .AND. NB.LT.N ) THEN
         IWS = MAX( LDWORK*NB, 1 )
         IF( LWORK.LT.IWS ) THEN
            NB = LWORK / LDWORK
            NBMIN = MAX( 2, ILAENV( 2, 'DGETRI', ' ', N, -1, -1, -1 ) )
         END IF
      ELSE
         IWS = N
      END IF
*
*     Solve the equation inv(A)*L = inv(U) for inv(A).
*
      IF( NB.LT.NBMIN .OR. NB.GE.N ) THEN
*
*        Use unblocked code.
*
         DO 20 J = N, 1, -1
*
*           Copy current column of L to WORK and replace with zeros.
*
            DO 10 I = J + 1, N
               WORK( I ) = A( I, J )
               A( I, J ) = ZERO
   10       CONTINUE
*
*           Compute current column of inv(A).
*
            IF( J.LT.N )
     $         CALL DGEMV( 'No transpose', N, N-J, -ONE, A( 1, J+1 ),
     $                     LDA, WORK( J+1 ), 1, ONE, A( 1, J ), 1 )
   20    CONTINUE
      ELSE
*
*        Use blocked code.
*
         NN = ( ( N-1 ) / NB )*NB + 1
         DO 50 J = NN, 1, -NB
            JB = MIN( NB, N-J+1 )
*
*           Copy current block column of L to WORK and replace with
*           zeros.
*
            DO 40 JJ = J, J + JB - 1
               DO 30 I = JJ + 1, N
                  WORK( I+( JJ-J )*LDWORK ) = A( I, JJ )
                  A( I, JJ ) = ZERO
   30          CONTINUE
   40       CONTINUE
*
*           Compute current block column of inv(A).
*
            IF( J+JB.LE.N )
     $         CALL DGEMM( 'No transpose', 'No transpose', N, JB,
     $                     N-J-JB+1, -ONE, A( 1, J+JB ), LDA,
     $                     WORK( J+JB ), LDWORK, ONE, A( 1, J ), LDA )
            CALL DTRSM( 'Right', 'Lower', 'No transpose', 'Unit', N, JB,
     $                  ONE, WORK( J ), LDWORK, A( 1, J ), LDA )
   50    CONTINUE
      END IF
*
*     Apply column interchanges.
*
      DO 60 J = N - 1, 1, -1
         JP = IPIV( J )
         IF( JP.NE.J )
     $      CALL DSWAP( N, A( 1, J ), 1, A( 1, JP ), 1 )
   60 CONTINUE
*
      WORK( 1 ) = IWS
      RETURN
*
*     End of DGETRI
*
      END
      SUBROUTINE DGBTRF( M, N, KL, KU, AB, LDAB, IPIV, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INFO, KL, KU, LDAB, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   AB( LDAB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGBTRF computes an LU factorization of a real m-by-n band matrix A
*  using partial pivoting with row interchanges.
*
*  This is the blocked version of the algorithm, calling Level 3 BLAS.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  KL      (input) INTEGER
*          The number of subdiagonals within the band of A.  KL >= 0.
*
*  KU      (input) INTEGER
*          The number of superdiagonals within the band of A.  KU >= 0.
*
*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
*          On entry, the matrix A in band storage, in rows KL+1 to
*          2*KL+KU+1; rows 1 to KL of the array need not be set.
*          The j-th column of A is stored in the j-th column of the
*          array AB as follows:
*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
*
*          On exit, details of the factorization: U is stored as an
*          upper triangular band matrix with KL+KU superdiagonals in
*          rows 1 to KL+KU+1, and the multipliers used during the
*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
*          See below for further details.
*
*  LDAB    (input) INTEGER
*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  Further Details
*  ===============
*
*  The band storage scheme is illustrated by the following example, when
*  M = N = 6, KL = 2, KU = 1:
*
*  On entry:                       On exit:
*
*      *    *    *    +    +    +       *    *    *   u14  u25  u36
*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
*
*  Array elements marked * are not used by the routine; elements marked
*  + need not be set on entry, but are required by the routine to store
*  elements of U because of fill-in resulting from the row interchanges.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
      INTEGER            NBMAX, LDWORK
      PARAMETER          ( NBMAX = 64, LDWORK = NBMAX+1 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, I2, I3, II, IP, J, J2, J3, JB, JJ, JM, JP,
     $                   JU, K2, KM, KV, NB, NW
      DOUBLE PRECISION   TEMP
*     ..
*     .. Local Arrays ..
      DOUBLE PRECISION   WORK13( LDWORK, NBMAX ),
     $                   WORK31( LDWORK, NBMAX )
*     ..
*     .. External Functions ..
      INTEGER            IDAMAX, ILAENV
      EXTERNAL           IDAMAX, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DCOPY, DGBTF2, DGEMM, DGER, DLASWP, DSCAL,
     $                   DSWAP, DTRSM, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     KV is the number of superdiagonals in the factor U, allowing for
*     fill-in
*
      KV = KU + KL
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( KL.LT.0 ) THEN
         INFO = -3
      ELSE IF( KU.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDAB.LT.KL+KV+1 ) THEN
         INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGBTRF', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Determine the block size for this environment
*
      NB = ILAENV( 1, 'DGBTRF', ' ', M, N, KL, KU )
*
*     The block size must not exceed the limit set by the size of the
*     local arrays WORK13 and WORK31.
*
      NB = MIN( NB, NBMAX )
*
      IF( NB.LE.1 .OR. NB.GT.KL ) THEN
*
*        Use unblocked code
*
         CALL DGBTF2( M, N, KL, KU, AB, LDAB, IPIV, INFO )
      ELSE
*
*        Use blocked code
*
*        Zero the superdiagonal elements of the work array WORK13
*
         DO 20 J = 1, NB
            DO 10 I = 1, J - 1
               WORK13( I, J ) = ZERO
   10       CONTINUE
   20    CONTINUE
*
*        Zero the subdiagonal elements of the work array WORK31
*
         DO 40 J = 1, NB
            DO 30 I = J + 1, NB
               WORK31( I, J ) = ZERO
   30       CONTINUE
   40    CONTINUE
*
*        Gaussian elimination with partial pivoting
*
*        Set fill-in elements in columns KU+2 to KV to zero
*
         DO 60 J = KU + 2, MIN( KV, N )
            DO 50 I = KV - J + 2, KL
               AB( I, J ) = ZERO
   50       CONTINUE
   60    CONTINUE
*
*        JU is the index of the last column affected by the current
*        stage of the factorization
*
         JU = 1
*
         DO 180 J = 1, MIN( M, N ), NB
            JB = MIN( NB, MIN( M, N )-J+1 )
*
*           The active part of the matrix is partitioned
*
*              A11   A12   A13
*              A21   A22   A23
*              A31   A32   A33
*
*           Here A11, A21 and A31 denote the current block of JB columns
*           which is about to be factorized. The number of rows in the
*           partitioning are JB, I2, I3 respectively, and the numbers
*           of columns are JB, J2, J3. The superdiagonal elements of A13
*           and the subdiagonal elements of A31 lie outside the band.
*
            I2 = MIN( KL-JB, M-J-JB+1 )
            I3 = MIN( JB, M-J-KL+1 )
*
*           J2 and J3 are computed after JU has been updated.
*
*           Factorize the current block of JB columns
*
            DO 80 JJ = J, J + JB - 1
*
*              Set fill-in elements in column JJ+KV to zero
*
               IF( JJ+KV.LE.N ) THEN
                  DO 70 I = 1, KL
                     AB( I, JJ+KV ) = ZERO
   70             CONTINUE
               END IF
*
*              Find pivot and test for singularity. KM is the number of
*              subdiagonal elements in the current column.
*
               KM = MIN( KL, M-JJ )
               JP = IDAMAX( KM+1, AB( KV+1, JJ ), 1 )
               IPIV( JJ ) = JP + JJ - J
               IF( AB( KV+JP, JJ ).NE.ZERO ) THEN
                  JU = MAX( JU, MIN( JJ+KU+JP-1, N ) )
                  IF( JP.NE.1 ) THEN
*
*                    Apply interchange to columns J to J+JB-1
*
                     IF( JP+JJ-1.LT.J+KL ) THEN
*
                        CALL DSWAP( JB, AB( KV+1+JJ-J, J ), LDAB-1,
     $                              AB( KV+JP+JJ-J, J ), LDAB-1 )
                     ELSE
*
*                       The interchange affects columns J to JJ-1 of A31
*                       which are stored in the work array WORK31
*
                        CALL DSWAP( JJ-J, AB( KV+1+JJ-J, J ), LDAB-1,
     $                              WORK31( JP+JJ-J-KL, 1 ), LDWORK )
                        CALL DSWAP( J+JB-JJ, AB( KV+1, JJ ), LDAB-1,
     $                              AB( KV+JP, JJ ), LDAB-1 )
                     END IF
                  END IF
*
*                 Compute multipliers
*
                  CALL DSCAL( KM, ONE / AB( KV+1, JJ ), AB( KV+2, JJ ),
     $                        1 )
*
*                 Update trailing submatrix within the band and within
*                 the current block. JM is the index of the last column
*                 which needs to be updated.
*
                  JM = MIN( JU, J+JB-1 )
                  IF( JM.GT.JJ )
     $               CALL DGER( KM, JM-JJ, -ONE, AB( KV+2, JJ ), 1,
     $                          AB( KV, JJ+1 ), LDAB-1,
     $                          AB( KV+1, JJ+1 ), LDAB-1 )
               ELSE
*
*                 If pivot is zero, set INFO to the index of the pivot
*                 unless a zero pivot has already been found.
*
                  IF( INFO.EQ.0 )
     $               INFO = JJ
               END IF
*
*              Copy current column of A31 into the work array WORK31
*
               NW = MIN( JJ-J+1, I3 )
               IF( NW.GT.0 )
     $            CALL DCOPY( NW, AB( KV+KL+1-JJ+J, JJ ), 1,
     $                        WORK31( 1, JJ-J+1 ), 1 )
   80       CONTINUE
            IF( J+JB.LE.N ) THEN
*
*              Apply the row interchanges to the other blocks.
*
               J2 = MIN( JU-J+1, KV ) - JB
               J3 = MAX( 0, JU-J-KV+1 )
*
*              Use DLASWP to apply the row interchanges to A12, A22, and
*              A32.
*
               CALL DLASWP( J2, AB( KV+1-JB, J+JB ), LDAB-1, 1, JB,
     $                      IPIV( J ), 1 )
*
*              Adjust the pivot indices.
*
               DO 90 I = J, J + JB - 1
                  IPIV( I ) = IPIV( I ) + J - 1
   90          CONTINUE
*
*              Apply the row interchanges to A13, A23, and A33
*              columnwise.
*
               K2 = J - 1 + JB + J2
               DO 110 I = 1, J3
                  JJ = K2 + I
                  DO 100 II = J + I - 1, J + JB - 1
                     IP = IPIV( II )
                     IF( IP.NE.II ) THEN
                        TEMP = AB( KV+1+II-JJ, JJ )
                        AB( KV+1+II-JJ, JJ ) = AB( KV+1+IP-JJ, JJ )
                        AB( KV+1+IP-JJ, JJ ) = TEMP
                     END IF
  100             CONTINUE
  110          CONTINUE
*
*              Update the relevant part of the trailing submatrix
*
               IF( J2.GT.0 ) THEN
*
*                 Update A12
*
                  CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit',
     $                        JB, J2, ONE, AB( KV+1, J ), LDAB-1,
     $                        AB( KV+1-JB, J+JB ), LDAB-1 )
*
                  IF( I2.GT.0 ) THEN
*
*                    Update A22
*
                     CALL DGEMM( 'No transpose', 'No transpose', I2, J2,
     $                           JB, -ONE, AB( KV+1+JB, J ), LDAB-1,
     $                           AB( KV+1-JB, J+JB ), LDAB-1, ONE,
     $                           AB( KV+1, J+JB ), LDAB-1 )
                  END IF
*
                  IF( I3.GT.0 ) THEN
*
*                    Update A32
*
                     CALL DGEMM( 'No transpose', 'No transpose', I3, J2,
     $                           JB, -ONE, WORK31, LDWORK,
     $                           AB( KV+1-JB, J+JB ), LDAB-1, ONE,
     $                           AB( KV+KL+1-JB, J+JB ), LDAB-1 )
                  END IF
               END IF
*
               IF( J3.GT.0 ) THEN
*
*                 Copy the lower triangle of A13 into the work array
*                 WORK13
*
                  DO 130 JJ = 1, J3
                     DO 120 II = JJ, JB
                        WORK13( II, JJ ) = AB( II-JJ+1, JJ+J+KV-1 )
  120                CONTINUE
  130             CONTINUE
*
*                 Update A13 in the work array
*
                  CALL DTRSM( 'Left', 'Lower', 'No transpose', 'Unit',
     $                        JB, J3, ONE, AB( KV+1, J ), LDAB-1,
     $                        WORK13, LDWORK )
*
                  IF( I2.GT.0 ) THEN
*
*                    Update A23
*
                     CALL DGEMM( 'No transpose', 'No transpose', I2, J3,
     $                           JB, -ONE, AB( KV+1+JB, J ), LDAB-1,
     $                           WORK13, LDWORK, ONE, AB( 1+JB, J+KV ),
     $                           LDAB-1 )
                  END IF
*
                  IF( I3.GT.0 ) THEN
*
*                    Update A33
*
                     CALL DGEMM( 'No transpose', 'No transpose', I3, J3,
     $                           JB, -ONE, WORK31, LDWORK, WORK13,
     $                           LDWORK, ONE, AB( 1+KL, J+KV ), LDAB-1 )
                  END IF
*
*                 Copy the lower triangle of A13 back into place
*
                  DO 150 JJ = 1, J3
                     DO 140 II = JJ, JB
                        AB( II-JJ+1, JJ+J+KV-1 ) = WORK13( II, JJ )
  140                CONTINUE
  150             CONTINUE
               END IF
            ELSE
*
*              Adjust the pivot indices.
*
               DO 160 I = J, J + JB - 1
                  IPIV( I ) = IPIV( I ) + J - 1
  160          CONTINUE
            END IF
*
*           Partially undo the interchanges in the current block to
*           restore the upper triangular form of A31 and copy the upper
*           triangle of A31 back into place
*
            DO 170 JJ = J + JB - 1, J, -1
               JP = IPIV( JJ ) - JJ + 1
               IF( JP.NE.1 ) THEN
*
*                 Apply interchange to columns J to JJ-1
*
                  IF( JP+JJ-1.LT.J+KL ) THEN
*
*                    The interchange does not affect A31
*
                     CALL DSWAP( JJ-J, AB( KV+1+JJ-J, J ), LDAB-1,
     $                           AB( KV+JP+JJ-J, J ), LDAB-1 )
                  ELSE
*
*                    The interchange does affect A31
*
                     CALL DSWAP( JJ-J, AB( KV+1+JJ-J, J ), LDAB-1,
     $                           WORK31( JP+JJ-J-KL, 1 ), LDWORK )
                  END IF
               END IF
*
*              Copy the current column of A31 back into place
*
               NW = MIN( I3, JJ-J+1 )
               IF( NW.GT.0 )
     $            CALL DCOPY( NW, WORK31( 1, JJ-J+1 ), 1,
     $                        AB( KV+KL+1-JJ+J, JJ ), 1 )
  170       CONTINUE
  180    CONTINUE
      END IF
*
      RETURN
*
*     End of DGBTRF
*
      END
      SUBROUTINE DGBTRS( TRANS, N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB,
     $                   INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      CHARACTER          TRANS
      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGBTRS solves a system of linear equations
*     A * X = B  or  A' * X = B
*  with a general band matrix A using the LU factorization computed
*  by DGBTRF.
*
*  Arguments
*  =========
*
*  TRANS   (input) CHARACTER*1
*          Specifies the form of the system of equations.
*          = 'N':  A * X = B  (No transpose)
*          = 'T':  A'* X = B  (Transpose)
*          = 'C':  A'* X = B  (Conjugate transpose = Transpose)
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  KL      (input) INTEGER
*          The number of subdiagonals within the band of A.  KL >= 0.
*
*  KU      (input) INTEGER
*          The number of superdiagonals within the band of A.  KU >= 0.
*
*  NRHS    (input) INTEGER
*          The number of right hand sides, i.e., the number of columns
*          of the matrix B.  NRHS >= 0.
*
*  AB      (input) DOUBLE PRECISION array, dimension (LDAB,N)
*          Details of the LU factorization of the band matrix A, as
*          computed by DGBTRF.  U is stored as an upper triangular band
*          matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
*          the multipliers used during the factorization are stored in
*          rows KL+KU+2 to 2*KL+KU+1.
*
*  LDAB    (input) INTEGER
*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
*
*  IPIV    (input) INTEGER array, dimension (N)
*          The pivot indices; for 1 <= i <= N, row i of the matrix was
*          interchanged with row IPIV(i).
*
*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
*          On entry, the right hand side matrix B.
*          On exit, the solution matrix X.
*
*  LDB     (input) INTEGER
*          The leading dimension of the array B.  LDB >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0:  successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            LNOTI, NOTRAN
      INTEGER            I, J, KD, L, LM
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGEMV, DGER, DSWAP, DTBSV, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      NOTRAN = LSAME( TRANS, 'N' )
      IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) .AND. .NOT.
     $    LSAME( TRANS, 'C' ) ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( KL.LT.0 ) THEN
         INFO = -3
      ELSE IF( KU.LT.0 ) THEN
         INFO = -4
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDAB.LT.( 2*KL+KU+1 ) ) THEN
         INFO = -7
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -10
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGBTRS', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 .OR. NRHS.EQ.0 )
     $   RETURN
*
      KD = KU + KL + 1
      LNOTI = KL.GT.0
*
      IF( NOTRAN ) THEN
*
*        Solve  A*X = B.
*
*        Solve L*X = B, overwriting B with X.
*
*        L is represented as a product of permutations and unit lower
*        triangular matrices L = P(1) * L(1) * ... * P(n-1) * L(n-1),
*        where each transformation L(i) is a rank-one modification of
*        the identity matrix.
*
         IF( LNOTI ) THEN
            DO 10 J = 1, N - 1
               LM = MIN( KL, N-J )
               L = IPIV( J )
               IF( L.NE.J )
     $            CALL DSWAP( NRHS, B( L, 1 ), LDB, B( J, 1 ), LDB )
               CALL DGER( LM, NRHS, -ONE, AB( KD+1, J ), 1, B( J, 1 ),
     $                    LDB, B( J+1, 1 ), LDB )
   10       CONTINUE
         END IF
*
         DO 20 I = 1, NRHS
*
*           Solve U*X = B, overwriting B with X.
*
            CALL DTBSV( 'Upper', 'No transpose', 'Non-unit', N, KL+KU,
     $                  AB, LDAB, B( 1, I ), 1 )
   20    CONTINUE
*
      ELSE
*
*        Solve A'*X = B.
*
         DO 30 I = 1, NRHS
*
*           Solve U'*X = B, overwriting B with X.
*
            CALL DTBSV( 'Upper', 'Transpose', 'Non-unit', N, KL+KU, AB,
     $                  LDAB, B( 1, I ), 1 )
   30    CONTINUE
*
*        Solve L'*X = B, overwriting B with X.
*
         IF( LNOTI ) THEN
            DO 40 J = N - 1, 1, -1
               LM = MIN( KL, N-J )
               CALL DGEMV( 'Transpose', LM, NRHS, -ONE, B( J+1, 1 ),
     $                     LDB, AB( KD+1, J ), 1, ONE, B( J, 1 ), LDB )
               L = IPIV( J )
               IF( L.NE.J )
     $            CALL DSWAP( NRHS, B( L, 1 ), LDB, B( J, 1 ), LDB )
   40       CONTINUE
         END IF
      END IF
      RETURN
*
*     End of DGBTRS
*
      END
      SUBROUTINE DGETF2( M, N, A, LDA, IPIV, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     June 30, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INFO, LDA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DGETF2 computes an LU factorization of a general m-by-n matrix A
*  using partial pivoting with row interchanges.
*
*  The factorization has the form
*     A = P * L * U
*  where P is a permutation matrix, L is lower triangular with unit
*  diagonal elements (lower trapezoidal if m > n), and U is upper
*  triangular (upper trapezoidal if m < n).
*
*  This is the right-looking Level 2 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the m by n matrix to be factored.
*          On exit, the factors L and U from the factorization
*          A = P*L*U; the unit diagonal elements of L are not stored.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,M).
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -k, the k-th argument had an illegal value
*          > 0: if INFO = k, U(k,k) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            J, JP
*     ..
*     .. External Functions ..
      INTEGER            IDAMAX
      EXTERNAL           IDAMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGER, DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -4
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGETF2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
      DO 10 J = 1, MIN( M, N )
*
*        Find pivot and test for singularity.
*
         JP = J - 1 + IDAMAX( M-J+1, A( J, J ), 1 )
         IPIV( J ) = JP
         IF( A( JP, J ).NE.ZERO ) THEN
*
*           Apply the interchange to columns 1:N.
*
            IF( JP.NE.J )
     $         CALL DSWAP( N, A( J, 1 ), LDA, A( JP, 1 ), LDA )
*
*           Compute elements J+1:M of J-th column.
*
            IF( J.LT.M )
     $         CALL DSCAL( M-J, ONE / A( J, J ), A( J+1, J ), 1 )
*
         ELSE IF( INFO.EQ.0 ) THEN
*
            INFO = J
         END IF
*
         IF( J.LT.MIN( M, N ) ) THEN
*
*           Update trailing submatrix.
*
            CALL DGER( M-J, N-J, -ONE, A( J+1, J ), 1, A( J, J+1 ), LDA,
     $                 A( J+1, J+1 ), LDA )
         END IF
   10 CONTINUE
      RETURN
*
*     End of DGETF2
*
      END
      SUBROUTINE DLASWP( N, A, LDA, K1, K2, IPIV, INCX )
*
*  -- LAPACK auxiliary routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     October 31, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INCX, K1, K2, LDA, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DLASWP performs a series of row interchanges on the matrix A.
*  One row interchange is initiated for each of rows K1 through K2 of A.
*
*  Arguments
*  =========
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the matrix of column dimension N to which the row
*          interchanges will be applied.
*          On exit, the permuted matrix.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.
*
*  K1      (input) INTEGER
*          The first element of IPIV for which a row interchange will
*          be done.
*
*  K2      (input) INTEGER
*          The last element of IPIV for which a row interchange will
*          be done.
*
*  IPIV    (input) INTEGER array, dimension (M*abs(INCX))
*          The vector of pivot indices.  Only the elements in positions
*          K1 through K2 of IPIV are accessed.
*          IPIV(K) = L implies rows K and L are to be interchanged.
*
*  INCX    (input) INTEGER
*          The increment between successive values of IPIV.  If IPIV
*          is negative, the pivots are applied in reverse order.
*
* =====================================================================
*
*     .. Local Scalars ..
      INTEGER            I, IP, IX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DSWAP
*     ..
*     .. Executable Statements ..
*
*     Interchange row I with row IPIV(I) for each of rows K1 through K2.
*
      IF( INCX.EQ.0 )
     $   RETURN
      IF( INCX.GT.0 ) THEN
         IX = K1
      ELSE
         IX = 1 + ( 1-K2 )*INCX
      END IF
      IF( INCX.EQ.1 ) THEN
         DO 10 I = K1, K2
            IP = IPIV( I )
            IF( IP.NE.I )
     $         CALL DSWAP( N, A( I, 1 ), LDA, A( IP, 1 ), LDA )
   10    CONTINUE
      ELSE IF( INCX.GT.1 ) THEN
         DO 20 I = K1, K2
            IP = IPIV( IX )
            IF( IP.NE.I )
     $         CALL DSWAP( N, A( I, 1 ), LDA, A( IP, 1 ), LDA )
            IX = IX + INCX
   20    CONTINUE
      ELSE IF( INCX.LT.0 ) THEN
         DO 30 I = K2, K1, -1
            IP = IPIV( IX )
            IF( IP.NE.I )
     $         CALL DSWAP( N, A( I, 1 ), LDA, A( IP, 1 ), LDA )
            IX = IX + INCX
   30    CONTINUE
      END IF
*
      RETURN
*
*     End of DLASWP
*
      END
      SUBROUTINE XERBLA( SRNAME, INFO )
*
*  -- LAPACK auxiliary routine (preliminary version) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      CHARACTER*6        SRNAME
      INTEGER            INFO
*     ..
*
*  Purpose
*  =======
*
*  XERBLA  is an error handler for the LAPACK routines.
*  It is called by an LAPACK routine if an input parameter has an
*  invalid value.  A message is printed and execution stops.
*
*  Installers may consider modifying the STOP statement in order to
*  call system-specific exception-handling facilities.
*
*  Arguments
*  =========
*
*  SRNAME  (input) CHARACTER*6
*          The name of the routine which called XERBLA.
*
*  INFO    (input) INTEGER
*          The position of the invalid parameter in the parameter list
*          of the calling routine.
*
*
      WRITE( *, FMT = 9999 )SRNAME, INFO
*
      STOP
*
 9999 FORMAT( ' ** On entry to ', A6, ' parameter number ', I2, ' had ',
     $      'an illegal value' )
*
*     End of XERBLA
*
      END
      SUBROUTINE DTRTRI( UPLO, DIAG, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     March 31, 1993
*
*     .. Scalar Arguments ..
      CHARACTER          DIAG, UPLO
      INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRTRI computes the inverse of a real upper or lower triangular
*  matrix A.
*
*  This is the Level 3 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          = 'U':  A is upper triangular;
*          = 'L':  A is lower triangular.
*
*  DIAG    (input) CHARACTER*1
*          = 'N':  A is non-unit triangular;
*          = 'U':  A is unit triangular.
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the triangular matrix A.  If UPLO = 'U', the
*          leading N-by-N upper triangular part of the array A contains
*          the upper triangular matrix, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading N-by-N lower triangular part of the array A contains
*          the lower triangular matrix, and the strictly upper
*          triangular part of A is not referenced.  If DIAG = 'U', the
*          diagonal elements of A are also not referenced and are
*          assumed to be 1.
*          On exit, the (triangular) inverse of the original matrix, in
*          the same storage format.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*          > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
*               matrix is singular and its inverse can not be computed.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            NOUNIT, UPPER
      INTEGER            J, JB, NB, NN
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      INTEGER            ILAENV
      EXTERNAL           LSAME, ILAENV
*     ..
*     .. External Subroutines ..
      EXTERNAL           DTRMM, DTRSM, DTRTI2, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      NOUNIT = LSAME( DIAG, 'N' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DTRTRI', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( N.EQ.0 )
     $   RETURN
*
*     Check for singularity if non-unit.
*
      IF( NOUNIT ) THEN
         DO 10 INFO = 1, N
            IF( A( INFO, INFO ).EQ.ZERO )
     $         RETURN
   10    CONTINUE
         INFO = 0
      END IF
*
*     Determine the block size for this environment.
*
      NB = ILAENV( 1, 'DTRTRI', UPLO // DIAG, N, -1, -1, -1 )
      IF( NB.LE.1 .OR. NB.GE.N ) THEN
*
*        Use unblocked code
*
         CALL DTRTI2( UPLO, DIAG, N, A, LDA, INFO )
      ELSE
*
*        Use blocked code
*
         IF( UPPER ) THEN
*
*           Compute inverse of upper triangular matrix
*
            DO 20 J = 1, N, NB
               JB = MIN( NB, N-J+1 )
*
*              Compute rows 1:j-1 of current block column
*
               CALL DTRMM( 'Left', 'Upper', 'No transpose', DIAG, J-1,
     $                     JB, ONE, A, LDA, A( 1, J ), LDA )
               CALL DTRSM( 'Right', 'Upper', 'No transpose', DIAG, J-1,
     $                     JB, -ONE, A( J, J ), LDA, A( 1, J ), LDA )
*
*              Compute inverse of current diagonal block
*
               CALL DTRTI2( 'Upper', DIAG, JB, A( J, J ), LDA, INFO )
   20       CONTINUE
         ELSE
*
*           Compute inverse of lower triangular matrix
*
            NN = ( ( N-1 ) / NB )*NB + 1
            DO 30 J = NN, 1, -NB
               JB = MIN( NB, N-J+1 )
               IF( J+JB.LE.N ) THEN
*
*                 Compute rows j+jb:n of current block column
*
                  CALL DTRMM( 'Left', 'Lower', 'No transpose', DIAG,
     $                        N-J-JB+1, JB, ONE, A( J+JB, J+JB ), LDA,
     $                        A( J+JB, J ), LDA )
                  CALL DTRSM( 'Right', 'Lower', 'No transpose', DIAG,
     $                        N-J-JB+1, JB, -ONE, A( J, J ), LDA,
     $                        A( J+JB, J ), LDA )
               END IF
*
*              Compute inverse of current diagonal block
*
               CALL DTRTI2( 'Lower', DIAG, JB, A( J, J ), LDA, INFO )
   30       CONTINUE
         END IF
      END IF
*
      RETURN
*
*     End of DTRTRI
*
      END
      SUBROUTINE DGBTF2( M, N, KL, KU, AB, LDAB, IPIV, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      INTEGER            INFO, KL, KU, LDAB, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            IPIV( * )
      DOUBLE PRECISION   AB( LDAB, * )
*     ..
*
*  Purpose
*  =======
*
*  DGBTF2 computes an LU factorization of a real m-by-n band matrix A
*  using partial pivoting with row interchanges.
*
*  This is the unblocked version of the algorithm, calling Level 2 BLAS.
*
*  Arguments
*  =========
*
*  M       (input) INTEGER
*          The number of rows of the matrix A.  M >= 0.
*
*  N       (input) INTEGER
*          The number of columns of the matrix A.  N >= 0.
*
*  KL      (input) INTEGER
*          The number of subdiagonals within the band of A.  KL >= 0.
*
*  KU      (input) INTEGER
*          The number of superdiagonals within the band of A.  KU >= 0.
*
*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)
*          On entry, the matrix A in band storage, in rows KL+1 to
*          2*KL+KU+1; rows 1 to KL of the array need not be set.
*          The j-th column of A is stored in the j-th column of the
*          array AB as follows:
*          AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)
*
*          On exit, details of the factorization: U is stored as an
*          upper triangular band matrix with KL+KU superdiagonals in
*          rows 1 to KL+KU+1, and the multipliers used during the
*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
*          See below for further details.
*
*  LDAB    (input) INTEGER
*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
*
*  IPIV    (output) INTEGER array, dimension (min(M,N))
*          The pivot indices; for 1 <= i <= min(M,N), row i of the
*          matrix was interchanged with row IPIV(i).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -i, the i-th argument had an illegal value
*          > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
*               has been completed, but the factor U is exactly
*               singular, and division by zero will occur if it is used
*               to solve a system of equations.
*
*  Further Details
*  ===============
*
*  The band storage scheme is illustrated by the following example, when
*  M = N = 6, KL = 2, KU = 1:
*
*  On entry:                       On exit:
*
*      *    *    *    +    +    +       *    *    *   u14  u25  u36
*      *    *    +    +    +    +       *    *   u13  u24  u35  u46
*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
*
*  Array elements marked * are not used by the routine; elements marked
*  + need not be set on entry, but are required by the routine to store
*  elements of U, because of fill-in resulting from the row
*  interchanges.
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
*     ..
*     .. Local Scalars ..
      INTEGER            I, J, JP, JU, KM, KV
*     ..
*     .. External Functions ..
      INTEGER            IDAMAX
      EXTERNAL           IDAMAX
*     ..
*     .. External Subroutines ..
      EXTERNAL           DGER, DSCAL, DSWAP, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX, MIN
*     ..
*     .. Executable Statements ..
*
*     KV is the number of superdiagonals in the factor U, allowing for
*     fill-in.
*
      KV = KU + KL
*
*     Test the input parameters.
*
      INFO = 0
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( KL.LT.0 ) THEN
         INFO = -3
      ELSE IF( KU.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDAB.LT.KL+KV+1 ) THEN
         INFO = -6
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DGBTF2', -INFO )
         RETURN
      END IF
*
*     Quick return if possible
*
      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
*
*     Gaussian elimination with partial pivoting
*
*     Set fill-in elements in columns KU+2 to KV to zero.
*
      DO 20 J = KU + 2, MIN( KV, N )
         DO 10 I = KV - J + 2, KL
            AB( I, J ) = ZERO
   10    CONTINUE
   20 CONTINUE
*
*     JU is the index of the last column affected by the current stage
*     of the factorization.
*
      JU = 1
*
      DO 40 J = 1, MIN( M, N )
*
*        Set fill-in elements in column J+KV to zero.
*
         IF( J+KV.LE.N ) THEN
            DO 30 I = 1, KL
               AB( I, J+KV ) = ZERO
   30       CONTINUE
         END IF
*
*        Find pivot and test for singularity. KM is the number of
*        subdiagonal elements in the current column.
*
         KM = MIN( KL, M-J )
         JP = IDAMAX( KM+1, AB( KV+1, J ), 1 )
         IPIV( J ) = JP + J - 1
         IF( AB( KV+JP, J ).NE.ZERO ) THEN
            JU = MAX( JU, MIN( J+KU+JP-1, N ) )
*
*           Apply interchange to columns J to JU.
*
            IF( JP.NE.1 )
     $         CALL DSWAP( JU-J+1, AB( KV+JP, J ), LDAB-1,
     $                     AB( KV+1, J ), LDAB-1 )
*
            IF( KM.GT.0 ) THEN
*
*              Compute multipliers.
*
               CALL DSCAL( KM, ONE / AB( KV+1, J ), AB( KV+2, J ), 1 )
*
*              Update trailing submatrix within the band.
*
               IF( JU.GT.J )
     $            CALL DGER( KM, JU-J, -ONE, AB( KV+2, J ), 1,
     $                       AB( KV, J+1 ), LDAB-1, AB( KV+1, J+1 ),
     $                       LDAB-1 )
            END IF
         ELSE
*
*           If pivot is zero, set INFO to the index of the pivot
*           unless a zero pivot has already been found.
*
            IF( INFO.EQ.0 )
     $         INFO = J
         END IF
   40 CONTINUE
      RETURN
*
*     End of DGBTF2
*
      END
      SUBROUTINE DTRTI2( UPLO, DIAG, N, A, LDA, INFO )
*
*  -- LAPACK routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     February 29, 1992
*
*     .. Scalar Arguments ..
      CHARACTER          DIAG, UPLO
      INTEGER            INFO, LDA, N
*     ..
*     .. Array Arguments ..
      DOUBLE PRECISION   A( LDA, * )
*     ..
*
*  Purpose
*  =======
*
*  DTRTI2 computes the inverse of a real upper or lower triangular
*  matrix.
*
*  This is the Level 2 BLAS version of the algorithm.
*
*  Arguments
*  =========
*
*  UPLO    (input) CHARACTER*1
*          Specifies whether the matrix A is upper or lower triangular.
*          = 'U':  Upper triangular
*          = 'L':  Lower triangular
*
*  DIAG    (input) CHARACTER*1
*          Specifies whether or not the matrix A is unit triangular.
*          = 'N':  Non-unit triangular
*          = 'U':  Unit triangular
*
*  N       (input) INTEGER
*          The order of the matrix A.  N >= 0.
*
*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
*          On entry, the triangular matrix A.  If UPLO = 'U', the
*          leading n by n upper triangular part of the array A contains
*          the upper triangular matrix, and the strictly lower
*          triangular part of A is not referenced.  If UPLO = 'L', the
*          leading n by n lower triangular part of the array A contains
*          the lower triangular matrix, and the strictly upper
*          triangular part of A is not referenced.  If DIAG = 'U', the
*          diagonal elements of A are also not referenced and are
*          assumed to be 1.
*
*          On exit, the (triangular) inverse of the original matrix, in
*          the same storage format.
*
*  LDA     (input) INTEGER
*          The leading dimension of the array A.  LDA >= max(1,N).
*
*  INFO    (output) INTEGER
*          = 0: successful exit
*          < 0: if INFO = -k, the k-th argument had an illegal value
*
*  =====================================================================
*
*     .. Parameters ..
      DOUBLE PRECISION   ONE
      PARAMETER          ( ONE = 1.0D+0 )
*     ..
*     .. Local Scalars ..
      LOGICAL            NOUNIT, UPPER
      INTEGER            J
      DOUBLE PRECISION   AJJ
*     ..
*     .. External Functions ..
      LOGICAL            LSAME
      EXTERNAL           LSAME
*     ..
*     .. External Subroutines ..
      EXTERNAL           DSCAL, DTRMV, XERBLA
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          MAX
*     ..
*     .. Executable Statements ..
*
*     Test the input parameters.
*
      INFO = 0
      UPPER = LSAME( UPLO, 'U' )
      NOUNIT = LSAME( DIAG, 'N' )
      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOUNIT .AND. .NOT.LSAME( DIAG, 'U' ) ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      END IF
      IF( INFO.NE.0 ) THEN
         CALL XERBLA( 'DTRTI2', -INFO )
         RETURN
      END IF
*
      IF( UPPER ) THEN
*
*        Compute inverse of upper triangular matrix.
*
         DO 10 J = 1, N
            IF( NOUNIT ) THEN
               A( J, J ) = ONE / A( J, J )
               AJJ = -A( J, J )
            ELSE
               AJJ = -ONE
            END IF
*
*           Compute elements 1:j-1 of j-th column.
*
            CALL DTRMV( 'Upper', 'No transpose', DIAG, J-1, A, LDA,
     $                  A( 1, J ), 1 )
            CALL DSCAL( J-1, AJJ, A( 1, J ), 1 )
   10    CONTINUE
      ELSE
*
*        Compute inverse of lower triangular matrix.
*
         DO 20 J = N, 1, -1
            IF( NOUNIT ) THEN
               A( J, J ) = ONE / A( J, J )
               AJJ = -A( J, J )
            ELSE
               AJJ = -ONE
            END IF
            IF( J.LT.N ) THEN
*
*              Compute elements j+1:n of j-th column.
*
               CALL DTRMV( 'Lower', 'No transpose', DIAG, N-J,
     $                     A( J+1, J+1 ), LDA, A( J+1, J ), 1 )
               CALL DSCAL( N-J, AJJ, A( J+1, J ), 1 )
            END IF
   20    CONTINUE
      END IF
*
      RETURN
*
*     End of DTRTI2
*
      END
      INTEGER          FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3,
     $                 N4 )
*
*  -- LAPACK auxiliary routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
*
*     .. Scalar Arguments ..
      CHARACTER*( * )    NAME, OPTS
      INTEGER            ISPEC, N1, N2, N3, N4
*     ..
*
*  Purpose
*  =======
*
*  ILAENV is called from the LAPACK routines to choose problem-dependent
*  parameters for the local environment.  See ISPEC for a description of
*  the parameters.
*
*  This version provides a set of parameters which should give good,
*  but not optimal, performance on many of the currently available
*  computers.  Users are encouraged to modify this subroutine to set
*  the tuning parameters for their particular machine using the option
*  and problem size information in the arguments.
*
*  This routine will not function correctly if it is converted to all
*  lower case.  Converting it to all upper case is allowed.
*
*  Arguments
*  =========
*
*  ISPEC   (input) INTEGER
*          Specifies the parameter to be returned as the value of
*          ILAENV.
*          = 1: the optimal blocksize; if this value is 1, an unblocked
*               algorithm will give the best performance.
*          = 2: the minimum block size for which the block routine
*               should be used; if the usable block size is less than
*               this value, an unblocked routine should be used.
*          = 3: the crossover point (in a block routine, for N less
*               than this value, an unblocked routine should be used)
*          = 4: the number of shifts, used in the nonsymmetric
*               eigenvalue routines
*          = 5: the minimum column dimension for blocking to be used;
*               rectangular blocks must have dimension at least k by m,
*               where k is given by ILAENV(2,...) and m by ILAENV(5,...)
*          = 6: the crossover point for the SVD (when reducing an m by n
*               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
*               this value, a QR factorization is used first to reduce
*               the matrix to a triangular form.)
*          = 7: the number of processors
*          = 8: the crossover point for the multishift QR and QZ methods
*               for nonsymmetric eigenvalue problems.
*
*  NAME    (input) CHARACTER*(*)
*          The name of the calling subroutine, in either upper case or
*          lower case.
*
*  OPTS    (input) CHARACTER*(*)
*          The character options to the subroutine NAME, concatenated
*          into a single character string.  For example, UPLO = 'U',
*          TRANS = 'T', and DIAG = 'N' for a triangular routine would
*          be specified as OPTS = 'UTN'.
*
*  N1      (input) INTEGER
*  N2      (input) INTEGER
*  N3      (input) INTEGER
*  N4      (input) INTEGER
*          Problem dimensions for the subroutine NAME; these may not all
*          be required.
*
* (ILAENV) (output) INTEGER
*          >= 0: the value of the parameter specified by ISPEC
*          < 0:  if ILAENV = -k, the k-th argument had an illegal value.
*
*  Further Details
*  ===============
*
*  The following conventions have been used when calling ILAENV from the
*  LAPACK routines:
*  1)  OPTS is a concatenation of all of the character options to
*      subroutine NAME, in the same order that they appear in the
*      argument list for NAME, even if they are not used in determining
*      the value of the parameter specified by ISPEC.
*  2)  The problem dimensions N1, N2, N3, N4 are specified in the order
*      that they appear in the argument list for NAME.  N1 is used
*      first, N2 second, and so on, and unused problem dimensions are
*      passed a value of -1.
*  3)  The parameter value returned by ILAENV is checked for validity in
*      the calling subroutine.  For example, ILAENV is used to retrieve
*      the optimal blocksize for STRTRI as follows:
*
*      NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
*      IF( NB.LE.1 ) NB = MAX( 1, N )
*
*  =====================================================================
*
*     .. Local Scalars ..
      LOGICAL            CNAME, SNAME
      CHARACTER*1        C1
      CHARACTER*2        C2, C4
      CHARACTER*3        C3
      CHARACTER*6        SUBNAM
      INTEGER            I, IC, IZ, NB, NBMIN, NX
*     ..
*     .. Intrinsic Functions ..
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL
*     ..
*     .. Executable Statements ..
*
      GO TO ( 100, 100, 100, 400, 500, 600, 700, 800 ) ISPEC
*
*     Invalid value for ISPEC
*
      ILAENV = -1
      RETURN
*
  100 CONTINUE
*
*     Convert NAME to upper case if the first character is lower case.
*
      ILAENV = 1
      SUBNAM = NAME
      IC = ICHAR( SUBNAM( 1:1 ) )
      IZ = ICHAR( 'Z' )
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN
*
*        ASCII character set
*
         IF( IC.GE.97 .AND. IC.LE.122 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 10 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.97 .AND. IC.LE.122 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   10       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN
*
*        EBCDIC character set
*
         IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $       ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $       ( IC.GE.162 .AND. IC.LE.169 ) ) THEN
            SUBNAM( 1:1 ) = CHAR( IC+64 )
            DO 20 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.
     $             ( IC.GE.145 .AND. IC.LE.153 ) .OR.
     $             ( IC.GE.162 .AND. IC.LE.169 ) )
     $            SUBNAM( I:I ) = CHAR( IC+64 )
   20       CONTINUE
         END IF
*
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN
*
*        Prime machines:  ASCII+128
*
         IF( IC.GE.225 .AND. IC.LE.250 ) THEN
            SUBNAM( 1:1 ) = CHAR( IC-32 )
            DO 30 I = 2, 6
               IC = ICHAR( SUBNAM( I:I ) )
               IF( IC.GE.225 .AND. IC.LE.250 )
     $            SUBNAM( I:I ) = CHAR( IC-32 )
   30       CONTINUE
         END IF
      END IF
*
      C1 = SUBNAM( 1:1 )
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D'
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z'
      IF( .NOT.( CNAME .OR. SNAME ) )
     $   RETURN
      C2 = SUBNAM( 2:3 )
      C3 = SUBNAM( 4:6 )
      C4 = C3( 2:3 )
*
      GO TO ( 110, 200, 300 ) ISPEC
*
  110 CONTINUE
*
*     ISPEC = 1:  block size
*
*     In these examples, separate code is provided for setting NB for
*     real and complex.  We assume that NB will take the same value in
*     single or double precision.
*
      NB = 1
*
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $            C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NB = 32
            ELSE
               NB = 32
            END IF
         ELSE IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2.EQ.'PO' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NB = 1
         ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN
            NB = 64
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            NB = 64
         ELSE IF( C3.EQ.'TRD' ) THEN
            NB = 1
         ELSE IF( C3.EQ.'GST' ) THEN
            NB = 64
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NB = 32
            END IF
         END IF
      ELSE IF( C2.EQ.'GB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               IF( N4.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            ELSE
               IF( N4.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            END IF
         END IF
      ELSE IF( C2.EQ.'PB' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               IF( N2.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            ELSE
               IF( N2.LE.64 ) THEN
                  NB = 1
               ELSE
                  NB = 32
               END IF
            END IF
         END IF
      ELSE IF( C2.EQ.'TR' ) THEN
         IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( C2.EQ.'LA' ) THEN
         IF( C3.EQ.'UUM' ) THEN
            IF( SNAME ) THEN
               NB = 64
            ELSE
               NB = 64
            END IF
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN
         IF( C3.EQ.'EBZ' ) THEN
            NB = 1
         END IF
      END IF
      ILAENV = NB
      RETURN
*
  200 CONTINUE
*
*     ISPEC = 2:  minimum block size
*
      NBMIN = 2
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $       C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         ELSE IF( C3.EQ.'TRI' ) THEN
            IF( SNAME ) THEN
               NBMIN = 2
            ELSE
               NBMIN = 2
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( C3.EQ.'TRF' ) THEN
            IF( SNAME ) THEN
               NBMIN = 8
            ELSE
               NBMIN = 8
            END IF
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRD' ) THEN
            NBMIN = 2
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NBMIN = 2
            END IF
         END IF
      END IF
      ILAENV = NBMIN
      RETURN
*
  300 CONTINUE
*
*     ISPEC = 3:  crossover point
*
      NX = 0
      IF( C2.EQ.'GE' ) THEN
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.
     $       C3.EQ.'QLF' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3.EQ.'HRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         ELSE IF( C3.EQ.'BRD' ) THEN
            IF( SNAME ) THEN
               NX = 128
            ELSE
               NX = 128
            END IF
         END IF
      ELSE IF( C2.EQ.'SY' ) THEN
         IF( SNAME .AND. C3.EQ.'TRD' ) THEN
            NX = 1
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN
         IF( C3.EQ.'TRD' ) THEN
            NX = 1
         END IF
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NX = 128
            END IF
         END IF
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN
         IF( C3( 1:1 ).EQ.'G' ) THEN
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.
     $          C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.
     $          C4.EQ.'BR' ) THEN
               NX = 128
            END IF
         END IF
      END IF
      ILAENV = NX
      RETURN
*
  400 CONTINUE
*
*     ISPEC = 4:  number of shifts (used by xHSEQR)
*
      ILAENV = 6
      RETURN
*
  500 CONTINUE
*
*     ISPEC = 5:  minimum column dimension (not used)
*
      ILAENV = 2
      RETURN
*
  600 CONTINUE 
*
*     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)
*
      ILAENV = INT( REAL( MIN( N1, N2 ) )*1.6E0 )
      RETURN
*
  700 CONTINUE
*
*     ISPEC = 7:  number of processors (not used)
*
      ILAENV = 1
      RETURN
*
  800 CONTINUE
*
*     ISPEC = 8:  crossover point for multishift (used by xHSEQR)
*
      ILAENV = 50
      RETURN
*
*     End of ILAENV
*
      END
      LOGICAL          FUNCTION LSAME( CA, CB )
*
*  -- LAPACK auxiliary routine (version 2.0) --
*     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
*     Courant Institute, Argonne National Lab, and Rice University
*     September 30, 1994
*
*     .. Scalar Arguments ..
      CHARACTER          CA, CB
*     ..
*
*  Purpose
*  =======
*
*  LSAME returns .TRUE. if CA is the same letter as CB regardless of
*  case.
*
*  Arguments
*  =========
*
*  CA      (input) CHARACTER*1
*  CB      (input) CHARACTER*1
*          CA and CB specify the single characters to be compared.
*
* =====================================================================
*
*     .. Intrinsic Functions ..
      INTRINSIC          ICHAR
*     ..
*     .. Local Scalars ..
      INTEGER            INTA, INTB, ZCODE
*     ..
*     .. Executable Statements ..
*
*     Test if the characters are equal
*
      LSAME = CA.EQ.CB
      IF( LSAME )
     $   RETURN
*
*     Now test for equivalence if both characters are alphabetic.
*
      ZCODE = ICHAR( 'Z' )
*
*     Use 'Z' rather than 'A' so that ASCII can be detected on Prime
*     machines, on which ICHAR returns a value with bit 8 set.
*     ICHAR('A') on Prime machines returns 193 which is the same as
*     ICHAR('A') on an EBCDIC machine.
*
      INTA = ICHAR( CA )
      INTB = ICHAR( CB )
*
      IF( ZCODE.EQ.90 .OR. ZCODE.EQ.122 ) THEN
*
*        ASCII is assumed - ZCODE is the ASCII code of either lower or
*        upper case 'Z'.
*
         IF( INTA.GE.97 .AND. INTA.LE.122 ) INTA = INTA - 32
         IF( INTB.GE.97 .AND. INTB.LE.122 ) INTB = INTB - 32
*
      ELSE IF( ZCODE.EQ.233 .OR. ZCODE.EQ.169 ) THEN
*
*        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
*        upper case 'Z'.
*
         IF( INTA.GE.129 .AND. INTA.LE.137 .OR.
     $       INTA.GE.145 .AND. INTA.LE.153 .OR.
     $       INTA.GE.162 .AND. INTA.LE.169 ) INTA = INTA + 64
         IF( INTB.GE.129 .AND. INTB.LE.137 .OR.
     $       INTB.GE.145 .AND. INTB.LE.153 .OR.
     $       INTB.GE.162 .AND. INTB.LE.169 ) INTB = INTB + 64
*
      ELSE IF( ZCODE.EQ.218 .OR. ZCODE.EQ.250 ) THEN
*
*        ASCII is assumed, on Prime machines - ZCODE is the ASCII code
*        plus 128 of either lower or upper case 'Z'.
*
         IF( INTA.GE.225 .AND. INTA.LE.250 ) INTA = INTA - 32
         IF( INTB.GE.225 .AND. INTB.LE.250 ) INTB = INTB - 32
      END IF
      LSAME = INTA.EQ.INTB
*
*     RETURN
*
*     End of LSAME
*
      END
